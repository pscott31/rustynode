pub mod vega {
    #![allow(unknown_lints)]
    #![allow(clippy::all)]
    #![allow(unused_attributes)]
    #![allow(box_pointers)]
    #![allow(dead_code)]
    #![allow(missing_docs)]
    #![allow(non_camel_case_types)]
    #![allow(non_snake_case)]
    #![allow(non_upper_case_globals)]
    #![allow(trivial_casts)]
    #![allow(unused_results)]
    #![allow(unused_mut)]
    //! Generated file from `vega/vega.proto`
    /// Generated files are compatible only with the same version
    /// of protobuf runtime.
    const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;
    pub struct Party {
        pub id: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Party {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Party {
        #[inline]
        fn eq(&self, other: &Party) -> bool {
            self.id == other.id && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Party {
        #[inline]
        fn clone(&self) -> Party {
            Party {
                id: ::core::clone::Clone::clone(&self.id),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Party {
        #[inline]
        fn default() -> Party {
            Party {
                id: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Party {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Party",
                "id",
                &&self.id,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a Party {
        fn default() -> &'a Party {
            <Party as ::protobuf::Message>::default_instance()
        }
    }
    impl Party {
        pub fn new() -> Party {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >("id", |m: &Party| { &m.id }, |m: &mut Party| { &mut m.id }),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                Party,
            >("Party", fields, oneofs)
        }
    }
    impl ::protobuf::Message for Party {
        const NAME: &'static str = "Party";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.id = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.id);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.id.is_empty() {
                os.write_string(1, &self.id)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> Party {
            Party::new()
        }
        fn clear(&mut self) {
            self.id.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static Party {
            static instance: Party = Party {
                id: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for Party {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor().message_by_package_relative_name("Party").unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for Party {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for Party {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct RiskFactor {
        pub market: ::std::string::String,
        pub short: ::std::string::String,
        pub long: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for RiskFactor {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for RiskFactor {
        #[inline]
        fn eq(&self, other: &RiskFactor) -> bool {
            self.market == other.market && self.short == other.short
                && self.long == other.long && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RiskFactor {
        #[inline]
        fn clone(&self) -> RiskFactor {
            RiskFactor {
                market: ::core::clone::Clone::clone(&self.market),
                short: ::core::clone::Clone::clone(&self.short),
                long: ::core::clone::Clone::clone(&self.long),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for RiskFactor {
        #[inline]
        fn default() -> RiskFactor {
            RiskFactor {
                market: ::core::default::Default::default(),
                short: ::core::default::Default::default(),
                long: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for RiskFactor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "RiskFactor",
                "market",
                &&self.market,
                "short",
                &&self.short,
                "long",
                &&self.long,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a RiskFactor {
        fn default() -> &'a RiskFactor {
            <RiskFactor as ::protobuf::Message>::default_instance()
        }
    }
    impl RiskFactor {
        pub fn new() -> RiskFactor {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "market",
                        |m: &RiskFactor| { &m.market },
                        |m: &mut RiskFactor| { &mut m.market },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "short",
                        |m: &RiskFactor| { &m.short },
                        |m: &mut RiskFactor| { &mut m.short },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "long",
                        |m: &RiskFactor| { &m.long },
                        |m: &mut RiskFactor| { &mut m.long },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                RiskFactor,
            >("RiskFactor", fields, oneofs)
        }
    }
    impl ::protobuf::Message for RiskFactor {
        const NAME: &'static str = "RiskFactor";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.market = is.read_string()?;
                    }
                    18 => {
                        self.short = is.read_string()?;
                    }
                    26 => {
                        self.long = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.market.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.market);
            }
            if !self.short.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.short);
            }
            if !self.long.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.long);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.market.is_empty() {
                os.write_string(1, &self.market)?;
            }
            if !self.short.is_empty() {
                os.write_string(2, &self.short)?;
            }
            if !self.long.is_empty() {
                os.write_string(3, &self.long)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> RiskFactor {
            RiskFactor::new()
        }
        fn clear(&mut self) {
            self.market.clear();
            self.short.clear();
            self.long.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static RiskFactor {
            static instance: RiskFactor = RiskFactor {
                market: ::std::string::String::new(),
                short: ::std::string::String::new(),
                long: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for RiskFactor {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("RiskFactor")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for RiskFactor {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for RiskFactor {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct PeggedOrder {
        pub reference: ::protobuf::EnumOrUnknown<PeggedReference>,
        pub offset: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PeggedOrder {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PeggedOrder {
        #[inline]
        fn eq(&self, other: &PeggedOrder) -> bool {
            self.reference == other.reference && self.offset == other.offset
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PeggedOrder {
        #[inline]
        fn clone(&self) -> PeggedOrder {
            PeggedOrder {
                reference: ::core::clone::Clone::clone(&self.reference),
                offset: ::core::clone::Clone::clone(&self.offset),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for PeggedOrder {
        #[inline]
        fn default() -> PeggedOrder {
            PeggedOrder {
                reference: ::core::default::Default::default(),
                offset: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PeggedOrder {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "PeggedOrder",
                "reference",
                &&self.reference,
                "offset",
                &&self.offset,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a PeggedOrder {
        fn default() -> &'a PeggedOrder {
            <PeggedOrder as ::protobuf::Message>::default_instance()
        }
    }
    impl PeggedOrder {
        pub fn new() -> PeggedOrder {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "reference",
                        |m: &PeggedOrder| { &m.reference },
                        |m: &mut PeggedOrder| { &mut m.reference },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "offset",
                        |m: &PeggedOrder| { &m.offset },
                        |m: &mut PeggedOrder| { &mut m.offset },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                PeggedOrder,
            >("PeggedOrder", fields, oneofs)
        }
    }
    impl ::protobuf::Message for PeggedOrder {
        const NAME: &'static str = "PeggedOrder";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.reference = is.read_enum_or_unknown()?;
                    }
                    18 => {
                        self.offset = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.reference
                != ::protobuf::EnumOrUnknown::new(
                    PeggedReference::PEGGED_REFERENCE_UNSPECIFIED,
                )
            {
                my_size += ::protobuf::rt::int32_size(1, self.reference.value());
            }
            if !self.offset.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.offset);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if self.reference
                != ::protobuf::EnumOrUnknown::new(
                    PeggedReference::PEGGED_REFERENCE_UNSPECIFIED,
                )
            {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.reference))?;
            }
            if !self.offset.is_empty() {
                os.write_string(2, &self.offset)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> PeggedOrder {
            PeggedOrder::new()
        }
        fn clear(&mut self) {
            self
                .reference = ::protobuf::EnumOrUnknown::new(
                PeggedReference::PEGGED_REFERENCE_UNSPECIFIED,
            );
            self.offset.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static PeggedOrder {
            static instance: PeggedOrder = PeggedOrder {
                reference: ::protobuf::EnumOrUnknown::from_i32(0),
                offset: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for PeggedOrder {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("PeggedOrder")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for PeggedOrder {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for PeggedOrder {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct Order {
        pub id: ::std::string::String,
        pub market_id: ::std::string::String,
        pub party_id: ::std::string::String,
        pub side: ::protobuf::EnumOrUnknown<Side>,
        pub price: ::std::string::String,
        pub size: u64,
        pub remaining: u64,
        pub time_in_force: ::protobuf::EnumOrUnknown<order::TimeInForce>,
        pub type_: ::protobuf::EnumOrUnknown<order::Type>,
        pub created_at: i64,
        pub status: ::protobuf::EnumOrUnknown<order::Status>,
        pub expires_at: i64,
        pub reference: ::std::string::String,
        pub reason: ::protobuf::EnumOrUnknown<OrderError>,
        pub updated_at: i64,
        pub version: u64,
        pub batch_id: u64,
        pub pegged_order: ::protobuf::MessageField<PeggedOrder>,
        pub liquidity_provision_id: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Order {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Order {
        #[inline]
        fn eq(&self, other: &Order) -> bool {
            self.id == other.id && self.market_id == other.market_id
                && self.party_id == other.party_id && self.side == other.side
                && self.price == other.price && self.size == other.size
                && self.remaining == other.remaining
                && self.time_in_force == other.time_in_force && self.type_ == other.type_
                && self.created_at == other.created_at && self.status == other.status
                && self.expires_at == other.expires_at
                && self.reference == other.reference && self.reason == other.reason
                && self.updated_at == other.updated_at && self.version == other.version
                && self.batch_id == other.batch_id
                && self.pegged_order == other.pegged_order
                && self.liquidity_provision_id == other.liquidity_provision_id
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Order {
        #[inline]
        fn clone(&self) -> Order {
            Order {
                id: ::core::clone::Clone::clone(&self.id),
                market_id: ::core::clone::Clone::clone(&self.market_id),
                party_id: ::core::clone::Clone::clone(&self.party_id),
                side: ::core::clone::Clone::clone(&self.side),
                price: ::core::clone::Clone::clone(&self.price),
                size: ::core::clone::Clone::clone(&self.size),
                remaining: ::core::clone::Clone::clone(&self.remaining),
                time_in_force: ::core::clone::Clone::clone(&self.time_in_force),
                type_: ::core::clone::Clone::clone(&self.type_),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                status: ::core::clone::Clone::clone(&self.status),
                expires_at: ::core::clone::Clone::clone(&self.expires_at),
                reference: ::core::clone::Clone::clone(&self.reference),
                reason: ::core::clone::Clone::clone(&self.reason),
                updated_at: ::core::clone::Clone::clone(&self.updated_at),
                version: ::core::clone::Clone::clone(&self.version),
                batch_id: ::core::clone::Clone::clone(&self.batch_id),
                pegged_order: ::core::clone::Clone::clone(&self.pegged_order),
                liquidity_provision_id: ::core::clone::Clone::clone(
                    &self.liquidity_provision_id,
                ),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Order {
        #[inline]
        fn default() -> Order {
            Order {
                id: ::core::default::Default::default(),
                market_id: ::core::default::Default::default(),
                party_id: ::core::default::Default::default(),
                side: ::core::default::Default::default(),
                price: ::core::default::Default::default(),
                size: ::core::default::Default::default(),
                remaining: ::core::default::Default::default(),
                time_in_force: ::core::default::Default::default(),
                type_: ::core::default::Default::default(),
                created_at: ::core::default::Default::default(),
                status: ::core::default::Default::default(),
                expires_at: ::core::default::Default::default(),
                reference: ::core::default::Default::default(),
                reason: ::core::default::Default::default(),
                updated_at: ::core::default::Default::default(),
                version: ::core::default::Default::default(),
                batch_id: ::core::default::Default::default(),
                pegged_order: ::core::default::Default::default(),
                liquidity_provision_id: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Order {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "market_id",
                "party_id",
                "side",
                "price",
                "size",
                "remaining",
                "time_in_force",
                "type_",
                "created_at",
                "status",
                "expires_at",
                "reference",
                "reason",
                "updated_at",
                "version",
                "batch_id",
                "pegged_order",
                "liquidity_provision_id",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.id,
                &&self.market_id,
                &&self.party_id,
                &&self.side,
                &&self.price,
                &&self.size,
                &&self.remaining,
                &&self.time_in_force,
                &&self.type_,
                &&self.created_at,
                &&self.status,
                &&self.expires_at,
                &&self.reference,
                &&self.reason,
                &&self.updated_at,
                &&self.version,
                &&self.batch_id,
                &&self.pegged_order,
                &&self.liquidity_provision_id,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Order", names, values)
        }
    }
    impl<'a> ::std::default::Default for &'a Order {
        fn default() -> &'a Order {
            <Order as ::protobuf::Message>::default_instance()
        }
    }
    impl Order {
        pub fn new() -> Order {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(19);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >("id", |m: &Order| { &m.id }, |m: &mut Order| { &mut m.id }),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "market_id",
                        |m: &Order| { &m.market_id },
                        |m: &mut Order| { &mut m.market_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "party_id",
                        |m: &Order| { &m.party_id },
                        |m: &mut Order| { &mut m.party_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >("side", |m: &Order| { &m.side }, |m: &mut Order| { &mut m.side }),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "price",
                        |m: &Order| { &m.price },
                        |m: &mut Order| { &mut m.price },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >("size", |m: &Order| { &m.size }, |m: &mut Order| { &mut m.size }),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "remaining",
                        |m: &Order| { &m.remaining },
                        |m: &mut Order| { &mut m.remaining },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "time_in_force",
                        |m: &Order| { &m.time_in_force },
                        |m: &mut Order| { &mut m.time_in_force },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >("type", |m: &Order| { &m.type_ }, |m: &mut Order| { &mut m.type_ }),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "created_at",
                        |m: &Order| { &m.created_at },
                        |m: &mut Order| { &mut m.created_at },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "status",
                        |m: &Order| { &m.status },
                        |m: &mut Order| { &mut m.status },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "expires_at",
                        |m: &Order| { &m.expires_at },
                        |m: &mut Order| { &mut m.expires_at },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "reference",
                        |m: &Order| { &m.reference },
                        |m: &mut Order| { &mut m.reference },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "reason",
                        |m: &Order| { &m.reason },
                        |m: &mut Order| { &mut m.reason },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "updated_at",
                        |m: &Order| { &m.updated_at },
                        |m: &mut Order| { &mut m.updated_at },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "version",
                        |m: &Order| { &m.version },
                        |m: &mut Order| { &mut m.version },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "batch_id",
                        |m: &Order| { &m.batch_id },
                        |m: &mut Order| { &mut m.batch_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        PeggedOrder,
                    >(
                        "pegged_order",
                        |m: &Order| { &m.pegged_order },
                        |m: &mut Order| { &mut m.pegged_order },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "liquidity_provision_id",
                        |m: &Order| { &m.liquidity_provision_id },
                        |m: &mut Order| { &mut m.liquidity_provision_id },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                Order,
            >("Order", fields, oneofs)
        }
    }
    impl ::protobuf::Message for Order {
        const NAME: &'static str = "Order";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.id = is.read_string()?;
                    }
                    18 => {
                        self.market_id = is.read_string()?;
                    }
                    26 => {
                        self.party_id = is.read_string()?;
                    }
                    32 => {
                        self.side = is.read_enum_or_unknown()?;
                    }
                    42 => {
                        self.price = is.read_string()?;
                    }
                    48 => {
                        self.size = is.read_uint64()?;
                    }
                    56 => {
                        self.remaining = is.read_uint64()?;
                    }
                    64 => {
                        self.time_in_force = is.read_enum_or_unknown()?;
                    }
                    72 => {
                        self.type_ = is.read_enum_or_unknown()?;
                    }
                    80 => {
                        self.created_at = is.read_int64()?;
                    }
                    88 => {
                        self.status = is.read_enum_or_unknown()?;
                    }
                    96 => {
                        self.expires_at = is.read_int64()?;
                    }
                    106 => {
                        self.reference = is.read_string()?;
                    }
                    112 => {
                        self.reason = is.read_enum_or_unknown()?;
                    }
                    120 => {
                        self.updated_at = is.read_int64()?;
                    }
                    128 => {
                        self.version = is.read_uint64()?;
                    }
                    136 => {
                        self.batch_id = is.read_uint64()?;
                    }
                    146 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.pegged_order,
                        )?;
                    }
                    154 => {
                        self.liquidity_provision_id = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.id);
            }
            if !self.market_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.market_id);
            }
            if !self.party_id.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.party_id);
            }
            if self.side != ::protobuf::EnumOrUnknown::new(Side::SIDE_UNSPECIFIED) {
                my_size += ::protobuf::rt::int32_size(4, self.side.value());
            }
            if !self.price.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.price);
            }
            if self.size != 0 {
                my_size += ::protobuf::rt::uint64_size(6, self.size);
            }
            if self.remaining != 0 {
                my_size += ::protobuf::rt::uint64_size(7, self.remaining);
            }
            if self.time_in_force
                != ::protobuf::EnumOrUnknown::new(
                    order::TimeInForce::TIME_IN_FORCE_UNSPECIFIED,
                )
            {
                my_size += ::protobuf::rt::int32_size(8, self.time_in_force.value());
            }
            if self.type_
                != ::protobuf::EnumOrUnknown::new(order::Type::TYPE_UNSPECIFIED)
            {
                my_size += ::protobuf::rt::int32_size(9, self.type_.value());
            }
            if self.created_at != 0 {
                my_size += ::protobuf::rt::int64_size(10, self.created_at);
            }
            if self.status
                != ::protobuf::EnumOrUnknown::new(order::Status::STATUS_UNSPECIFIED)
            {
                my_size += ::protobuf::rt::int32_size(11, self.status.value());
            }
            if self.expires_at != 0 {
                my_size += ::protobuf::rt::int64_size(12, self.expires_at);
            }
            if !self.reference.is_empty() {
                my_size += ::protobuf::rt::string_size(13, &self.reference);
            }
            if self.reason
                != ::protobuf::EnumOrUnknown::new(OrderError::ORDER_ERROR_UNSPECIFIED)
            {
                my_size += ::protobuf::rt::int32_size(14, self.reason.value());
            }
            if self.updated_at != 0 {
                my_size += ::protobuf::rt::int64_size(15, self.updated_at);
            }
            if self.version != 0 {
                my_size += ::protobuf::rt::uint64_size(16, self.version);
            }
            if self.batch_id != 0 {
                my_size += ::protobuf::rt::uint64_size(17, self.batch_id);
            }
            if let Some(v) = self.pegged_order.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.liquidity_provision_id.is_empty() {
                my_size += ::protobuf::rt::string_size(19, &self.liquidity_provision_id);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.id.is_empty() {
                os.write_string(1, &self.id)?;
            }
            if !self.market_id.is_empty() {
                os.write_string(2, &self.market_id)?;
            }
            if !self.party_id.is_empty() {
                os.write_string(3, &self.party_id)?;
            }
            if self.side != ::protobuf::EnumOrUnknown::new(Side::SIDE_UNSPECIFIED) {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.side))?;
            }
            if !self.price.is_empty() {
                os.write_string(5, &self.price)?;
            }
            if self.size != 0 {
                os.write_uint64(6, self.size)?;
            }
            if self.remaining != 0 {
                os.write_uint64(7, self.remaining)?;
            }
            if self.time_in_force
                != ::protobuf::EnumOrUnknown::new(
                    order::TimeInForce::TIME_IN_FORCE_UNSPECIFIED,
                )
            {
                os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.time_in_force))?;
            }
            if self.type_
                != ::protobuf::EnumOrUnknown::new(order::Type::TYPE_UNSPECIFIED)
            {
                os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.type_))?;
            }
            if self.created_at != 0 {
                os.write_int64(10, self.created_at)?;
            }
            if self.status
                != ::protobuf::EnumOrUnknown::new(order::Status::STATUS_UNSPECIFIED)
            {
                os.write_enum(11, ::protobuf::EnumOrUnknown::value(&self.status))?;
            }
            if self.expires_at != 0 {
                os.write_int64(12, self.expires_at)?;
            }
            if !self.reference.is_empty() {
                os.write_string(13, &self.reference)?;
            }
            if self.reason
                != ::protobuf::EnumOrUnknown::new(OrderError::ORDER_ERROR_UNSPECIFIED)
            {
                os.write_enum(14, ::protobuf::EnumOrUnknown::value(&self.reason))?;
            }
            if self.updated_at != 0 {
                os.write_int64(15, self.updated_at)?;
            }
            if self.version != 0 {
                os.write_uint64(16, self.version)?;
            }
            if self.batch_id != 0 {
                os.write_uint64(17, self.batch_id)?;
            }
            if let Some(v) = self.pegged_order.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
            }
            if !self.liquidity_provision_id.is_empty() {
                os.write_string(19, &self.liquidity_provision_id)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> Order {
            Order::new()
        }
        fn clear(&mut self) {
            self.id.clear();
            self.market_id.clear();
            self.party_id.clear();
            self.side = ::protobuf::EnumOrUnknown::new(Side::SIDE_UNSPECIFIED);
            self.price.clear();
            self.size = 0;
            self.remaining = 0;
            self
                .time_in_force = ::protobuf::EnumOrUnknown::new(
                order::TimeInForce::TIME_IN_FORCE_UNSPECIFIED,
            );
            self.type_ = ::protobuf::EnumOrUnknown::new(order::Type::TYPE_UNSPECIFIED);
            self.created_at = 0;
            self
                .status = ::protobuf::EnumOrUnknown::new(
                order::Status::STATUS_UNSPECIFIED,
            );
            self.expires_at = 0;
            self.reference.clear();
            self
                .reason = ::protobuf::EnumOrUnknown::new(
                OrderError::ORDER_ERROR_UNSPECIFIED,
            );
            self.updated_at = 0;
            self.version = 0;
            self.batch_id = 0;
            self.pegged_order.clear();
            self.liquidity_provision_id.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static Order {
            static instance: Order = Order {
                id: ::std::string::String::new(),
                market_id: ::std::string::String::new(),
                party_id: ::std::string::String::new(),
                side: ::protobuf::EnumOrUnknown::from_i32(0),
                price: ::std::string::String::new(),
                size: 0,
                remaining: 0,
                time_in_force: ::protobuf::EnumOrUnknown::from_i32(0),
                type_: ::protobuf::EnumOrUnknown::from_i32(0),
                created_at: 0,
                status: ::protobuf::EnumOrUnknown::from_i32(0),
                expires_at: 0,
                reference: ::std::string::String::new(),
                reason: ::protobuf::EnumOrUnknown::from_i32(0),
                updated_at: 0,
                version: 0,
                batch_id: 0,
                pegged_order: ::protobuf::MessageField::none(),
                liquidity_provision_id: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for Order {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor().message_by_package_relative_name("Order").unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for Order {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for Order {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    /// Nested message and enums of message `Order`
    pub mod order {
        #[postgres(name = "transfer_type")]
        pub enum TimeInForce {
            TIME_IN_FORCE_UNSPECIFIED = 0,
            TIME_IN_FORCE_GTC = 1,
            TIME_IN_FORCE_GTT = 2,
            TIME_IN_FORCE_IOC = 3,
            TIME_IN_FORCE_FOK = 4,
            TIME_IN_FORCE_GFA = 5,
            TIME_IN_FORCE_GFN = 6,
        }
        impl<'a> postgres_types::FromSql<'a> for TimeInForce {
            fn from_sql(
                _type: &postgres_types::Type,
                buf: &'a [u8],
            ) -> std::result::Result<
                TimeInForce,
                std::boxed::Box<
                    dyn std::error::Error + std::marker::Sync + std::marker::Send,
                >,
            > {
                match std::str::from_utf8(buf)? {
                    "TIME_IN_FORCE_UNSPECIFIED" => {
                        std::result::Result::Ok(TimeInForce::TIME_IN_FORCE_UNSPECIFIED)
                    }
                    "TIME_IN_FORCE_GTC" => {
                        std::result::Result::Ok(TimeInForce::TIME_IN_FORCE_GTC)
                    }
                    "TIME_IN_FORCE_GTT" => {
                        std::result::Result::Ok(TimeInForce::TIME_IN_FORCE_GTT)
                    }
                    "TIME_IN_FORCE_IOC" => {
                        std::result::Result::Ok(TimeInForce::TIME_IN_FORCE_IOC)
                    }
                    "TIME_IN_FORCE_FOK" => {
                        std::result::Result::Ok(TimeInForce::TIME_IN_FORCE_FOK)
                    }
                    "TIME_IN_FORCE_GFA" => {
                        std::result::Result::Ok(TimeInForce::TIME_IN_FORCE_GFA)
                    }
                    "TIME_IN_FORCE_GFN" => {
                        std::result::Result::Ok(TimeInForce::TIME_IN_FORCE_GFN)
                    }
                    s => {
                        std::result::Result::Err(
                            std::convert::Into::into({
                                let res = ::alloc::fmt::format(
                                    ::core::fmt::Arguments::new_v1(
                                        &["invalid variant `", "`"],
                                        &[::core::fmt::ArgumentV1::new_display(&s)],
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn accepts(type_: &postgres_types::Type) -> bool {
                if type_.name() != "transfer_type" {
                    return false;
                }
                match *type_.kind() {
                    ::postgres_types::Kind::Enum(ref variants) => {
                        if variants.len() != 7usize {
                            return false;
                        }
                        variants
                            .iter()
                            .all(|v| {
                                match &**v {
                                    "TIME_IN_FORCE_UNSPECIFIED" => true,
                                    "TIME_IN_FORCE_GTC" => true,
                                    "TIME_IN_FORCE_GTT" => true,
                                    "TIME_IN_FORCE_IOC" => true,
                                    "TIME_IN_FORCE_FOK" => true,
                                    "TIME_IN_FORCE_GFA" => true,
                                    "TIME_IN_FORCE_GFN" => true,
                                    _ => false,
                                }
                            })
                    }
                    _ => false,
                }
            }
        }
        impl postgres_types::ToSql for TimeInForce {
            fn to_sql(
                &self,
                _type: &postgres_types::Type,
                buf: &mut postgres_types::private::BytesMut,
            ) -> std::result::Result<
                postgres_types::IsNull,
                std::boxed::Box<
                    dyn std::error::Error + std::marker::Sync + std::marker::Send,
                >,
            > {
                let s = match *self {
                    TimeInForce::TIME_IN_FORCE_UNSPECIFIED => "TIME_IN_FORCE_UNSPECIFIED",
                    TimeInForce::TIME_IN_FORCE_GTC => "TIME_IN_FORCE_GTC",
                    TimeInForce::TIME_IN_FORCE_GTT => "TIME_IN_FORCE_GTT",
                    TimeInForce::TIME_IN_FORCE_IOC => "TIME_IN_FORCE_IOC",
                    TimeInForce::TIME_IN_FORCE_FOK => "TIME_IN_FORCE_FOK",
                    TimeInForce::TIME_IN_FORCE_GFA => "TIME_IN_FORCE_GFA",
                    TimeInForce::TIME_IN_FORCE_GFN => "TIME_IN_FORCE_GFN",
                };
                buf.extend_from_slice(s.as_bytes());
                std::result::Result::Ok(postgres_types::IsNull::No)
            }
            fn accepts(type_: &postgres_types::Type) -> bool {
                if type_.name() != "transfer_type" {
                    return false;
                }
                match *type_.kind() {
                    ::postgres_types::Kind::Enum(ref variants) => {
                        if variants.len() != 7usize {
                            return false;
                        }
                        variants
                            .iter()
                            .all(|v| {
                                match &**v {
                                    "TIME_IN_FORCE_UNSPECIFIED" => true,
                                    "TIME_IN_FORCE_GTC" => true,
                                    "TIME_IN_FORCE_GTT" => true,
                                    "TIME_IN_FORCE_IOC" => true,
                                    "TIME_IN_FORCE_FOK" => true,
                                    "TIME_IN_FORCE_GFA" => true,
                                    "TIME_IN_FORCE_GFN" => true,
                                    _ => false,
                                }
                            })
                    }
                    _ => false,
                }
            }
            fn to_sql_checked(
                &self,
                ty: &::postgres_types::Type,
                out: &mut ::postgres_types::private::BytesMut,
            ) -> ::std::result::Result<
                ::postgres_types::IsNull,
                Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
            > {
                ::postgres_types::__to_sql_checked(self, ty, out)
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TimeInForce {
            #[inline]
            fn clone(&self) -> TimeInForce {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for TimeInForce {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TimeInForce {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TimeInForce {
            #[inline]
            fn eq(&self, other: &TimeInForce) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for TimeInForce {}
        #[automatically_derived]
        impl ::core::cmp::Eq for TimeInForce {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TimeInForce {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    TimeInForce::TIME_IN_FORCE_UNSPECIFIED => {
                        ::core::fmt::Formatter::write_str(f, "TIME_IN_FORCE_UNSPECIFIED")
                    }
                    TimeInForce::TIME_IN_FORCE_GTC => {
                        ::core::fmt::Formatter::write_str(f, "TIME_IN_FORCE_GTC")
                    }
                    TimeInForce::TIME_IN_FORCE_GTT => {
                        ::core::fmt::Formatter::write_str(f, "TIME_IN_FORCE_GTT")
                    }
                    TimeInForce::TIME_IN_FORCE_IOC => {
                        ::core::fmt::Formatter::write_str(f, "TIME_IN_FORCE_IOC")
                    }
                    TimeInForce::TIME_IN_FORCE_FOK => {
                        ::core::fmt::Formatter::write_str(f, "TIME_IN_FORCE_FOK")
                    }
                    TimeInForce::TIME_IN_FORCE_GFA => {
                        ::core::fmt::Formatter::write_str(f, "TIME_IN_FORCE_GFA")
                    }
                    TimeInForce::TIME_IN_FORCE_GFN => {
                        ::core::fmt::Formatter::write_str(f, "TIME_IN_FORCE_GFN")
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for TimeInForce {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state)
            }
        }
        impl ::protobuf::Enum for TimeInForce {
            const NAME: &'static str = "TimeInForce";
            fn value(&self) -> i32 {
                *self as i32
            }
            fn from_i32(value: i32) -> ::std::option::Option<TimeInForce> {
                match value {
                    0 => {
                        ::std::option::Option::Some(
                            TimeInForce::TIME_IN_FORCE_UNSPECIFIED,
                        )
                    }
                    1 => ::std::option::Option::Some(TimeInForce::TIME_IN_FORCE_GTC),
                    2 => ::std::option::Option::Some(TimeInForce::TIME_IN_FORCE_GTT),
                    3 => ::std::option::Option::Some(TimeInForce::TIME_IN_FORCE_IOC),
                    4 => ::std::option::Option::Some(TimeInForce::TIME_IN_FORCE_FOK),
                    5 => ::std::option::Option::Some(TimeInForce::TIME_IN_FORCE_GFA),
                    6 => ::std::option::Option::Some(TimeInForce::TIME_IN_FORCE_GFN),
                    _ => ::std::option::Option::None,
                }
            }
            const VALUES: &'static [TimeInForce] = &[
                TimeInForce::TIME_IN_FORCE_UNSPECIFIED,
                TimeInForce::TIME_IN_FORCE_GTC,
                TimeInForce::TIME_IN_FORCE_GTT,
                TimeInForce::TIME_IN_FORCE_IOC,
                TimeInForce::TIME_IN_FORCE_FOK,
                TimeInForce::TIME_IN_FORCE_GFA,
                TimeInForce::TIME_IN_FORCE_GFN,
            ];
        }
        impl ::protobuf::EnumFull for TimeInForce {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<
                    ::protobuf::reflect::EnumDescriptor,
                > = ::protobuf::rt::Lazy::new();
                descriptor
                    .get(|| {
                        super::file_descriptor()
                            .enum_by_package_relative_name("Order.TimeInForce")
                            .unwrap()
                    })
                    .clone()
            }
            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }
        impl ::std::default::Default for TimeInForce {
            fn default() -> Self {
                TimeInForce::TIME_IN_FORCE_UNSPECIFIED
            }
        }
        impl TimeInForce {
            pub(super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<
                    TimeInForce,
                >("Order.TimeInForce")
            }
        }
        #[postgres(name = "transfer_type")]
        pub enum Type {
            TYPE_UNSPECIFIED = 0,
            TYPE_LIMIT = 1,
            TYPE_MARKET = 2,
            TYPE_NETWORK = 3,
        }
        impl<'a> postgres_types::FromSql<'a> for Type {
            fn from_sql(
                _type: &postgres_types::Type,
                buf: &'a [u8],
            ) -> std::result::Result<
                Type,
                std::boxed::Box<
                    dyn std::error::Error + std::marker::Sync + std::marker::Send,
                >,
            > {
                match std::str::from_utf8(buf)? {
                    "TYPE_UNSPECIFIED" => std::result::Result::Ok(Type::TYPE_UNSPECIFIED),
                    "TYPE_LIMIT" => std::result::Result::Ok(Type::TYPE_LIMIT),
                    "TYPE_MARKET" => std::result::Result::Ok(Type::TYPE_MARKET),
                    "TYPE_NETWORK" => std::result::Result::Ok(Type::TYPE_NETWORK),
                    s => {
                        std::result::Result::Err(
                            std::convert::Into::into({
                                let res = ::alloc::fmt::format(
                                    ::core::fmt::Arguments::new_v1(
                                        &["invalid variant `", "`"],
                                        &[::core::fmt::ArgumentV1::new_display(&s)],
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn accepts(type_: &postgres_types::Type) -> bool {
                if type_.name() != "transfer_type" {
                    return false;
                }
                match *type_.kind() {
                    ::postgres_types::Kind::Enum(ref variants) => {
                        if variants.len() != 4usize {
                            return false;
                        }
                        variants
                            .iter()
                            .all(|v| {
                                match &**v {
                                    "TYPE_UNSPECIFIED" => true,
                                    "TYPE_LIMIT" => true,
                                    "TYPE_MARKET" => true,
                                    "TYPE_NETWORK" => true,
                                    _ => false,
                                }
                            })
                    }
                    _ => false,
                }
            }
        }
        impl postgres_types::ToSql for Type {
            fn to_sql(
                &self,
                _type: &postgres_types::Type,
                buf: &mut postgres_types::private::BytesMut,
            ) -> std::result::Result<
                postgres_types::IsNull,
                std::boxed::Box<
                    dyn std::error::Error + std::marker::Sync + std::marker::Send,
                >,
            > {
                let s = match *self {
                    Type::TYPE_UNSPECIFIED => "TYPE_UNSPECIFIED",
                    Type::TYPE_LIMIT => "TYPE_LIMIT",
                    Type::TYPE_MARKET => "TYPE_MARKET",
                    Type::TYPE_NETWORK => "TYPE_NETWORK",
                };
                buf.extend_from_slice(s.as_bytes());
                std::result::Result::Ok(postgres_types::IsNull::No)
            }
            fn accepts(type_: &postgres_types::Type) -> bool {
                if type_.name() != "transfer_type" {
                    return false;
                }
                match *type_.kind() {
                    ::postgres_types::Kind::Enum(ref variants) => {
                        if variants.len() != 4usize {
                            return false;
                        }
                        variants
                            .iter()
                            .all(|v| {
                                match &**v {
                                    "TYPE_UNSPECIFIED" => true,
                                    "TYPE_LIMIT" => true,
                                    "TYPE_MARKET" => true,
                                    "TYPE_NETWORK" => true,
                                    _ => false,
                                }
                            })
                    }
                    _ => false,
                }
            }
            fn to_sql_checked(
                &self,
                ty: &::postgres_types::Type,
                out: &mut ::postgres_types::private::BytesMut,
            ) -> ::std::result::Result<
                ::postgres_types::IsNull,
                Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
            > {
                ::postgres_types::__to_sql_checked(self, ty, out)
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Type {
            #[inline]
            fn clone(&self) -> Type {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Type {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Type {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Type {
            #[inline]
            fn eq(&self, other: &Type) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Type {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Type {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Type {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Type::TYPE_UNSPECIFIED => {
                        ::core::fmt::Formatter::write_str(f, "TYPE_UNSPECIFIED")
                    }
                    Type::TYPE_LIMIT => {
                        ::core::fmt::Formatter::write_str(f, "TYPE_LIMIT")
                    }
                    Type::TYPE_MARKET => {
                        ::core::fmt::Formatter::write_str(f, "TYPE_MARKET")
                    }
                    Type::TYPE_NETWORK => {
                        ::core::fmt::Formatter::write_str(f, "TYPE_NETWORK")
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Type {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state)
            }
        }
        impl ::protobuf::Enum for Type {
            const NAME: &'static str = "Type";
            fn value(&self) -> i32 {
                *self as i32
            }
            fn from_i32(value: i32) -> ::std::option::Option<Type> {
                match value {
                    0 => ::std::option::Option::Some(Type::TYPE_UNSPECIFIED),
                    1 => ::std::option::Option::Some(Type::TYPE_LIMIT),
                    2 => ::std::option::Option::Some(Type::TYPE_MARKET),
                    3 => ::std::option::Option::Some(Type::TYPE_NETWORK),
                    _ => ::std::option::Option::None,
                }
            }
            const VALUES: &'static [Type] = &[
                Type::TYPE_UNSPECIFIED,
                Type::TYPE_LIMIT,
                Type::TYPE_MARKET,
                Type::TYPE_NETWORK,
            ];
        }
        impl ::protobuf::EnumFull for Type {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<
                    ::protobuf::reflect::EnumDescriptor,
                > = ::protobuf::rt::Lazy::new();
                descriptor
                    .get(|| {
                        super::file_descriptor()
                            .enum_by_package_relative_name("Order.Type")
                            .unwrap()
                    })
                    .clone()
            }
            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }
        impl ::std::default::Default for Type {
            fn default() -> Self {
                Type::TYPE_UNSPECIFIED
            }
        }
        impl Type {
            pub(super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<
                    Type,
                >("Order.Type")
            }
        }
        #[postgres(name = "transfer_type")]
        pub enum Status {
            STATUS_UNSPECIFIED = 0,
            STATUS_ACTIVE = 1,
            STATUS_EXPIRED = 2,
            STATUS_CANCELLED = 3,
            STATUS_STOPPED = 4,
            STATUS_FILLED = 5,
            STATUS_REJECTED = 6,
            STATUS_PARTIALLY_FILLED = 7,
            STATUS_PARKED = 8,
        }
        impl<'a> postgres_types::FromSql<'a> for Status {
            fn from_sql(
                _type: &postgres_types::Type,
                buf: &'a [u8],
            ) -> std::result::Result<
                Status,
                std::boxed::Box<
                    dyn std::error::Error + std::marker::Sync + std::marker::Send,
                >,
            > {
                match std::str::from_utf8(buf)? {
                    "STATUS_UNSPECIFIED" => {
                        std::result::Result::Ok(Status::STATUS_UNSPECIFIED)
                    }
                    "STATUS_ACTIVE" => std::result::Result::Ok(Status::STATUS_ACTIVE),
                    "STATUS_EXPIRED" => std::result::Result::Ok(Status::STATUS_EXPIRED),
                    "STATUS_CANCELLED" => {
                        std::result::Result::Ok(Status::STATUS_CANCELLED)
                    }
                    "STATUS_STOPPED" => std::result::Result::Ok(Status::STATUS_STOPPED),
                    "STATUS_FILLED" => std::result::Result::Ok(Status::STATUS_FILLED),
                    "STATUS_REJECTED" => std::result::Result::Ok(Status::STATUS_REJECTED),
                    "STATUS_PARTIALLY_FILLED" => {
                        std::result::Result::Ok(Status::STATUS_PARTIALLY_FILLED)
                    }
                    "STATUS_PARKED" => std::result::Result::Ok(Status::STATUS_PARKED),
                    s => {
                        std::result::Result::Err(
                            std::convert::Into::into({
                                let res = ::alloc::fmt::format(
                                    ::core::fmt::Arguments::new_v1(
                                        &["invalid variant `", "`"],
                                        &[::core::fmt::ArgumentV1::new_display(&s)],
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn accepts(type_: &postgres_types::Type) -> bool {
                if type_.name() != "transfer_type" {
                    return false;
                }
                match *type_.kind() {
                    ::postgres_types::Kind::Enum(ref variants) => {
                        if variants.len() != 9usize {
                            return false;
                        }
                        variants
                            .iter()
                            .all(|v| {
                                match &**v {
                                    "STATUS_UNSPECIFIED" => true,
                                    "STATUS_ACTIVE" => true,
                                    "STATUS_EXPIRED" => true,
                                    "STATUS_CANCELLED" => true,
                                    "STATUS_STOPPED" => true,
                                    "STATUS_FILLED" => true,
                                    "STATUS_REJECTED" => true,
                                    "STATUS_PARTIALLY_FILLED" => true,
                                    "STATUS_PARKED" => true,
                                    _ => false,
                                }
                            })
                    }
                    _ => false,
                }
            }
        }
        impl postgres_types::ToSql for Status {
            fn to_sql(
                &self,
                _type: &postgres_types::Type,
                buf: &mut postgres_types::private::BytesMut,
            ) -> std::result::Result<
                postgres_types::IsNull,
                std::boxed::Box<
                    dyn std::error::Error + std::marker::Sync + std::marker::Send,
                >,
            > {
                let s = match *self {
                    Status::STATUS_UNSPECIFIED => "STATUS_UNSPECIFIED",
                    Status::STATUS_ACTIVE => "STATUS_ACTIVE",
                    Status::STATUS_EXPIRED => "STATUS_EXPIRED",
                    Status::STATUS_CANCELLED => "STATUS_CANCELLED",
                    Status::STATUS_STOPPED => "STATUS_STOPPED",
                    Status::STATUS_FILLED => "STATUS_FILLED",
                    Status::STATUS_REJECTED => "STATUS_REJECTED",
                    Status::STATUS_PARTIALLY_FILLED => "STATUS_PARTIALLY_FILLED",
                    Status::STATUS_PARKED => "STATUS_PARKED",
                };
                buf.extend_from_slice(s.as_bytes());
                std::result::Result::Ok(postgres_types::IsNull::No)
            }
            fn accepts(type_: &postgres_types::Type) -> bool {
                if type_.name() != "transfer_type" {
                    return false;
                }
                match *type_.kind() {
                    ::postgres_types::Kind::Enum(ref variants) => {
                        if variants.len() != 9usize {
                            return false;
                        }
                        variants
                            .iter()
                            .all(|v| {
                                match &**v {
                                    "STATUS_UNSPECIFIED" => true,
                                    "STATUS_ACTIVE" => true,
                                    "STATUS_EXPIRED" => true,
                                    "STATUS_CANCELLED" => true,
                                    "STATUS_STOPPED" => true,
                                    "STATUS_FILLED" => true,
                                    "STATUS_REJECTED" => true,
                                    "STATUS_PARTIALLY_FILLED" => true,
                                    "STATUS_PARKED" => true,
                                    _ => false,
                                }
                            })
                    }
                    _ => false,
                }
            }
            fn to_sql_checked(
                &self,
                ty: &::postgres_types::Type,
                out: &mut ::postgres_types::private::BytesMut,
            ) -> ::std::result::Result<
                ::postgres_types::IsNull,
                Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
            > {
                ::postgres_types::__to_sql_checked(self, ty, out)
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Status {
            #[inline]
            fn clone(&self) -> Status {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Status {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Status {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Status {
            #[inline]
            fn eq(&self, other: &Status) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Status {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Status {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Status {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Status::STATUS_UNSPECIFIED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_UNSPECIFIED")
                    }
                    Status::STATUS_ACTIVE => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_ACTIVE")
                    }
                    Status::STATUS_EXPIRED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_EXPIRED")
                    }
                    Status::STATUS_CANCELLED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_CANCELLED")
                    }
                    Status::STATUS_STOPPED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_STOPPED")
                    }
                    Status::STATUS_FILLED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_FILLED")
                    }
                    Status::STATUS_REJECTED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_REJECTED")
                    }
                    Status::STATUS_PARTIALLY_FILLED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_PARTIALLY_FILLED")
                    }
                    Status::STATUS_PARKED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_PARKED")
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Status {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state)
            }
        }
        impl ::protobuf::Enum for Status {
            const NAME: &'static str = "Status";
            fn value(&self) -> i32 {
                *self as i32
            }
            fn from_i32(value: i32) -> ::std::option::Option<Status> {
                match value {
                    0 => ::std::option::Option::Some(Status::STATUS_UNSPECIFIED),
                    1 => ::std::option::Option::Some(Status::STATUS_ACTIVE),
                    2 => ::std::option::Option::Some(Status::STATUS_EXPIRED),
                    3 => ::std::option::Option::Some(Status::STATUS_CANCELLED),
                    4 => ::std::option::Option::Some(Status::STATUS_STOPPED),
                    5 => ::std::option::Option::Some(Status::STATUS_FILLED),
                    6 => ::std::option::Option::Some(Status::STATUS_REJECTED),
                    7 => ::std::option::Option::Some(Status::STATUS_PARTIALLY_FILLED),
                    8 => ::std::option::Option::Some(Status::STATUS_PARKED),
                    _ => ::std::option::Option::None,
                }
            }
            const VALUES: &'static [Status] = &[
                Status::STATUS_UNSPECIFIED,
                Status::STATUS_ACTIVE,
                Status::STATUS_EXPIRED,
                Status::STATUS_CANCELLED,
                Status::STATUS_STOPPED,
                Status::STATUS_FILLED,
                Status::STATUS_REJECTED,
                Status::STATUS_PARTIALLY_FILLED,
                Status::STATUS_PARKED,
            ];
        }
        impl ::protobuf::EnumFull for Status {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<
                    ::protobuf::reflect::EnumDescriptor,
                > = ::protobuf::rt::Lazy::new();
                descriptor
                    .get(|| {
                        super::file_descriptor()
                            .enum_by_package_relative_name("Order.Status")
                            .unwrap()
                    })
                    .clone()
            }
            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }
        impl ::std::default::Default for Status {
            fn default() -> Self {
                Status::STATUS_UNSPECIFIED
            }
        }
        impl Status {
            pub(super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<
                    Status,
                >("Order.Status")
            }
        }
    }
    pub struct OrderCancellationConfirmation {
        pub order: ::protobuf::MessageField<Order>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OrderCancellationConfirmation {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OrderCancellationConfirmation {
        #[inline]
        fn eq(&self, other: &OrderCancellationConfirmation) -> bool {
            self.order == other.order && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for OrderCancellationConfirmation {
        #[inline]
        fn clone(&self) -> OrderCancellationConfirmation {
            OrderCancellationConfirmation {
                order: ::core::clone::Clone::clone(&self.order),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for OrderCancellationConfirmation {
        #[inline]
        fn default() -> OrderCancellationConfirmation {
            OrderCancellationConfirmation {
                order: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for OrderCancellationConfirmation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "OrderCancellationConfirmation",
                "order",
                &&self.order,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a OrderCancellationConfirmation {
        fn default() -> &'a OrderCancellationConfirmation {
            <OrderCancellationConfirmation as ::protobuf::Message>::default_instance()
        }
    }
    impl OrderCancellationConfirmation {
        pub fn new() -> OrderCancellationConfirmation {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        Order,
                    >(
                        "order",
                        |m: &OrderCancellationConfirmation| { &m.order },
                        |m: &mut OrderCancellationConfirmation| { &mut m.order },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                OrderCancellationConfirmation,
            >("OrderCancellationConfirmation", fields, oneofs)
        }
    }
    impl ::protobuf::Message for OrderCancellationConfirmation {
        const NAME: &'static str = "OrderCancellationConfirmation";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.order,
                        )?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.order.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if let Some(v) = self.order.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> OrderCancellationConfirmation {
            OrderCancellationConfirmation::new()
        }
        fn clear(&mut self) {
            self.order.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static OrderCancellationConfirmation {
            static instance: OrderCancellationConfirmation = OrderCancellationConfirmation {
                order: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for OrderCancellationConfirmation {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name(
                            "OrderCancellationConfirmation",
                        )
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for OrderCancellationConfirmation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for OrderCancellationConfirmation {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct OrderConfirmation {
        pub order: ::protobuf::MessageField<Order>,
        pub trades: ::std::vec::Vec<Trade>,
        pub passive_orders_affected: ::std::vec::Vec<Order>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OrderConfirmation {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OrderConfirmation {
        #[inline]
        fn eq(&self, other: &OrderConfirmation) -> bool {
            self.order == other.order && self.trades == other.trades
                && self.passive_orders_affected == other.passive_orders_affected
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for OrderConfirmation {
        #[inline]
        fn clone(&self) -> OrderConfirmation {
            OrderConfirmation {
                order: ::core::clone::Clone::clone(&self.order),
                trades: ::core::clone::Clone::clone(&self.trades),
                passive_orders_affected: ::core::clone::Clone::clone(
                    &self.passive_orders_affected,
                ),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for OrderConfirmation {
        #[inline]
        fn default() -> OrderConfirmation {
            OrderConfirmation {
                order: ::core::default::Default::default(),
                trades: ::core::default::Default::default(),
                passive_orders_affected: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for OrderConfirmation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "OrderConfirmation",
                "order",
                &&self.order,
                "trades",
                &&self.trades,
                "passive_orders_affected",
                &&self.passive_orders_affected,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a OrderConfirmation {
        fn default() -> &'a OrderConfirmation {
            <OrderConfirmation as ::protobuf::Message>::default_instance()
        }
    }
    impl OrderConfirmation {
        pub fn new() -> OrderConfirmation {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        Order,
                    >(
                        "order",
                        |m: &OrderConfirmation| { &m.order },
                        |m: &mut OrderConfirmation| { &mut m.order },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "trades",
                        |m: &OrderConfirmation| { &m.trades },
                        |m: &mut OrderConfirmation| { &mut m.trades },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "passive_orders_affected",
                        |m: &OrderConfirmation| { &m.passive_orders_affected },
                        |m: &mut OrderConfirmation| { &mut m.passive_orders_affected },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                OrderConfirmation,
            >("OrderConfirmation", fields, oneofs)
        }
    }
    impl ::protobuf::Message for OrderConfirmation {
        const NAME: &'static str = "OrderConfirmation";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.order,
                        )?;
                    }
                    18 => {
                        self.trades.push(is.read_message()?);
                    }
                    26 => {
                        self.passive_orders_affected.push(is.read_message()?);
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.order.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.trades {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.passive_orders_affected {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if let Some(v) = self.order.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            for v in &self.trades {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            for v in &self.passive_orders_affected {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> OrderConfirmation {
            OrderConfirmation::new()
        }
        fn clear(&mut self) {
            self.order.clear();
            self.trades.clear();
            self.passive_orders_affected.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static OrderConfirmation {
            static instance: OrderConfirmation = OrderConfirmation {
                order: ::protobuf::MessageField::none(),
                trades: ::std::vec::Vec::new(),
                passive_orders_affected: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for OrderConfirmation {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("OrderConfirmation")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for OrderConfirmation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for OrderConfirmation {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct AuctionIndicativeState {
        pub market_id: ::std::string::String,
        pub indicative_price: ::std::string::String,
        pub indicative_volume: u64,
        pub auction_start: i64,
        pub auction_end: i64,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AuctionIndicativeState {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AuctionIndicativeState {
        #[inline]
        fn eq(&self, other: &AuctionIndicativeState) -> bool {
            self.market_id == other.market_id
                && self.indicative_price == other.indicative_price
                && self.indicative_volume == other.indicative_volume
                && self.auction_start == other.auction_start
                && self.auction_end == other.auction_end
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AuctionIndicativeState {
        #[inline]
        fn clone(&self) -> AuctionIndicativeState {
            AuctionIndicativeState {
                market_id: ::core::clone::Clone::clone(&self.market_id),
                indicative_price: ::core::clone::Clone::clone(&self.indicative_price),
                indicative_volume: ::core::clone::Clone::clone(&self.indicative_volume),
                auction_start: ::core::clone::Clone::clone(&self.auction_start),
                auction_end: ::core::clone::Clone::clone(&self.auction_end),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for AuctionIndicativeState {
        #[inline]
        fn default() -> AuctionIndicativeState {
            AuctionIndicativeState {
                market_id: ::core::default::Default::default(),
                indicative_price: ::core::default::Default::default(),
                indicative_volume: ::core::default::Default::default(),
                auction_start: ::core::default::Default::default(),
                auction_end: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AuctionIndicativeState {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "market_id",
                "indicative_price",
                "indicative_volume",
                "auction_start",
                "auction_end",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.market_id,
                &&self.indicative_price,
                &&self.indicative_volume,
                &&self.auction_start,
                &&self.auction_end,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "AuctionIndicativeState",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a AuctionIndicativeState {
        fn default() -> &'a AuctionIndicativeState {
            <AuctionIndicativeState as ::protobuf::Message>::default_instance()
        }
    }
    impl AuctionIndicativeState {
        pub fn new() -> AuctionIndicativeState {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "market_id",
                        |m: &AuctionIndicativeState| { &m.market_id },
                        |m: &mut AuctionIndicativeState| { &mut m.market_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "indicative_price",
                        |m: &AuctionIndicativeState| { &m.indicative_price },
                        |m: &mut AuctionIndicativeState| { &mut m.indicative_price },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "indicative_volume",
                        |m: &AuctionIndicativeState| { &m.indicative_volume },
                        |m: &mut AuctionIndicativeState| { &mut m.indicative_volume },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "auction_start",
                        |m: &AuctionIndicativeState| { &m.auction_start },
                        |m: &mut AuctionIndicativeState| { &mut m.auction_start },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "auction_end",
                        |m: &AuctionIndicativeState| { &m.auction_end },
                        |m: &mut AuctionIndicativeState| { &mut m.auction_end },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                AuctionIndicativeState,
            >("AuctionIndicativeState", fields, oneofs)
        }
    }
    impl ::protobuf::Message for AuctionIndicativeState {
        const NAME: &'static str = "AuctionIndicativeState";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.market_id = is.read_string()?;
                    }
                    18 => {
                        self.indicative_price = is.read_string()?;
                    }
                    24 => {
                        self.indicative_volume = is.read_uint64()?;
                    }
                    32 => {
                        self.auction_start = is.read_int64()?;
                    }
                    40 => {
                        self.auction_end = is.read_int64()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.market_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.market_id);
            }
            if !self.indicative_price.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.indicative_price);
            }
            if self.indicative_volume != 0 {
                my_size += ::protobuf::rt::uint64_size(3, self.indicative_volume);
            }
            if self.auction_start != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.auction_start);
            }
            if self.auction_end != 0 {
                my_size += ::protobuf::rt::int64_size(5, self.auction_end);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.market_id.is_empty() {
                os.write_string(1, &self.market_id)?;
            }
            if !self.indicative_price.is_empty() {
                os.write_string(2, &self.indicative_price)?;
            }
            if self.indicative_volume != 0 {
                os.write_uint64(3, self.indicative_volume)?;
            }
            if self.auction_start != 0 {
                os.write_int64(4, self.auction_start)?;
            }
            if self.auction_end != 0 {
                os.write_int64(5, self.auction_end)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> AuctionIndicativeState {
            AuctionIndicativeState::new()
        }
        fn clear(&mut self) {
            self.market_id.clear();
            self.indicative_price.clear();
            self.indicative_volume = 0;
            self.auction_start = 0;
            self.auction_end = 0;
            self.special_fields.clear();
        }
        fn default_instance() -> &'static AuctionIndicativeState {
            static instance: AuctionIndicativeState = AuctionIndicativeState {
                market_id: ::std::string::String::new(),
                indicative_price: ::std::string::String::new(),
                indicative_volume: 0,
                auction_start: 0,
                auction_end: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for AuctionIndicativeState {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("AuctionIndicativeState")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for AuctionIndicativeState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for AuctionIndicativeState {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct Trade {
        pub id: ::std::string::String,
        pub market_id: ::std::string::String,
        pub price: ::std::string::String,
        pub size: u64,
        pub buyer: ::std::string::String,
        pub seller: ::std::string::String,
        pub aggressor: ::protobuf::EnumOrUnknown<Side>,
        pub buy_order: ::std::string::String,
        pub sell_order: ::std::string::String,
        pub timestamp: i64,
        pub type_: ::protobuf::EnumOrUnknown<trade::Type>,
        pub buyer_fee: ::protobuf::MessageField<Fee>,
        pub seller_fee: ::protobuf::MessageField<Fee>,
        pub buyer_auction_batch: u64,
        pub seller_auction_batch: u64,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Trade {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Trade {
        #[inline]
        fn eq(&self, other: &Trade) -> bool {
            self.id == other.id && self.market_id == other.market_id
                && self.price == other.price && self.size == other.size
                && self.buyer == other.buyer && self.seller == other.seller
                && self.aggressor == other.aggressor && self.buy_order == other.buy_order
                && self.sell_order == other.sell_order
                && self.timestamp == other.timestamp && self.type_ == other.type_
                && self.buyer_fee == other.buyer_fee
                && self.seller_fee == other.seller_fee
                && self.buyer_auction_batch == other.buyer_auction_batch
                && self.seller_auction_batch == other.seller_auction_batch
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Trade {
        #[inline]
        fn clone(&self) -> Trade {
            Trade {
                id: ::core::clone::Clone::clone(&self.id),
                market_id: ::core::clone::Clone::clone(&self.market_id),
                price: ::core::clone::Clone::clone(&self.price),
                size: ::core::clone::Clone::clone(&self.size),
                buyer: ::core::clone::Clone::clone(&self.buyer),
                seller: ::core::clone::Clone::clone(&self.seller),
                aggressor: ::core::clone::Clone::clone(&self.aggressor),
                buy_order: ::core::clone::Clone::clone(&self.buy_order),
                sell_order: ::core::clone::Clone::clone(&self.sell_order),
                timestamp: ::core::clone::Clone::clone(&self.timestamp),
                type_: ::core::clone::Clone::clone(&self.type_),
                buyer_fee: ::core::clone::Clone::clone(&self.buyer_fee),
                seller_fee: ::core::clone::Clone::clone(&self.seller_fee),
                buyer_auction_batch: ::core::clone::Clone::clone(
                    &self.buyer_auction_batch,
                ),
                seller_auction_batch: ::core::clone::Clone::clone(
                    &self.seller_auction_batch,
                ),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Trade {
        #[inline]
        fn default() -> Trade {
            Trade {
                id: ::core::default::Default::default(),
                market_id: ::core::default::Default::default(),
                price: ::core::default::Default::default(),
                size: ::core::default::Default::default(),
                buyer: ::core::default::Default::default(),
                seller: ::core::default::Default::default(),
                aggressor: ::core::default::Default::default(),
                buy_order: ::core::default::Default::default(),
                sell_order: ::core::default::Default::default(),
                timestamp: ::core::default::Default::default(),
                type_: ::core::default::Default::default(),
                buyer_fee: ::core::default::Default::default(),
                seller_fee: ::core::default::Default::default(),
                buyer_auction_batch: ::core::default::Default::default(),
                seller_auction_batch: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Trade {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "market_id",
                "price",
                "size",
                "buyer",
                "seller",
                "aggressor",
                "buy_order",
                "sell_order",
                "timestamp",
                "type_",
                "buyer_fee",
                "seller_fee",
                "buyer_auction_batch",
                "seller_auction_batch",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.id,
                &&self.market_id,
                &&self.price,
                &&self.size,
                &&self.buyer,
                &&self.seller,
                &&self.aggressor,
                &&self.buy_order,
                &&self.sell_order,
                &&self.timestamp,
                &&self.type_,
                &&self.buyer_fee,
                &&self.seller_fee,
                &&self.buyer_auction_batch,
                &&self.seller_auction_batch,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Trade", names, values)
        }
    }
    impl<'a> ::std::default::Default for &'a Trade {
        fn default() -> &'a Trade {
            <Trade as ::protobuf::Message>::default_instance()
        }
    }
    impl Trade {
        pub fn new() -> Trade {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(15);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >("id", |m: &Trade| { &m.id }, |m: &mut Trade| { &mut m.id }),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "market_id",
                        |m: &Trade| { &m.market_id },
                        |m: &mut Trade| { &mut m.market_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "price",
                        |m: &Trade| { &m.price },
                        |m: &mut Trade| { &mut m.price },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >("size", |m: &Trade| { &m.size }, |m: &mut Trade| { &mut m.size }),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "buyer",
                        |m: &Trade| { &m.buyer },
                        |m: &mut Trade| { &mut m.buyer },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "seller",
                        |m: &Trade| { &m.seller },
                        |m: &mut Trade| { &mut m.seller },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "aggressor",
                        |m: &Trade| { &m.aggressor },
                        |m: &mut Trade| { &mut m.aggressor },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "buy_order",
                        |m: &Trade| { &m.buy_order },
                        |m: &mut Trade| { &mut m.buy_order },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "sell_order",
                        |m: &Trade| { &m.sell_order },
                        |m: &mut Trade| { &mut m.sell_order },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "timestamp",
                        |m: &Trade| { &m.timestamp },
                        |m: &mut Trade| { &mut m.timestamp },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >("type", |m: &Trade| { &m.type_ }, |m: &mut Trade| { &mut m.type_ }),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        Fee,
                    >(
                        "buyer_fee",
                        |m: &Trade| { &m.buyer_fee },
                        |m: &mut Trade| { &mut m.buyer_fee },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        Fee,
                    >(
                        "seller_fee",
                        |m: &Trade| { &m.seller_fee },
                        |m: &mut Trade| { &mut m.seller_fee },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "buyer_auction_batch",
                        |m: &Trade| { &m.buyer_auction_batch },
                        |m: &mut Trade| { &mut m.buyer_auction_batch },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "seller_auction_batch",
                        |m: &Trade| { &m.seller_auction_batch },
                        |m: &mut Trade| { &mut m.seller_auction_batch },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                Trade,
            >("Trade", fields, oneofs)
        }
    }
    impl ::protobuf::Message for Trade {
        const NAME: &'static str = "Trade";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.id = is.read_string()?;
                    }
                    18 => {
                        self.market_id = is.read_string()?;
                    }
                    26 => {
                        self.price = is.read_string()?;
                    }
                    32 => {
                        self.size = is.read_uint64()?;
                    }
                    42 => {
                        self.buyer = is.read_string()?;
                    }
                    50 => {
                        self.seller = is.read_string()?;
                    }
                    56 => {
                        self.aggressor = is.read_enum_or_unknown()?;
                    }
                    66 => {
                        self.buy_order = is.read_string()?;
                    }
                    74 => {
                        self.sell_order = is.read_string()?;
                    }
                    80 => {
                        self.timestamp = is.read_int64()?;
                    }
                    88 => {
                        self.type_ = is.read_enum_or_unknown()?;
                    }
                    98 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.buyer_fee,
                        )?;
                    }
                    106 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.seller_fee,
                        )?;
                    }
                    112 => {
                        self.buyer_auction_batch = is.read_uint64()?;
                    }
                    120 => {
                        self.seller_auction_batch = is.read_uint64()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.id);
            }
            if !self.market_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.market_id);
            }
            if !self.price.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.price);
            }
            if self.size != 0 {
                my_size += ::protobuf::rt::uint64_size(4, self.size);
            }
            if !self.buyer.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.buyer);
            }
            if !self.seller.is_empty() {
                my_size += ::protobuf::rt::string_size(6, &self.seller);
            }
            if self.aggressor != ::protobuf::EnumOrUnknown::new(Side::SIDE_UNSPECIFIED) {
                my_size += ::protobuf::rt::int32_size(7, self.aggressor.value());
            }
            if !self.buy_order.is_empty() {
                my_size += ::protobuf::rt::string_size(8, &self.buy_order);
            }
            if !self.sell_order.is_empty() {
                my_size += ::protobuf::rt::string_size(9, &self.sell_order);
            }
            if self.timestamp != 0 {
                my_size += ::protobuf::rt::int64_size(10, self.timestamp);
            }
            if self.type_
                != ::protobuf::EnumOrUnknown::new(trade::Type::TYPE_UNSPECIFIED)
            {
                my_size += ::protobuf::rt::int32_size(11, self.type_.value());
            }
            if let Some(v) = self.buyer_fee.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.seller_fee.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.buyer_auction_batch != 0 {
                my_size += ::protobuf::rt::uint64_size(14, self.buyer_auction_batch);
            }
            if self.seller_auction_batch != 0 {
                my_size += ::protobuf::rt::uint64_size(15, self.seller_auction_batch);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.id.is_empty() {
                os.write_string(1, &self.id)?;
            }
            if !self.market_id.is_empty() {
                os.write_string(2, &self.market_id)?;
            }
            if !self.price.is_empty() {
                os.write_string(3, &self.price)?;
            }
            if self.size != 0 {
                os.write_uint64(4, self.size)?;
            }
            if !self.buyer.is_empty() {
                os.write_string(5, &self.buyer)?;
            }
            if !self.seller.is_empty() {
                os.write_string(6, &self.seller)?;
            }
            if self.aggressor != ::protobuf::EnumOrUnknown::new(Side::SIDE_UNSPECIFIED) {
                os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.aggressor))?;
            }
            if !self.buy_order.is_empty() {
                os.write_string(8, &self.buy_order)?;
            }
            if !self.sell_order.is_empty() {
                os.write_string(9, &self.sell_order)?;
            }
            if self.timestamp != 0 {
                os.write_int64(10, self.timestamp)?;
            }
            if self.type_
                != ::protobuf::EnumOrUnknown::new(trade::Type::TYPE_UNSPECIFIED)
            {
                os.write_enum(11, ::protobuf::EnumOrUnknown::value(&self.type_))?;
            }
            if let Some(v) = self.buyer_fee.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
            }
            if let Some(v) = self.seller_fee.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
            }
            if self.buyer_auction_batch != 0 {
                os.write_uint64(14, self.buyer_auction_batch)?;
            }
            if self.seller_auction_batch != 0 {
                os.write_uint64(15, self.seller_auction_batch)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> Trade {
            Trade::new()
        }
        fn clear(&mut self) {
            self.id.clear();
            self.market_id.clear();
            self.price.clear();
            self.size = 0;
            self.buyer.clear();
            self.seller.clear();
            self.aggressor = ::protobuf::EnumOrUnknown::new(Side::SIDE_UNSPECIFIED);
            self.buy_order.clear();
            self.sell_order.clear();
            self.timestamp = 0;
            self.type_ = ::protobuf::EnumOrUnknown::new(trade::Type::TYPE_UNSPECIFIED);
            self.buyer_fee.clear();
            self.seller_fee.clear();
            self.buyer_auction_batch = 0;
            self.seller_auction_batch = 0;
            self.special_fields.clear();
        }
        fn default_instance() -> &'static Trade {
            static instance: Trade = Trade {
                id: ::std::string::String::new(),
                market_id: ::std::string::String::new(),
                price: ::std::string::String::new(),
                size: 0,
                buyer: ::std::string::String::new(),
                seller: ::std::string::String::new(),
                aggressor: ::protobuf::EnumOrUnknown::from_i32(0),
                buy_order: ::std::string::String::new(),
                sell_order: ::std::string::String::new(),
                timestamp: 0,
                type_: ::protobuf::EnumOrUnknown::from_i32(0),
                buyer_fee: ::protobuf::MessageField::none(),
                seller_fee: ::protobuf::MessageField::none(),
                buyer_auction_batch: 0,
                seller_auction_batch: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for Trade {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor().message_by_package_relative_name("Trade").unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for Trade {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for Trade {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    /// Nested message and enums of message `Trade`
    pub mod trade {
        #[postgres(name = "transfer_type")]
        pub enum Type {
            TYPE_UNSPECIFIED = 0,
            TYPE_DEFAULT = 1,
            TYPE_NETWORK_CLOSE_OUT_GOOD = 2,
            TYPE_NETWORK_CLOSE_OUT_BAD = 3,
        }
        impl<'a> postgres_types::FromSql<'a> for Type {
            fn from_sql(
                _type: &postgres_types::Type,
                buf: &'a [u8],
            ) -> std::result::Result<
                Type,
                std::boxed::Box<
                    dyn std::error::Error + std::marker::Sync + std::marker::Send,
                >,
            > {
                match std::str::from_utf8(buf)? {
                    "TYPE_UNSPECIFIED" => std::result::Result::Ok(Type::TYPE_UNSPECIFIED),
                    "TYPE_DEFAULT" => std::result::Result::Ok(Type::TYPE_DEFAULT),
                    "TYPE_NETWORK_CLOSE_OUT_GOOD" => {
                        std::result::Result::Ok(Type::TYPE_NETWORK_CLOSE_OUT_GOOD)
                    }
                    "TYPE_NETWORK_CLOSE_OUT_BAD" => {
                        std::result::Result::Ok(Type::TYPE_NETWORK_CLOSE_OUT_BAD)
                    }
                    s => {
                        std::result::Result::Err(
                            std::convert::Into::into({
                                let res = ::alloc::fmt::format(
                                    ::core::fmt::Arguments::new_v1(
                                        &["invalid variant `", "`"],
                                        &[::core::fmt::ArgumentV1::new_display(&s)],
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn accepts(type_: &postgres_types::Type) -> bool {
                if type_.name() != "transfer_type" {
                    return false;
                }
                match *type_.kind() {
                    ::postgres_types::Kind::Enum(ref variants) => {
                        if variants.len() != 4usize {
                            return false;
                        }
                        variants
                            .iter()
                            .all(|v| {
                                match &**v {
                                    "TYPE_UNSPECIFIED" => true,
                                    "TYPE_DEFAULT" => true,
                                    "TYPE_NETWORK_CLOSE_OUT_GOOD" => true,
                                    "TYPE_NETWORK_CLOSE_OUT_BAD" => true,
                                    _ => false,
                                }
                            })
                    }
                    _ => false,
                }
            }
        }
        impl postgres_types::ToSql for Type {
            fn to_sql(
                &self,
                _type: &postgres_types::Type,
                buf: &mut postgres_types::private::BytesMut,
            ) -> std::result::Result<
                postgres_types::IsNull,
                std::boxed::Box<
                    dyn std::error::Error + std::marker::Sync + std::marker::Send,
                >,
            > {
                let s = match *self {
                    Type::TYPE_UNSPECIFIED => "TYPE_UNSPECIFIED",
                    Type::TYPE_DEFAULT => "TYPE_DEFAULT",
                    Type::TYPE_NETWORK_CLOSE_OUT_GOOD => "TYPE_NETWORK_CLOSE_OUT_GOOD",
                    Type::TYPE_NETWORK_CLOSE_OUT_BAD => "TYPE_NETWORK_CLOSE_OUT_BAD",
                };
                buf.extend_from_slice(s.as_bytes());
                std::result::Result::Ok(postgres_types::IsNull::No)
            }
            fn accepts(type_: &postgres_types::Type) -> bool {
                if type_.name() != "transfer_type" {
                    return false;
                }
                match *type_.kind() {
                    ::postgres_types::Kind::Enum(ref variants) => {
                        if variants.len() != 4usize {
                            return false;
                        }
                        variants
                            .iter()
                            .all(|v| {
                                match &**v {
                                    "TYPE_UNSPECIFIED" => true,
                                    "TYPE_DEFAULT" => true,
                                    "TYPE_NETWORK_CLOSE_OUT_GOOD" => true,
                                    "TYPE_NETWORK_CLOSE_OUT_BAD" => true,
                                    _ => false,
                                }
                            })
                    }
                    _ => false,
                }
            }
            fn to_sql_checked(
                &self,
                ty: &::postgres_types::Type,
                out: &mut ::postgres_types::private::BytesMut,
            ) -> ::std::result::Result<
                ::postgres_types::IsNull,
                Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
            > {
                ::postgres_types::__to_sql_checked(self, ty, out)
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Type {
            #[inline]
            fn clone(&self) -> Type {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Type {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Type {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Type {
            #[inline]
            fn eq(&self, other: &Type) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Type {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Type {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Type {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Type::TYPE_UNSPECIFIED => {
                        ::core::fmt::Formatter::write_str(f, "TYPE_UNSPECIFIED")
                    }
                    Type::TYPE_DEFAULT => {
                        ::core::fmt::Formatter::write_str(f, "TYPE_DEFAULT")
                    }
                    Type::TYPE_NETWORK_CLOSE_OUT_GOOD => {
                        ::core::fmt::Formatter::write_str(
                            f,
                            "TYPE_NETWORK_CLOSE_OUT_GOOD",
                        )
                    }
                    Type::TYPE_NETWORK_CLOSE_OUT_BAD => {
                        ::core::fmt::Formatter::write_str(
                            f,
                            "TYPE_NETWORK_CLOSE_OUT_BAD",
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Type {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state)
            }
        }
        impl ::protobuf::Enum for Type {
            const NAME: &'static str = "Type";
            fn value(&self) -> i32 {
                *self as i32
            }
            fn from_i32(value: i32) -> ::std::option::Option<Type> {
                match value {
                    0 => ::std::option::Option::Some(Type::TYPE_UNSPECIFIED),
                    1 => ::std::option::Option::Some(Type::TYPE_DEFAULT),
                    2 => ::std::option::Option::Some(Type::TYPE_NETWORK_CLOSE_OUT_GOOD),
                    3 => ::std::option::Option::Some(Type::TYPE_NETWORK_CLOSE_OUT_BAD),
                    _ => ::std::option::Option::None,
                }
            }
            const VALUES: &'static [Type] = &[
                Type::TYPE_UNSPECIFIED,
                Type::TYPE_DEFAULT,
                Type::TYPE_NETWORK_CLOSE_OUT_GOOD,
                Type::TYPE_NETWORK_CLOSE_OUT_BAD,
            ];
        }
        impl ::protobuf::EnumFull for Type {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<
                    ::protobuf::reflect::EnumDescriptor,
                > = ::protobuf::rt::Lazy::new();
                descriptor
                    .get(|| {
                        super::file_descriptor()
                            .enum_by_package_relative_name("Trade.Type")
                            .unwrap()
                    })
                    .clone()
            }
            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }
        impl ::std::default::Default for Type {
            fn default() -> Self {
                Type::TYPE_UNSPECIFIED
            }
        }
        impl Type {
            pub(super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<
                    Type,
                >("Trade.Type")
            }
        }
    }
    pub struct Fee {
        pub maker_fee: ::std::string::String,
        pub infrastructure_fee: ::std::string::String,
        pub liquidity_fee: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Fee {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Fee {
        #[inline]
        fn eq(&self, other: &Fee) -> bool {
            self.maker_fee == other.maker_fee
                && self.infrastructure_fee == other.infrastructure_fee
                && self.liquidity_fee == other.liquidity_fee
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Fee {
        #[inline]
        fn clone(&self) -> Fee {
            Fee {
                maker_fee: ::core::clone::Clone::clone(&self.maker_fee),
                infrastructure_fee: ::core::clone::Clone::clone(
                    &self.infrastructure_fee,
                ),
                liquidity_fee: ::core::clone::Clone::clone(&self.liquidity_fee),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Fee {
        #[inline]
        fn default() -> Fee {
            Fee {
                maker_fee: ::core::default::Default::default(),
                infrastructure_fee: ::core::default::Default::default(),
                liquidity_fee: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Fee {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Fee",
                "maker_fee",
                &&self.maker_fee,
                "infrastructure_fee",
                &&self.infrastructure_fee,
                "liquidity_fee",
                &&self.liquidity_fee,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a Fee {
        fn default() -> &'a Fee {
            <Fee as ::protobuf::Message>::default_instance()
        }
    }
    impl Fee {
        pub fn new() -> Fee {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "maker_fee",
                        |m: &Fee| { &m.maker_fee },
                        |m: &mut Fee| { &mut m.maker_fee },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "infrastructure_fee",
                        |m: &Fee| { &m.infrastructure_fee },
                        |m: &mut Fee| { &mut m.infrastructure_fee },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "liquidity_fee",
                        |m: &Fee| { &m.liquidity_fee },
                        |m: &mut Fee| { &mut m.liquidity_fee },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                Fee,
            >("Fee", fields, oneofs)
        }
    }
    impl ::protobuf::Message for Fee {
        const NAME: &'static str = "Fee";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.maker_fee = is.read_string()?;
                    }
                    18 => {
                        self.infrastructure_fee = is.read_string()?;
                    }
                    26 => {
                        self.liquidity_fee = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.maker_fee.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.maker_fee);
            }
            if !self.infrastructure_fee.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.infrastructure_fee);
            }
            if !self.liquidity_fee.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.liquidity_fee);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.maker_fee.is_empty() {
                os.write_string(1, &self.maker_fee)?;
            }
            if !self.infrastructure_fee.is_empty() {
                os.write_string(2, &self.infrastructure_fee)?;
            }
            if !self.liquidity_fee.is_empty() {
                os.write_string(3, &self.liquidity_fee)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> Fee {
            Fee::new()
        }
        fn clear(&mut self) {
            self.maker_fee.clear();
            self.infrastructure_fee.clear();
            self.liquidity_fee.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static Fee {
            static instance: Fee = Fee {
                maker_fee: ::std::string::String::new(),
                infrastructure_fee: ::std::string::String::new(),
                liquidity_fee: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for Fee {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor().message_by_package_relative_name("Fee").unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for Fee {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for Fee {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct TradeSet {
        pub trades: ::std::vec::Vec<Trade>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TradeSet {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TradeSet {
        #[inline]
        fn eq(&self, other: &TradeSet) -> bool {
            self.trades == other.trades && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TradeSet {
        #[inline]
        fn clone(&self) -> TradeSet {
            TradeSet {
                trades: ::core::clone::Clone::clone(&self.trades),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for TradeSet {
        #[inline]
        fn default() -> TradeSet {
            TradeSet {
                trades: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TradeSet {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "TradeSet",
                "trades",
                &&self.trades,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a TradeSet {
        fn default() -> &'a TradeSet {
            <TradeSet as ::protobuf::Message>::default_instance()
        }
    }
    impl TradeSet {
        pub fn new() -> TradeSet {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "trades",
                        |m: &TradeSet| { &m.trades },
                        |m: &mut TradeSet| { &mut m.trades },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                TradeSet,
            >("TradeSet", fields, oneofs)
        }
    }
    impl ::protobuf::Message for TradeSet {
        const NAME: &'static str = "TradeSet";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.trades.push(is.read_message()?);
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.trades {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            for v in &self.trades {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> TradeSet {
            TradeSet::new()
        }
        fn clear(&mut self) {
            self.trades.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static TradeSet {
            static instance: TradeSet = TradeSet {
                trades: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for TradeSet {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("TradeSet")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for TradeSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for TradeSet {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct Candle {
        pub timestamp: i64,
        pub datetime: ::std::string::String,
        pub high: ::std::string::String,
        pub low: ::std::string::String,
        pub open: ::std::string::String,
        pub close: ::std::string::String,
        pub volume: u64,
        pub interval: ::protobuf::EnumOrUnknown<Interval>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Candle {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Candle {
        #[inline]
        fn eq(&self, other: &Candle) -> bool {
            self.timestamp == other.timestamp && self.datetime == other.datetime
                && self.high == other.high && self.low == other.low
                && self.open == other.open && self.close == other.close
                && self.volume == other.volume && self.interval == other.interval
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Candle {
        #[inline]
        fn clone(&self) -> Candle {
            Candle {
                timestamp: ::core::clone::Clone::clone(&self.timestamp),
                datetime: ::core::clone::Clone::clone(&self.datetime),
                high: ::core::clone::Clone::clone(&self.high),
                low: ::core::clone::Clone::clone(&self.low),
                open: ::core::clone::Clone::clone(&self.open),
                close: ::core::clone::Clone::clone(&self.close),
                volume: ::core::clone::Clone::clone(&self.volume),
                interval: ::core::clone::Clone::clone(&self.interval),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Candle {
        #[inline]
        fn default() -> Candle {
            Candle {
                timestamp: ::core::default::Default::default(),
                datetime: ::core::default::Default::default(),
                high: ::core::default::Default::default(),
                low: ::core::default::Default::default(),
                open: ::core::default::Default::default(),
                close: ::core::default::Default::default(),
                volume: ::core::default::Default::default(),
                interval: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Candle {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "timestamp",
                "datetime",
                "high",
                "low",
                "open",
                "close",
                "volume",
                "interval",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.timestamp,
                &&self.datetime,
                &&self.high,
                &&self.low,
                &&self.open,
                &&self.close,
                &&self.volume,
                &&self.interval,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "Candle",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a Candle {
        fn default() -> &'a Candle {
            <Candle as ::protobuf::Message>::default_instance()
        }
    }
    impl Candle {
        pub fn new() -> Candle {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "timestamp",
                        |m: &Candle| { &m.timestamp },
                        |m: &mut Candle| { &mut m.timestamp },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "datetime",
                        |m: &Candle| { &m.datetime },
                        |m: &mut Candle| { &mut m.datetime },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >("high", |m: &Candle| { &m.high }, |m: &mut Candle| { &mut m.high }),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >("low", |m: &Candle| { &m.low }, |m: &mut Candle| { &mut m.low }),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >("open", |m: &Candle| { &m.open }, |m: &mut Candle| { &mut m.open }),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "close",
                        |m: &Candle| { &m.close },
                        |m: &mut Candle| { &mut m.close },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "volume",
                        |m: &Candle| { &m.volume },
                        |m: &mut Candle| { &mut m.volume },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "interval",
                        |m: &Candle| { &m.interval },
                        |m: &mut Candle| { &mut m.interval },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                Candle,
            >("Candle", fields, oneofs)
        }
    }
    impl ::protobuf::Message for Candle {
        const NAME: &'static str = "Candle";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.timestamp = is.read_int64()?;
                    }
                    18 => {
                        self.datetime = is.read_string()?;
                    }
                    26 => {
                        self.high = is.read_string()?;
                    }
                    34 => {
                        self.low = is.read_string()?;
                    }
                    42 => {
                        self.open = is.read_string()?;
                    }
                    50 => {
                        self.close = is.read_string()?;
                    }
                    56 => {
                        self.volume = is.read_uint64()?;
                    }
                    64 => {
                        self.interval = is.read_enum_or_unknown()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.timestamp != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.timestamp);
            }
            if !self.datetime.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.datetime);
            }
            if !self.high.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.high);
            }
            if !self.low.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.low);
            }
            if !self.open.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.open);
            }
            if !self.close.is_empty() {
                my_size += ::protobuf::rt::string_size(6, &self.close);
            }
            if self.volume != 0 {
                my_size += ::protobuf::rt::uint64_size(7, self.volume);
            }
            if self.interval
                != ::protobuf::EnumOrUnknown::new(Interval::INTERVAL_UNSPECIFIED)
            {
                my_size += ::protobuf::rt::int32_size(8, self.interval.value());
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if self.timestamp != 0 {
                os.write_int64(1, self.timestamp)?;
            }
            if !self.datetime.is_empty() {
                os.write_string(2, &self.datetime)?;
            }
            if !self.high.is_empty() {
                os.write_string(3, &self.high)?;
            }
            if !self.low.is_empty() {
                os.write_string(4, &self.low)?;
            }
            if !self.open.is_empty() {
                os.write_string(5, &self.open)?;
            }
            if !self.close.is_empty() {
                os.write_string(6, &self.close)?;
            }
            if self.volume != 0 {
                os.write_uint64(7, self.volume)?;
            }
            if self.interval
                != ::protobuf::EnumOrUnknown::new(Interval::INTERVAL_UNSPECIFIED)
            {
                os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.interval))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> Candle {
            Candle::new()
        }
        fn clear(&mut self) {
            self.timestamp = 0;
            self.datetime.clear();
            self.high.clear();
            self.low.clear();
            self.open.clear();
            self.close.clear();
            self.volume = 0;
            self
                .interval = ::protobuf::EnumOrUnknown::new(
                Interval::INTERVAL_UNSPECIFIED,
            );
            self.special_fields.clear();
        }
        fn default_instance() -> &'static Candle {
            static instance: Candle = Candle {
                timestamp: 0,
                datetime: ::std::string::String::new(),
                high: ::std::string::String::new(),
                low: ::std::string::String::new(),
                open: ::std::string::String::new(),
                close: ::std::string::String::new(),
                volume: 0,
                interval: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for Candle {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor().message_by_package_relative_name("Candle").unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for Candle {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for Candle {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct PriceLevel {
        pub price: ::std::string::String,
        pub number_of_orders: u64,
        pub volume: u64,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PriceLevel {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PriceLevel {
        #[inline]
        fn eq(&self, other: &PriceLevel) -> bool {
            self.price == other.price && self.number_of_orders == other.number_of_orders
                && self.volume == other.volume
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PriceLevel {
        #[inline]
        fn clone(&self) -> PriceLevel {
            PriceLevel {
                price: ::core::clone::Clone::clone(&self.price),
                number_of_orders: ::core::clone::Clone::clone(&self.number_of_orders),
                volume: ::core::clone::Clone::clone(&self.volume),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for PriceLevel {
        #[inline]
        fn default() -> PriceLevel {
            PriceLevel {
                price: ::core::default::Default::default(),
                number_of_orders: ::core::default::Default::default(),
                volume: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PriceLevel {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "PriceLevel",
                "price",
                &&self.price,
                "number_of_orders",
                &&self.number_of_orders,
                "volume",
                &&self.volume,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a PriceLevel {
        fn default() -> &'a PriceLevel {
            <PriceLevel as ::protobuf::Message>::default_instance()
        }
    }
    impl PriceLevel {
        pub fn new() -> PriceLevel {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "price",
                        |m: &PriceLevel| { &m.price },
                        |m: &mut PriceLevel| { &mut m.price },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "number_of_orders",
                        |m: &PriceLevel| { &m.number_of_orders },
                        |m: &mut PriceLevel| { &mut m.number_of_orders },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "volume",
                        |m: &PriceLevel| { &m.volume },
                        |m: &mut PriceLevel| { &mut m.volume },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                PriceLevel,
            >("PriceLevel", fields, oneofs)
        }
    }
    impl ::protobuf::Message for PriceLevel {
        const NAME: &'static str = "PriceLevel";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.price = is.read_string()?;
                    }
                    16 => {
                        self.number_of_orders = is.read_uint64()?;
                    }
                    24 => {
                        self.volume = is.read_uint64()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.price.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.price);
            }
            if self.number_of_orders != 0 {
                my_size += ::protobuf::rt::uint64_size(2, self.number_of_orders);
            }
            if self.volume != 0 {
                my_size += ::protobuf::rt::uint64_size(3, self.volume);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.price.is_empty() {
                os.write_string(1, &self.price)?;
            }
            if self.number_of_orders != 0 {
                os.write_uint64(2, self.number_of_orders)?;
            }
            if self.volume != 0 {
                os.write_uint64(3, self.volume)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> PriceLevel {
            PriceLevel::new()
        }
        fn clear(&mut self) {
            self.price.clear();
            self.number_of_orders = 0;
            self.volume = 0;
            self.special_fields.clear();
        }
        fn default_instance() -> &'static PriceLevel {
            static instance: PriceLevel = PriceLevel {
                price: ::std::string::String::new(),
                number_of_orders: 0,
                volume: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for PriceLevel {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("PriceLevel")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for PriceLevel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for PriceLevel {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct MarketDepth {
        pub market_id: ::std::string::String,
        pub buy: ::std::vec::Vec<PriceLevel>,
        pub sell: ::std::vec::Vec<PriceLevel>,
        pub sequence_number: u64,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MarketDepth {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MarketDepth {
        #[inline]
        fn eq(&self, other: &MarketDepth) -> bool {
            self.market_id == other.market_id && self.buy == other.buy
                && self.sell == other.sell
                && self.sequence_number == other.sequence_number
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MarketDepth {
        #[inline]
        fn clone(&self) -> MarketDepth {
            MarketDepth {
                market_id: ::core::clone::Clone::clone(&self.market_id),
                buy: ::core::clone::Clone::clone(&self.buy),
                sell: ::core::clone::Clone::clone(&self.sell),
                sequence_number: ::core::clone::Clone::clone(&self.sequence_number),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for MarketDepth {
        #[inline]
        fn default() -> MarketDepth {
            MarketDepth {
                market_id: ::core::default::Default::default(),
                buy: ::core::default::Default::default(),
                sell: ::core::default::Default::default(),
                sequence_number: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for MarketDepth {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "MarketDepth",
                "market_id",
                &&self.market_id,
                "buy",
                &&self.buy,
                "sell",
                &&self.sell,
                "sequence_number",
                &&self.sequence_number,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a MarketDepth {
        fn default() -> &'a MarketDepth {
            <MarketDepth as ::protobuf::Message>::default_instance()
        }
    }
    impl MarketDepth {
        pub fn new() -> MarketDepth {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "market_id",
                        |m: &MarketDepth| { &m.market_id },
                        |m: &mut MarketDepth| { &mut m.market_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "buy",
                        |m: &MarketDepth| { &m.buy },
                        |m: &mut MarketDepth| { &mut m.buy },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "sell",
                        |m: &MarketDepth| { &m.sell },
                        |m: &mut MarketDepth| { &mut m.sell },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "sequence_number",
                        |m: &MarketDepth| { &m.sequence_number },
                        |m: &mut MarketDepth| { &mut m.sequence_number },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                MarketDepth,
            >("MarketDepth", fields, oneofs)
        }
    }
    impl ::protobuf::Message for MarketDepth {
        const NAME: &'static str = "MarketDepth";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.market_id = is.read_string()?;
                    }
                    18 => {
                        self.buy.push(is.read_message()?);
                    }
                    26 => {
                        self.sell.push(is.read_message()?);
                    }
                    32 => {
                        self.sequence_number = is.read_uint64()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.market_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.market_id);
            }
            for value in &self.buy {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.sell {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.sequence_number != 0 {
                my_size += ::protobuf::rt::uint64_size(4, self.sequence_number);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.market_id.is_empty() {
                os.write_string(1, &self.market_id)?;
            }
            for v in &self.buy {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            for v in &self.sell {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if self.sequence_number != 0 {
                os.write_uint64(4, self.sequence_number)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> MarketDepth {
            MarketDepth::new()
        }
        fn clear(&mut self) {
            self.market_id.clear();
            self.buy.clear();
            self.sell.clear();
            self.sequence_number = 0;
            self.special_fields.clear();
        }
        fn default_instance() -> &'static MarketDepth {
            static instance: MarketDepth = MarketDepth {
                market_id: ::std::string::String::new(),
                buy: ::std::vec::Vec::new(),
                sell: ::std::vec::Vec::new(),
                sequence_number: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for MarketDepth {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("MarketDepth")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for MarketDepth {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for MarketDepth {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct MarketDepthUpdate {
        pub market_id: ::std::string::String,
        pub buy: ::std::vec::Vec<PriceLevel>,
        pub sell: ::std::vec::Vec<PriceLevel>,
        pub sequence_number: u64,
        pub previous_sequence_number: u64,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MarketDepthUpdate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MarketDepthUpdate {
        #[inline]
        fn eq(&self, other: &MarketDepthUpdate) -> bool {
            self.market_id == other.market_id && self.buy == other.buy
                && self.sell == other.sell
                && self.sequence_number == other.sequence_number
                && self.previous_sequence_number == other.previous_sequence_number
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MarketDepthUpdate {
        #[inline]
        fn clone(&self) -> MarketDepthUpdate {
            MarketDepthUpdate {
                market_id: ::core::clone::Clone::clone(&self.market_id),
                buy: ::core::clone::Clone::clone(&self.buy),
                sell: ::core::clone::Clone::clone(&self.sell),
                sequence_number: ::core::clone::Clone::clone(&self.sequence_number),
                previous_sequence_number: ::core::clone::Clone::clone(
                    &self.previous_sequence_number,
                ),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for MarketDepthUpdate {
        #[inline]
        fn default() -> MarketDepthUpdate {
            MarketDepthUpdate {
                market_id: ::core::default::Default::default(),
                buy: ::core::default::Default::default(),
                sell: ::core::default::Default::default(),
                sequence_number: ::core::default::Default::default(),
                previous_sequence_number: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for MarketDepthUpdate {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "market_id",
                "buy",
                "sell",
                "sequence_number",
                "previous_sequence_number",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.market_id,
                &&self.buy,
                &&self.sell,
                &&self.sequence_number,
                &&self.previous_sequence_number,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "MarketDepthUpdate",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a MarketDepthUpdate {
        fn default() -> &'a MarketDepthUpdate {
            <MarketDepthUpdate as ::protobuf::Message>::default_instance()
        }
    }
    impl MarketDepthUpdate {
        pub fn new() -> MarketDepthUpdate {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "market_id",
                        |m: &MarketDepthUpdate| { &m.market_id },
                        |m: &mut MarketDepthUpdate| { &mut m.market_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "buy",
                        |m: &MarketDepthUpdate| { &m.buy },
                        |m: &mut MarketDepthUpdate| { &mut m.buy },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "sell",
                        |m: &MarketDepthUpdate| { &m.sell },
                        |m: &mut MarketDepthUpdate| { &mut m.sell },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "sequence_number",
                        |m: &MarketDepthUpdate| { &m.sequence_number },
                        |m: &mut MarketDepthUpdate| { &mut m.sequence_number },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "previous_sequence_number",
                        |m: &MarketDepthUpdate| { &m.previous_sequence_number },
                        |m: &mut MarketDepthUpdate| { &mut m.previous_sequence_number },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                MarketDepthUpdate,
            >("MarketDepthUpdate", fields, oneofs)
        }
    }
    impl ::protobuf::Message for MarketDepthUpdate {
        const NAME: &'static str = "MarketDepthUpdate";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.market_id = is.read_string()?;
                    }
                    18 => {
                        self.buy.push(is.read_message()?);
                    }
                    26 => {
                        self.sell.push(is.read_message()?);
                    }
                    32 => {
                        self.sequence_number = is.read_uint64()?;
                    }
                    40 => {
                        self.previous_sequence_number = is.read_uint64()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.market_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.market_id);
            }
            for value in &self.buy {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.sell {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.sequence_number != 0 {
                my_size += ::protobuf::rt::uint64_size(4, self.sequence_number);
            }
            if self.previous_sequence_number != 0 {
                my_size += ::protobuf::rt::uint64_size(5, self.previous_sequence_number);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.market_id.is_empty() {
                os.write_string(1, &self.market_id)?;
            }
            for v in &self.buy {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            for v in &self.sell {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if self.sequence_number != 0 {
                os.write_uint64(4, self.sequence_number)?;
            }
            if self.previous_sequence_number != 0 {
                os.write_uint64(5, self.previous_sequence_number)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> MarketDepthUpdate {
            MarketDepthUpdate::new()
        }
        fn clear(&mut self) {
            self.market_id.clear();
            self.buy.clear();
            self.sell.clear();
            self.sequence_number = 0;
            self.previous_sequence_number = 0;
            self.special_fields.clear();
        }
        fn default_instance() -> &'static MarketDepthUpdate {
            static instance: MarketDepthUpdate = MarketDepthUpdate {
                market_id: ::std::string::String::new(),
                buy: ::std::vec::Vec::new(),
                sell: ::std::vec::Vec::new(),
                sequence_number: 0,
                previous_sequence_number: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for MarketDepthUpdate {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("MarketDepthUpdate")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for MarketDepthUpdate {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for MarketDepthUpdate {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct Position {
        pub market_id: ::std::string::String,
        pub party_id: ::std::string::String,
        pub open_volume: i64,
        pub realised_pnl: ::std::string::String,
        pub unrealised_pnl: ::std::string::String,
        pub average_entry_price: ::std::string::String,
        pub updated_at: i64,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Position {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Position {
        #[inline]
        fn eq(&self, other: &Position) -> bool {
            self.market_id == other.market_id && self.party_id == other.party_id
                && self.open_volume == other.open_volume
                && self.realised_pnl == other.realised_pnl
                && self.unrealised_pnl == other.unrealised_pnl
                && self.average_entry_price == other.average_entry_price
                && self.updated_at == other.updated_at
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Position {
        #[inline]
        fn clone(&self) -> Position {
            Position {
                market_id: ::core::clone::Clone::clone(&self.market_id),
                party_id: ::core::clone::Clone::clone(&self.party_id),
                open_volume: ::core::clone::Clone::clone(&self.open_volume),
                realised_pnl: ::core::clone::Clone::clone(&self.realised_pnl),
                unrealised_pnl: ::core::clone::Clone::clone(&self.unrealised_pnl),
                average_entry_price: ::core::clone::Clone::clone(
                    &self.average_entry_price,
                ),
                updated_at: ::core::clone::Clone::clone(&self.updated_at),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Position {
        #[inline]
        fn default() -> Position {
            Position {
                market_id: ::core::default::Default::default(),
                party_id: ::core::default::Default::default(),
                open_volume: ::core::default::Default::default(),
                realised_pnl: ::core::default::Default::default(),
                unrealised_pnl: ::core::default::Default::default(),
                average_entry_price: ::core::default::Default::default(),
                updated_at: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Position {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "market_id",
                "party_id",
                "open_volume",
                "realised_pnl",
                "unrealised_pnl",
                "average_entry_price",
                "updated_at",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.market_id,
                &&self.party_id,
                &&self.open_volume,
                &&self.realised_pnl,
                &&self.unrealised_pnl,
                &&self.average_entry_price,
                &&self.updated_at,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "Position",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a Position {
        fn default() -> &'a Position {
            <Position as ::protobuf::Message>::default_instance()
        }
    }
    impl Position {
        pub fn new() -> Position {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "market_id",
                        |m: &Position| { &m.market_id },
                        |m: &mut Position| { &mut m.market_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "party_id",
                        |m: &Position| { &m.party_id },
                        |m: &mut Position| { &mut m.party_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "open_volume",
                        |m: &Position| { &m.open_volume },
                        |m: &mut Position| { &mut m.open_volume },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "realised_pnl",
                        |m: &Position| { &m.realised_pnl },
                        |m: &mut Position| { &mut m.realised_pnl },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "unrealised_pnl",
                        |m: &Position| { &m.unrealised_pnl },
                        |m: &mut Position| { &mut m.unrealised_pnl },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "average_entry_price",
                        |m: &Position| { &m.average_entry_price },
                        |m: &mut Position| { &mut m.average_entry_price },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "updated_at",
                        |m: &Position| { &m.updated_at },
                        |m: &mut Position| { &mut m.updated_at },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                Position,
            >("Position", fields, oneofs)
        }
    }
    impl ::protobuf::Message for Position {
        const NAME: &'static str = "Position";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.market_id = is.read_string()?;
                    }
                    18 => {
                        self.party_id = is.read_string()?;
                    }
                    24 => {
                        self.open_volume = is.read_int64()?;
                    }
                    34 => {
                        self.realised_pnl = is.read_string()?;
                    }
                    42 => {
                        self.unrealised_pnl = is.read_string()?;
                    }
                    50 => {
                        self.average_entry_price = is.read_string()?;
                    }
                    56 => {
                        self.updated_at = is.read_int64()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.market_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.market_id);
            }
            if !self.party_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.party_id);
            }
            if self.open_volume != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.open_volume);
            }
            if !self.realised_pnl.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.realised_pnl);
            }
            if !self.unrealised_pnl.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.unrealised_pnl);
            }
            if !self.average_entry_price.is_empty() {
                my_size += ::protobuf::rt::string_size(6, &self.average_entry_price);
            }
            if self.updated_at != 0 {
                my_size += ::protobuf::rt::int64_size(7, self.updated_at);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.market_id.is_empty() {
                os.write_string(1, &self.market_id)?;
            }
            if !self.party_id.is_empty() {
                os.write_string(2, &self.party_id)?;
            }
            if self.open_volume != 0 {
                os.write_int64(3, self.open_volume)?;
            }
            if !self.realised_pnl.is_empty() {
                os.write_string(4, &self.realised_pnl)?;
            }
            if !self.unrealised_pnl.is_empty() {
                os.write_string(5, &self.unrealised_pnl)?;
            }
            if !self.average_entry_price.is_empty() {
                os.write_string(6, &self.average_entry_price)?;
            }
            if self.updated_at != 0 {
                os.write_int64(7, self.updated_at)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> Position {
            Position::new()
        }
        fn clear(&mut self) {
            self.market_id.clear();
            self.party_id.clear();
            self.open_volume = 0;
            self.realised_pnl.clear();
            self.unrealised_pnl.clear();
            self.average_entry_price.clear();
            self.updated_at = 0;
            self.special_fields.clear();
        }
        fn default_instance() -> &'static Position {
            static instance: Position = Position {
                market_id: ::std::string::String::new(),
                party_id: ::std::string::String::new(),
                open_volume: 0,
                realised_pnl: ::std::string::String::new(),
                unrealised_pnl: ::std::string::String::new(),
                average_entry_price: ::std::string::String::new(),
                updated_at: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for Position {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("Position")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for Position {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for Position {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct PositionTrade {
        pub volume: i64,
        pub price: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PositionTrade {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PositionTrade {
        #[inline]
        fn eq(&self, other: &PositionTrade) -> bool {
            self.volume == other.volume && self.price == other.price
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PositionTrade {
        #[inline]
        fn clone(&self) -> PositionTrade {
            PositionTrade {
                volume: ::core::clone::Clone::clone(&self.volume),
                price: ::core::clone::Clone::clone(&self.price),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for PositionTrade {
        #[inline]
        fn default() -> PositionTrade {
            PositionTrade {
                volume: ::core::default::Default::default(),
                price: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PositionTrade {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "PositionTrade",
                "volume",
                &&self.volume,
                "price",
                &&self.price,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a PositionTrade {
        fn default() -> &'a PositionTrade {
            <PositionTrade as ::protobuf::Message>::default_instance()
        }
    }
    impl PositionTrade {
        pub fn new() -> PositionTrade {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "volume",
                        |m: &PositionTrade| { &m.volume },
                        |m: &mut PositionTrade| { &mut m.volume },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "price",
                        |m: &PositionTrade| { &m.price },
                        |m: &mut PositionTrade| { &mut m.price },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                PositionTrade,
            >("PositionTrade", fields, oneofs)
        }
    }
    impl ::protobuf::Message for PositionTrade {
        const NAME: &'static str = "PositionTrade";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.volume = is.read_int64()?;
                    }
                    18 => {
                        self.price = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.volume != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.volume);
            }
            if !self.price.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.price);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if self.volume != 0 {
                os.write_int64(1, self.volume)?;
            }
            if !self.price.is_empty() {
                os.write_string(2, &self.price)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> PositionTrade {
            PositionTrade::new()
        }
        fn clear(&mut self) {
            self.volume = 0;
            self.price.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static PositionTrade {
            static instance: PositionTrade = PositionTrade {
                volume: 0,
                price: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for PositionTrade {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("PositionTrade")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for PositionTrade {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for PositionTrade {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct Deposit {
        pub id: ::std::string::String,
        pub status: ::protobuf::EnumOrUnknown<deposit::Status>,
        pub party_id: ::std::string::String,
        pub asset: ::std::string::String,
        pub amount: ::std::string::String,
        pub tx_hash: ::std::string::String,
        pub credited_timestamp: i64,
        pub created_timestamp: i64,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Deposit {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Deposit {
        #[inline]
        fn eq(&self, other: &Deposit) -> bool {
            self.id == other.id && self.status == other.status
                && self.party_id == other.party_id && self.asset == other.asset
                && self.amount == other.amount && self.tx_hash == other.tx_hash
                && self.credited_timestamp == other.credited_timestamp
                && self.created_timestamp == other.created_timestamp
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Deposit {
        #[inline]
        fn clone(&self) -> Deposit {
            Deposit {
                id: ::core::clone::Clone::clone(&self.id),
                status: ::core::clone::Clone::clone(&self.status),
                party_id: ::core::clone::Clone::clone(&self.party_id),
                asset: ::core::clone::Clone::clone(&self.asset),
                amount: ::core::clone::Clone::clone(&self.amount),
                tx_hash: ::core::clone::Clone::clone(&self.tx_hash),
                credited_timestamp: ::core::clone::Clone::clone(
                    &self.credited_timestamp,
                ),
                created_timestamp: ::core::clone::Clone::clone(&self.created_timestamp),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Deposit {
        #[inline]
        fn default() -> Deposit {
            Deposit {
                id: ::core::default::Default::default(),
                status: ::core::default::Default::default(),
                party_id: ::core::default::Default::default(),
                asset: ::core::default::Default::default(),
                amount: ::core::default::Default::default(),
                tx_hash: ::core::default::Default::default(),
                credited_timestamp: ::core::default::Default::default(),
                created_timestamp: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Deposit {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "status",
                "party_id",
                "asset",
                "amount",
                "tx_hash",
                "credited_timestamp",
                "created_timestamp",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.id,
                &&self.status,
                &&self.party_id,
                &&self.asset,
                &&self.amount,
                &&self.tx_hash,
                &&self.credited_timestamp,
                &&self.created_timestamp,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "Deposit",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a Deposit {
        fn default() -> &'a Deposit {
            <Deposit as ::protobuf::Message>::default_instance()
        }
    }
    impl Deposit {
        pub fn new() -> Deposit {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >("id", |m: &Deposit| { &m.id }, |m: &mut Deposit| { &mut m.id }),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "status",
                        |m: &Deposit| { &m.status },
                        |m: &mut Deposit| { &mut m.status },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "party_id",
                        |m: &Deposit| { &m.party_id },
                        |m: &mut Deposit| { &mut m.party_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "asset",
                        |m: &Deposit| { &m.asset },
                        |m: &mut Deposit| { &mut m.asset },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "amount",
                        |m: &Deposit| { &m.amount },
                        |m: &mut Deposit| { &mut m.amount },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "tx_hash",
                        |m: &Deposit| { &m.tx_hash },
                        |m: &mut Deposit| { &mut m.tx_hash },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "credited_timestamp",
                        |m: &Deposit| { &m.credited_timestamp },
                        |m: &mut Deposit| { &mut m.credited_timestamp },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "created_timestamp",
                        |m: &Deposit| { &m.created_timestamp },
                        |m: &mut Deposit| { &mut m.created_timestamp },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                Deposit,
            >("Deposit", fields, oneofs)
        }
    }
    impl ::protobuf::Message for Deposit {
        const NAME: &'static str = "Deposit";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.id = is.read_string()?;
                    }
                    16 => {
                        self.status = is.read_enum_or_unknown()?;
                    }
                    26 => {
                        self.party_id = is.read_string()?;
                    }
                    34 => {
                        self.asset = is.read_string()?;
                    }
                    42 => {
                        self.amount = is.read_string()?;
                    }
                    50 => {
                        self.tx_hash = is.read_string()?;
                    }
                    56 => {
                        self.credited_timestamp = is.read_int64()?;
                    }
                    64 => {
                        self.created_timestamp = is.read_int64()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.id);
            }
            if self.status
                != ::protobuf::EnumOrUnknown::new(deposit::Status::STATUS_UNSPECIFIED)
            {
                my_size += ::protobuf::rt::int32_size(2, self.status.value());
            }
            if !self.party_id.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.party_id);
            }
            if !self.asset.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.asset);
            }
            if !self.amount.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.amount);
            }
            if !self.tx_hash.is_empty() {
                my_size += ::protobuf::rt::string_size(6, &self.tx_hash);
            }
            if self.credited_timestamp != 0 {
                my_size += ::protobuf::rt::int64_size(7, self.credited_timestamp);
            }
            if self.created_timestamp != 0 {
                my_size += ::protobuf::rt::int64_size(8, self.created_timestamp);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.id.is_empty() {
                os.write_string(1, &self.id)?;
            }
            if self.status
                != ::protobuf::EnumOrUnknown::new(deposit::Status::STATUS_UNSPECIFIED)
            {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.status))?;
            }
            if !self.party_id.is_empty() {
                os.write_string(3, &self.party_id)?;
            }
            if !self.asset.is_empty() {
                os.write_string(4, &self.asset)?;
            }
            if !self.amount.is_empty() {
                os.write_string(5, &self.amount)?;
            }
            if !self.tx_hash.is_empty() {
                os.write_string(6, &self.tx_hash)?;
            }
            if self.credited_timestamp != 0 {
                os.write_int64(7, self.credited_timestamp)?;
            }
            if self.created_timestamp != 0 {
                os.write_int64(8, self.created_timestamp)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> Deposit {
            Deposit::new()
        }
        fn clear(&mut self) {
            self.id.clear();
            self
                .status = ::protobuf::EnumOrUnknown::new(
                deposit::Status::STATUS_UNSPECIFIED,
            );
            self.party_id.clear();
            self.asset.clear();
            self.amount.clear();
            self.tx_hash.clear();
            self.credited_timestamp = 0;
            self.created_timestamp = 0;
            self.special_fields.clear();
        }
        fn default_instance() -> &'static Deposit {
            static instance: Deposit = Deposit {
                id: ::std::string::String::new(),
                status: ::protobuf::EnumOrUnknown::from_i32(0),
                party_id: ::std::string::String::new(),
                asset: ::std::string::String::new(),
                amount: ::std::string::String::new(),
                tx_hash: ::std::string::String::new(),
                credited_timestamp: 0,
                created_timestamp: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for Deposit {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("Deposit")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for Deposit {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for Deposit {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    /// Nested message and enums of message `Deposit`
    pub mod deposit {
        #[postgres(name = "transfer_type")]
        pub enum Status {
            STATUS_UNSPECIFIED = 0,
            STATUS_OPEN = 1,
            STATUS_CANCELLED = 2,
            STATUS_FINALIZED = 3,
        }
        impl<'a> postgres_types::FromSql<'a> for Status {
            fn from_sql(
                _type: &postgres_types::Type,
                buf: &'a [u8],
            ) -> std::result::Result<
                Status,
                std::boxed::Box<
                    dyn std::error::Error + std::marker::Sync + std::marker::Send,
                >,
            > {
                match std::str::from_utf8(buf)? {
                    "STATUS_UNSPECIFIED" => {
                        std::result::Result::Ok(Status::STATUS_UNSPECIFIED)
                    }
                    "STATUS_OPEN" => std::result::Result::Ok(Status::STATUS_OPEN),
                    "STATUS_CANCELLED" => {
                        std::result::Result::Ok(Status::STATUS_CANCELLED)
                    }
                    "STATUS_FINALIZED" => {
                        std::result::Result::Ok(Status::STATUS_FINALIZED)
                    }
                    s => {
                        std::result::Result::Err(
                            std::convert::Into::into({
                                let res = ::alloc::fmt::format(
                                    ::core::fmt::Arguments::new_v1(
                                        &["invalid variant `", "`"],
                                        &[::core::fmt::ArgumentV1::new_display(&s)],
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn accepts(type_: &postgres_types::Type) -> bool {
                if type_.name() != "transfer_type" {
                    return false;
                }
                match *type_.kind() {
                    ::postgres_types::Kind::Enum(ref variants) => {
                        if variants.len() != 4usize {
                            return false;
                        }
                        variants
                            .iter()
                            .all(|v| {
                                match &**v {
                                    "STATUS_UNSPECIFIED" => true,
                                    "STATUS_OPEN" => true,
                                    "STATUS_CANCELLED" => true,
                                    "STATUS_FINALIZED" => true,
                                    _ => false,
                                }
                            })
                    }
                    _ => false,
                }
            }
        }
        impl postgres_types::ToSql for Status {
            fn to_sql(
                &self,
                _type: &postgres_types::Type,
                buf: &mut postgres_types::private::BytesMut,
            ) -> std::result::Result<
                postgres_types::IsNull,
                std::boxed::Box<
                    dyn std::error::Error + std::marker::Sync + std::marker::Send,
                >,
            > {
                let s = match *self {
                    Status::STATUS_UNSPECIFIED => "STATUS_UNSPECIFIED",
                    Status::STATUS_OPEN => "STATUS_OPEN",
                    Status::STATUS_CANCELLED => "STATUS_CANCELLED",
                    Status::STATUS_FINALIZED => "STATUS_FINALIZED",
                };
                buf.extend_from_slice(s.as_bytes());
                std::result::Result::Ok(postgres_types::IsNull::No)
            }
            fn accepts(type_: &postgres_types::Type) -> bool {
                if type_.name() != "transfer_type" {
                    return false;
                }
                match *type_.kind() {
                    ::postgres_types::Kind::Enum(ref variants) => {
                        if variants.len() != 4usize {
                            return false;
                        }
                        variants
                            .iter()
                            .all(|v| {
                                match &**v {
                                    "STATUS_UNSPECIFIED" => true,
                                    "STATUS_OPEN" => true,
                                    "STATUS_CANCELLED" => true,
                                    "STATUS_FINALIZED" => true,
                                    _ => false,
                                }
                            })
                    }
                    _ => false,
                }
            }
            fn to_sql_checked(
                &self,
                ty: &::postgres_types::Type,
                out: &mut ::postgres_types::private::BytesMut,
            ) -> ::std::result::Result<
                ::postgres_types::IsNull,
                Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
            > {
                ::postgres_types::__to_sql_checked(self, ty, out)
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Status {
            #[inline]
            fn clone(&self) -> Status {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Status {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Status {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Status {
            #[inline]
            fn eq(&self, other: &Status) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Status {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Status {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Status {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Status::STATUS_UNSPECIFIED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_UNSPECIFIED")
                    }
                    Status::STATUS_OPEN => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_OPEN")
                    }
                    Status::STATUS_CANCELLED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_CANCELLED")
                    }
                    Status::STATUS_FINALIZED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_FINALIZED")
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Status {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state)
            }
        }
        impl ::protobuf::Enum for Status {
            const NAME: &'static str = "Status";
            fn value(&self) -> i32 {
                *self as i32
            }
            fn from_i32(value: i32) -> ::std::option::Option<Status> {
                match value {
                    0 => ::std::option::Option::Some(Status::STATUS_UNSPECIFIED),
                    1 => ::std::option::Option::Some(Status::STATUS_OPEN),
                    2 => ::std::option::Option::Some(Status::STATUS_CANCELLED),
                    3 => ::std::option::Option::Some(Status::STATUS_FINALIZED),
                    _ => ::std::option::Option::None,
                }
            }
            const VALUES: &'static [Status] = &[
                Status::STATUS_UNSPECIFIED,
                Status::STATUS_OPEN,
                Status::STATUS_CANCELLED,
                Status::STATUS_FINALIZED,
            ];
        }
        impl ::protobuf::EnumFull for Status {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<
                    ::protobuf::reflect::EnumDescriptor,
                > = ::protobuf::rt::Lazy::new();
                descriptor
                    .get(|| {
                        super::file_descriptor()
                            .enum_by_package_relative_name("Deposit.Status")
                            .unwrap()
                    })
                    .clone()
            }
            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }
        impl ::std::default::Default for Status {
            fn default() -> Self {
                Status::STATUS_UNSPECIFIED
            }
        }
        impl Status {
            pub(super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<
                    Status,
                >("Deposit.Status")
            }
        }
    }
    pub struct Withdrawal {
        pub id: ::std::string::String,
        pub party_id: ::std::string::String,
        pub amount: ::std::string::String,
        pub asset: ::std::string::String,
        pub status: ::protobuf::EnumOrUnknown<withdrawal::Status>,
        pub ref_: ::std::string::String,
        pub expiry: i64,
        pub tx_hash: ::std::string::String,
        pub created_timestamp: i64,
        pub withdrawn_timestamp: i64,
        pub ext: ::protobuf::MessageField<WithdrawExt>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Withdrawal {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Withdrawal {
        #[inline]
        fn eq(&self, other: &Withdrawal) -> bool {
            self.id == other.id && self.party_id == other.party_id
                && self.amount == other.amount && self.asset == other.asset
                && self.status == other.status && self.ref_ == other.ref_
                && self.expiry == other.expiry && self.tx_hash == other.tx_hash
                && self.created_timestamp == other.created_timestamp
                && self.withdrawn_timestamp == other.withdrawn_timestamp
                && self.ext == other.ext && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Withdrawal {
        #[inline]
        fn clone(&self) -> Withdrawal {
            Withdrawal {
                id: ::core::clone::Clone::clone(&self.id),
                party_id: ::core::clone::Clone::clone(&self.party_id),
                amount: ::core::clone::Clone::clone(&self.amount),
                asset: ::core::clone::Clone::clone(&self.asset),
                status: ::core::clone::Clone::clone(&self.status),
                ref_: ::core::clone::Clone::clone(&self.ref_),
                expiry: ::core::clone::Clone::clone(&self.expiry),
                tx_hash: ::core::clone::Clone::clone(&self.tx_hash),
                created_timestamp: ::core::clone::Clone::clone(&self.created_timestamp),
                withdrawn_timestamp: ::core::clone::Clone::clone(
                    &self.withdrawn_timestamp,
                ),
                ext: ::core::clone::Clone::clone(&self.ext),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Withdrawal {
        #[inline]
        fn default() -> Withdrawal {
            Withdrawal {
                id: ::core::default::Default::default(),
                party_id: ::core::default::Default::default(),
                amount: ::core::default::Default::default(),
                asset: ::core::default::Default::default(),
                status: ::core::default::Default::default(),
                ref_: ::core::default::Default::default(),
                expiry: ::core::default::Default::default(),
                tx_hash: ::core::default::Default::default(),
                created_timestamp: ::core::default::Default::default(),
                withdrawn_timestamp: ::core::default::Default::default(),
                ext: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Withdrawal {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "party_id",
                "amount",
                "asset",
                "status",
                "ref_",
                "expiry",
                "tx_hash",
                "created_timestamp",
                "withdrawn_timestamp",
                "ext",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.id,
                &&self.party_id,
                &&self.amount,
                &&self.asset,
                &&self.status,
                &&self.ref_,
                &&self.expiry,
                &&self.tx_hash,
                &&self.created_timestamp,
                &&self.withdrawn_timestamp,
                &&self.ext,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "Withdrawal",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a Withdrawal {
        fn default() -> &'a Withdrawal {
            <Withdrawal as ::protobuf::Message>::default_instance()
        }
    }
    impl Withdrawal {
        pub fn new() -> Withdrawal {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(11);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "id",
                        |m: &Withdrawal| { &m.id },
                        |m: &mut Withdrawal| { &mut m.id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "party_id",
                        |m: &Withdrawal| { &m.party_id },
                        |m: &mut Withdrawal| { &mut m.party_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "amount",
                        |m: &Withdrawal| { &m.amount },
                        |m: &mut Withdrawal| { &mut m.amount },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "asset",
                        |m: &Withdrawal| { &m.asset },
                        |m: &mut Withdrawal| { &mut m.asset },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "status",
                        |m: &Withdrawal| { &m.status },
                        |m: &mut Withdrawal| { &mut m.status },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "ref",
                        |m: &Withdrawal| { &m.ref_ },
                        |m: &mut Withdrawal| { &mut m.ref_ },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "expiry",
                        |m: &Withdrawal| { &m.expiry },
                        |m: &mut Withdrawal| { &mut m.expiry },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "tx_hash",
                        |m: &Withdrawal| { &m.tx_hash },
                        |m: &mut Withdrawal| { &mut m.tx_hash },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "created_timestamp",
                        |m: &Withdrawal| { &m.created_timestamp },
                        |m: &mut Withdrawal| { &mut m.created_timestamp },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "withdrawn_timestamp",
                        |m: &Withdrawal| { &m.withdrawn_timestamp },
                        |m: &mut Withdrawal| { &mut m.withdrawn_timestamp },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        WithdrawExt,
                    >(
                        "ext",
                        |m: &Withdrawal| { &m.ext },
                        |m: &mut Withdrawal| { &mut m.ext },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                Withdrawal,
            >("Withdrawal", fields, oneofs)
        }
    }
    impl ::protobuf::Message for Withdrawal {
        const NAME: &'static str = "Withdrawal";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.id = is.read_string()?;
                    }
                    18 => {
                        self.party_id = is.read_string()?;
                    }
                    26 => {
                        self.amount = is.read_string()?;
                    }
                    34 => {
                        self.asset = is.read_string()?;
                    }
                    40 => {
                        self.status = is.read_enum_or_unknown()?;
                    }
                    50 => {
                        self.ref_ = is.read_string()?;
                    }
                    56 => {
                        self.expiry = is.read_int64()?;
                    }
                    66 => {
                        self.tx_hash = is.read_string()?;
                    }
                    72 => {
                        self.created_timestamp = is.read_int64()?;
                    }
                    80 => {
                        self.withdrawn_timestamp = is.read_int64()?;
                    }
                    90 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.ext,
                        )?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.id);
            }
            if !self.party_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.party_id);
            }
            if !self.amount.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.amount);
            }
            if !self.asset.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.asset);
            }
            if self.status
                != ::protobuf::EnumOrUnknown::new(withdrawal::Status::STATUS_UNSPECIFIED)
            {
                my_size += ::protobuf::rt::int32_size(5, self.status.value());
            }
            if !self.ref_.is_empty() {
                my_size += ::protobuf::rt::string_size(6, &self.ref_);
            }
            if self.expiry != 0 {
                my_size += ::protobuf::rt::int64_size(7, self.expiry);
            }
            if !self.tx_hash.is_empty() {
                my_size += ::protobuf::rt::string_size(8, &self.tx_hash);
            }
            if self.created_timestamp != 0 {
                my_size += ::protobuf::rt::int64_size(9, self.created_timestamp);
            }
            if self.withdrawn_timestamp != 0 {
                my_size += ::protobuf::rt::int64_size(10, self.withdrawn_timestamp);
            }
            if let Some(v) = self.ext.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.id.is_empty() {
                os.write_string(1, &self.id)?;
            }
            if !self.party_id.is_empty() {
                os.write_string(2, &self.party_id)?;
            }
            if !self.amount.is_empty() {
                os.write_string(3, &self.amount)?;
            }
            if !self.asset.is_empty() {
                os.write_string(4, &self.asset)?;
            }
            if self.status
                != ::protobuf::EnumOrUnknown::new(withdrawal::Status::STATUS_UNSPECIFIED)
            {
                os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.status))?;
            }
            if !self.ref_.is_empty() {
                os.write_string(6, &self.ref_)?;
            }
            if self.expiry != 0 {
                os.write_int64(7, self.expiry)?;
            }
            if !self.tx_hash.is_empty() {
                os.write_string(8, &self.tx_hash)?;
            }
            if self.created_timestamp != 0 {
                os.write_int64(9, self.created_timestamp)?;
            }
            if self.withdrawn_timestamp != 0 {
                os.write_int64(10, self.withdrawn_timestamp)?;
            }
            if let Some(v) = self.ext.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> Withdrawal {
            Withdrawal::new()
        }
        fn clear(&mut self) {
            self.id.clear();
            self.party_id.clear();
            self.amount.clear();
            self.asset.clear();
            self
                .status = ::protobuf::EnumOrUnknown::new(
                withdrawal::Status::STATUS_UNSPECIFIED,
            );
            self.ref_.clear();
            self.expiry = 0;
            self.tx_hash.clear();
            self.created_timestamp = 0;
            self.withdrawn_timestamp = 0;
            self.ext.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static Withdrawal {
            static instance: Withdrawal = Withdrawal {
                id: ::std::string::String::new(),
                party_id: ::std::string::String::new(),
                amount: ::std::string::String::new(),
                asset: ::std::string::String::new(),
                status: ::protobuf::EnumOrUnknown::from_i32(0),
                ref_: ::std::string::String::new(),
                expiry: 0,
                tx_hash: ::std::string::String::new(),
                created_timestamp: 0,
                withdrawn_timestamp: 0,
                ext: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for Withdrawal {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("Withdrawal")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for Withdrawal {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for Withdrawal {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    /// Nested message and enums of message `Withdrawal`
    pub mod withdrawal {
        #[postgres(name = "transfer_type")]
        pub enum Status {
            STATUS_UNSPECIFIED = 0,
            STATUS_OPEN = 1,
            STATUS_REJECTED = 2,
            STATUS_FINALIZED = 3,
        }
        impl<'a> postgres_types::FromSql<'a> for Status {
            fn from_sql(
                _type: &postgres_types::Type,
                buf: &'a [u8],
            ) -> std::result::Result<
                Status,
                std::boxed::Box<
                    dyn std::error::Error + std::marker::Sync + std::marker::Send,
                >,
            > {
                match std::str::from_utf8(buf)? {
                    "STATUS_UNSPECIFIED" => {
                        std::result::Result::Ok(Status::STATUS_UNSPECIFIED)
                    }
                    "STATUS_OPEN" => std::result::Result::Ok(Status::STATUS_OPEN),
                    "STATUS_REJECTED" => std::result::Result::Ok(Status::STATUS_REJECTED),
                    "STATUS_FINALIZED" => {
                        std::result::Result::Ok(Status::STATUS_FINALIZED)
                    }
                    s => {
                        std::result::Result::Err(
                            std::convert::Into::into({
                                let res = ::alloc::fmt::format(
                                    ::core::fmt::Arguments::new_v1(
                                        &["invalid variant `", "`"],
                                        &[::core::fmt::ArgumentV1::new_display(&s)],
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn accepts(type_: &postgres_types::Type) -> bool {
                if type_.name() != "transfer_type" {
                    return false;
                }
                match *type_.kind() {
                    ::postgres_types::Kind::Enum(ref variants) => {
                        if variants.len() != 4usize {
                            return false;
                        }
                        variants
                            .iter()
                            .all(|v| {
                                match &**v {
                                    "STATUS_UNSPECIFIED" => true,
                                    "STATUS_OPEN" => true,
                                    "STATUS_REJECTED" => true,
                                    "STATUS_FINALIZED" => true,
                                    _ => false,
                                }
                            })
                    }
                    _ => false,
                }
            }
        }
        impl postgres_types::ToSql for Status {
            fn to_sql(
                &self,
                _type: &postgres_types::Type,
                buf: &mut postgres_types::private::BytesMut,
            ) -> std::result::Result<
                postgres_types::IsNull,
                std::boxed::Box<
                    dyn std::error::Error + std::marker::Sync + std::marker::Send,
                >,
            > {
                let s = match *self {
                    Status::STATUS_UNSPECIFIED => "STATUS_UNSPECIFIED",
                    Status::STATUS_OPEN => "STATUS_OPEN",
                    Status::STATUS_REJECTED => "STATUS_REJECTED",
                    Status::STATUS_FINALIZED => "STATUS_FINALIZED",
                };
                buf.extend_from_slice(s.as_bytes());
                std::result::Result::Ok(postgres_types::IsNull::No)
            }
            fn accepts(type_: &postgres_types::Type) -> bool {
                if type_.name() != "transfer_type" {
                    return false;
                }
                match *type_.kind() {
                    ::postgres_types::Kind::Enum(ref variants) => {
                        if variants.len() != 4usize {
                            return false;
                        }
                        variants
                            .iter()
                            .all(|v| {
                                match &**v {
                                    "STATUS_UNSPECIFIED" => true,
                                    "STATUS_OPEN" => true,
                                    "STATUS_REJECTED" => true,
                                    "STATUS_FINALIZED" => true,
                                    _ => false,
                                }
                            })
                    }
                    _ => false,
                }
            }
            fn to_sql_checked(
                &self,
                ty: &::postgres_types::Type,
                out: &mut ::postgres_types::private::BytesMut,
            ) -> ::std::result::Result<
                ::postgres_types::IsNull,
                Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
            > {
                ::postgres_types::__to_sql_checked(self, ty, out)
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Status {
            #[inline]
            fn clone(&self) -> Status {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Status {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Status {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Status {
            #[inline]
            fn eq(&self, other: &Status) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Status {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Status {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Status {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Status::STATUS_UNSPECIFIED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_UNSPECIFIED")
                    }
                    Status::STATUS_OPEN => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_OPEN")
                    }
                    Status::STATUS_REJECTED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_REJECTED")
                    }
                    Status::STATUS_FINALIZED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_FINALIZED")
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Status {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state)
            }
        }
        impl ::protobuf::Enum for Status {
            const NAME: &'static str = "Status";
            fn value(&self) -> i32 {
                *self as i32
            }
            fn from_i32(value: i32) -> ::std::option::Option<Status> {
                match value {
                    0 => ::std::option::Option::Some(Status::STATUS_UNSPECIFIED),
                    1 => ::std::option::Option::Some(Status::STATUS_OPEN),
                    2 => ::std::option::Option::Some(Status::STATUS_REJECTED),
                    3 => ::std::option::Option::Some(Status::STATUS_FINALIZED),
                    _ => ::std::option::Option::None,
                }
            }
            const VALUES: &'static [Status] = &[
                Status::STATUS_UNSPECIFIED,
                Status::STATUS_OPEN,
                Status::STATUS_REJECTED,
                Status::STATUS_FINALIZED,
            ];
        }
        impl ::protobuf::EnumFull for Status {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<
                    ::protobuf::reflect::EnumDescriptor,
                > = ::protobuf::rt::Lazy::new();
                descriptor
                    .get(|| {
                        super::file_descriptor()
                            .enum_by_package_relative_name("Withdrawal.Status")
                            .unwrap()
                    })
                    .clone()
            }
            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }
        impl ::std::default::Default for Status {
            fn default() -> Self {
                Status::STATUS_UNSPECIFIED
            }
        }
        impl Status {
            pub(super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<
                    Status,
                >("Withdrawal.Status")
            }
        }
    }
    pub struct WithdrawExt {
        pub ext: ::std::option::Option<withdraw_ext::Ext>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for WithdrawExt {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for WithdrawExt {
        #[inline]
        fn eq(&self, other: &WithdrawExt) -> bool {
            self.ext == other.ext && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for WithdrawExt {
        #[inline]
        fn clone(&self) -> WithdrawExt {
            WithdrawExt {
                ext: ::core::clone::Clone::clone(&self.ext),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for WithdrawExt {
        #[inline]
        fn default() -> WithdrawExt {
            WithdrawExt {
                ext: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for WithdrawExt {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "WithdrawExt",
                "ext",
                &&self.ext,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a WithdrawExt {
        fn default() -> &'a WithdrawExt {
            <WithdrawExt as ::protobuf::Message>::default_instance()
        }
    }
    impl WithdrawExt {
        pub fn new() -> WithdrawExt {
            ::std::default::Default::default()
        }
        pub fn erc20(&self) -> &Erc20WithdrawExt {
            match self.ext {
                ::std::option::Option::Some(withdraw_ext::Ext::Erc20(ref v)) => v,
                _ => <Erc20WithdrawExt as ::protobuf::Message>::default_instance(),
            }
        }
        pub fn clear_erc20(&mut self) {
            self.ext = ::std::option::Option::None;
        }
        pub fn has_erc20(&self) -> bool {
            match self.ext {
                ::std::option::Option::Some(withdraw_ext::Ext::Erc20(..)) => true,
                _ => false,
            }
        }
        pub fn set_erc20(&mut self, v: Erc20WithdrawExt) {
            self.ext = ::std::option::Option::Some(withdraw_ext::Ext::Erc20(v));
        }
        pub fn mut_erc20(&mut self) -> &mut Erc20WithdrawExt {
            if let ::std::option::Option::Some(withdraw_ext::Ext::Erc20(_)) = self.ext
            {} else {
                self
                    .ext = ::std::option::Option::Some(
                    withdraw_ext::Ext::Erc20(Erc20WithdrawExt::new()),
                );
            }
            match self.ext {
                ::std::option::Option::Some(withdraw_ext::Ext::Erc20(ref mut v)) => v,
                _ => ::core::panicking::panic("explicit panic"),
            }
        }
        pub fn take_erc20(&mut self) -> Erc20WithdrawExt {
            if self.has_erc20() {
                match self.ext.take() {
                    ::std::option::Option::Some(withdraw_ext::Ext::Erc20(v)) => v,
                    _ => ::core::panicking::panic("explicit panic"),
                }
            } else {
                Erc20WithdrawExt::new()
            }
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<
                        _,
                        Erc20WithdrawExt,
                    >(
                        "erc20",
                        WithdrawExt::has_erc20,
                        WithdrawExt::erc20,
                        WithdrawExt::mut_erc20,
                        WithdrawExt::set_erc20,
                    ),
                );
            oneofs.push(withdraw_ext::Ext::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                WithdrawExt,
            >("WithdrawExt", fields, oneofs)
        }
    }
    impl ::protobuf::Message for WithdrawExt {
        const NAME: &'static str = "WithdrawExt";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self
                            .ext = ::std::option::Option::Some(
                            withdraw_ext::Ext::Erc20(is.read_message()?),
                        );
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.ext {
                match v {
                    &withdraw_ext::Ext::Erc20(ref v) => {
                        let len = v.compute_size();
                        my_size
                            += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    }
                };
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.ext {
                match v {
                    &withdraw_ext::Ext::Erc20(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    }
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> WithdrawExt {
            WithdrawExt::new()
        }
        fn clear(&mut self) {
            self.ext = ::std::option::Option::None;
            self.special_fields.clear();
        }
        fn default_instance() -> &'static WithdrawExt {
            static instance: WithdrawExt = WithdrawExt {
                ext: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for WithdrawExt {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("WithdrawExt")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for WithdrawExt {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for WithdrawExt {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    /// Nested message and enums of message `WithdrawExt`
    pub mod withdraw_ext {
        #[non_exhaustive]
        pub enum Ext {
            Erc20(super::Erc20WithdrawExt),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Ext {
            #[inline]
            fn clone(&self) -> Ext {
                match self {
                    Ext::Erc20(__self_0) => {
                        Ext::Erc20(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Ext {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Ext {
            #[inline]
            fn eq(&self, other: &Ext) -> bool {
                match (self, other) {
                    (Ext::Erc20(__self_0), Ext::Erc20(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Ext {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Ext::Erc20(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Erc20",
                            &__self_0,
                        )
                    }
                }
            }
        }
        impl ::protobuf::Oneof for Ext {}
        impl ::protobuf::OneofFull for Ext {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<
                    ::protobuf::reflect::OneofDescriptor,
                > = ::protobuf::rt::Lazy::new();
                descriptor
                    .get(|| {
                        <super::WithdrawExt as ::protobuf::MessageFull>::descriptor()
                            .oneof_by_name("ext")
                            .unwrap()
                    })
                    .clone()
            }
        }
        impl Ext {
            pub(super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Ext>("ext")
            }
        }
    }
    pub struct Erc20WithdrawExt {
        pub receiver_address: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Erc20WithdrawExt {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Erc20WithdrawExt {
        #[inline]
        fn eq(&self, other: &Erc20WithdrawExt) -> bool {
            self.receiver_address == other.receiver_address
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Erc20WithdrawExt {
        #[inline]
        fn clone(&self) -> Erc20WithdrawExt {
            Erc20WithdrawExt {
                receiver_address: ::core::clone::Clone::clone(&self.receiver_address),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Erc20WithdrawExt {
        #[inline]
        fn default() -> Erc20WithdrawExt {
            Erc20WithdrawExt {
                receiver_address: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Erc20WithdrawExt {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Erc20WithdrawExt",
                "receiver_address",
                &&self.receiver_address,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a Erc20WithdrawExt {
        fn default() -> &'a Erc20WithdrawExt {
            <Erc20WithdrawExt as ::protobuf::Message>::default_instance()
        }
    }
    impl Erc20WithdrawExt {
        pub fn new() -> Erc20WithdrawExt {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "receiver_address",
                        |m: &Erc20WithdrawExt| { &m.receiver_address },
                        |m: &mut Erc20WithdrawExt| { &mut m.receiver_address },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                Erc20WithdrawExt,
            >("Erc20WithdrawExt", fields, oneofs)
        }
    }
    impl ::protobuf::Message for Erc20WithdrawExt {
        const NAME: &'static str = "Erc20WithdrawExt";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.receiver_address = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.receiver_address.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.receiver_address);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.receiver_address.is_empty() {
                os.write_string(1, &self.receiver_address)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> Erc20WithdrawExt {
            Erc20WithdrawExt::new()
        }
        fn clear(&mut self) {
            self.receiver_address.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static Erc20WithdrawExt {
            static instance: Erc20WithdrawExt = Erc20WithdrawExt {
                receiver_address: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for Erc20WithdrawExt {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("Erc20WithdrawExt")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for Erc20WithdrawExt {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for Erc20WithdrawExt {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct Account {
        pub id: ::std::string::String,
        pub owner: ::std::string::String,
        pub balance: ::std::string::String,
        pub asset: ::std::string::String,
        pub market_id: ::std::string::String,
        pub type_: ::protobuf::EnumOrUnknown<AccountType>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Account {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Account {
        #[inline]
        fn eq(&self, other: &Account) -> bool {
            self.id == other.id && self.owner == other.owner
                && self.balance == other.balance && self.asset == other.asset
                && self.market_id == other.market_id && self.type_ == other.type_
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Account {
        #[inline]
        fn clone(&self) -> Account {
            Account {
                id: ::core::clone::Clone::clone(&self.id),
                owner: ::core::clone::Clone::clone(&self.owner),
                balance: ::core::clone::Clone::clone(&self.balance),
                asset: ::core::clone::Clone::clone(&self.asset),
                market_id: ::core::clone::Clone::clone(&self.market_id),
                type_: ::core::clone::Clone::clone(&self.type_),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Account {
        #[inline]
        fn default() -> Account {
            Account {
                id: ::core::default::Default::default(),
                owner: ::core::default::Default::default(),
                balance: ::core::default::Default::default(),
                asset: ::core::default::Default::default(),
                market_id: ::core::default::Default::default(),
                type_: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Account {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "owner",
                "balance",
                "asset",
                "market_id",
                "type_",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.id,
                &&self.owner,
                &&self.balance,
                &&self.asset,
                &&self.market_id,
                &&self.type_,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "Account",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a Account {
        fn default() -> &'a Account {
            <Account as ::protobuf::Message>::default_instance()
        }
    }
    impl Account {
        pub fn new() -> Account {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >("id", |m: &Account| { &m.id }, |m: &mut Account| { &mut m.id }),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "owner",
                        |m: &Account| { &m.owner },
                        |m: &mut Account| { &mut m.owner },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "balance",
                        |m: &Account| { &m.balance },
                        |m: &mut Account| { &mut m.balance },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "asset",
                        |m: &Account| { &m.asset },
                        |m: &mut Account| { &mut m.asset },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "market_id",
                        |m: &Account| { &m.market_id },
                        |m: &mut Account| { &mut m.market_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "type",
                        |m: &Account| { &m.type_ },
                        |m: &mut Account| { &mut m.type_ },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                Account,
            >("Account", fields, oneofs)
        }
    }
    impl ::protobuf::Message for Account {
        const NAME: &'static str = "Account";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.id = is.read_string()?;
                    }
                    18 => {
                        self.owner = is.read_string()?;
                    }
                    26 => {
                        self.balance = is.read_string()?;
                    }
                    34 => {
                        self.asset = is.read_string()?;
                    }
                    42 => {
                        self.market_id = is.read_string()?;
                    }
                    48 => {
                        self.type_ = is.read_enum_or_unknown()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.id);
            }
            if !self.owner.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.owner);
            }
            if !self.balance.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.balance);
            }
            if !self.asset.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.asset);
            }
            if !self.market_id.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.market_id);
            }
            if self.type_
                != ::protobuf::EnumOrUnknown::new(AccountType::ACCOUNT_TYPE_UNSPECIFIED)
            {
                my_size += ::protobuf::rt::int32_size(6, self.type_.value());
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.id.is_empty() {
                os.write_string(1, &self.id)?;
            }
            if !self.owner.is_empty() {
                os.write_string(2, &self.owner)?;
            }
            if !self.balance.is_empty() {
                os.write_string(3, &self.balance)?;
            }
            if !self.asset.is_empty() {
                os.write_string(4, &self.asset)?;
            }
            if !self.market_id.is_empty() {
                os.write_string(5, &self.market_id)?;
            }
            if self.type_
                != ::protobuf::EnumOrUnknown::new(AccountType::ACCOUNT_TYPE_UNSPECIFIED)
            {
                os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.type_))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> Account {
            Account::new()
        }
        fn clear(&mut self) {
            self.id.clear();
            self.owner.clear();
            self.balance.clear();
            self.asset.clear();
            self.market_id.clear();
            self
                .type_ = ::protobuf::EnumOrUnknown::new(
                AccountType::ACCOUNT_TYPE_UNSPECIFIED,
            );
            self.special_fields.clear();
        }
        fn default_instance() -> &'static Account {
            static instance: Account = Account {
                id: ::std::string::String::new(),
                owner: ::std::string::String::new(),
                balance: ::std::string::String::new(),
                asset: ::std::string::String::new(),
                market_id: ::std::string::String::new(),
                type_: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for Account {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("Account")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for Account {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for Account {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct FinancialAmount {
        pub amount: ::std::string::String,
        pub asset: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FinancialAmount {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FinancialAmount {
        #[inline]
        fn eq(&self, other: &FinancialAmount) -> bool {
            self.amount == other.amount && self.asset == other.asset
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FinancialAmount {
        #[inline]
        fn clone(&self) -> FinancialAmount {
            FinancialAmount {
                amount: ::core::clone::Clone::clone(&self.amount),
                asset: ::core::clone::Clone::clone(&self.asset),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for FinancialAmount {
        #[inline]
        fn default() -> FinancialAmount {
            FinancialAmount {
                amount: ::core::default::Default::default(),
                asset: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FinancialAmount {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "FinancialAmount",
                "amount",
                &&self.amount,
                "asset",
                &&self.asset,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a FinancialAmount {
        fn default() -> &'a FinancialAmount {
            <FinancialAmount as ::protobuf::Message>::default_instance()
        }
    }
    impl FinancialAmount {
        pub fn new() -> FinancialAmount {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "amount",
                        |m: &FinancialAmount| { &m.amount },
                        |m: &mut FinancialAmount| { &mut m.amount },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "asset",
                        |m: &FinancialAmount| { &m.asset },
                        |m: &mut FinancialAmount| { &mut m.asset },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                FinancialAmount,
            >("FinancialAmount", fields, oneofs)
        }
    }
    impl ::protobuf::Message for FinancialAmount {
        const NAME: &'static str = "FinancialAmount";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.amount = is.read_string()?;
                    }
                    18 => {
                        self.asset = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.amount.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.amount);
            }
            if !self.asset.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.asset);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.amount.is_empty() {
                os.write_string(1, &self.amount)?;
            }
            if !self.asset.is_empty() {
                os.write_string(2, &self.asset)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> FinancialAmount {
            FinancialAmount::new()
        }
        fn clear(&mut self) {
            self.amount.clear();
            self.asset.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static FinancialAmount {
            static instance: FinancialAmount = FinancialAmount {
                amount: ::std::string::String::new(),
                asset: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for FinancialAmount {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("FinancialAmount")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for FinancialAmount {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for FinancialAmount {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct Transfer {
        pub owner: ::std::string::String,
        pub amount: ::protobuf::MessageField<FinancialAmount>,
        pub type_: ::protobuf::EnumOrUnknown<TransferType>,
        pub min_amount: ::std::string::String,
        pub market_id: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Transfer {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Transfer {
        #[inline]
        fn eq(&self, other: &Transfer) -> bool {
            self.owner == other.owner && self.amount == other.amount
                && self.type_ == other.type_ && self.min_amount == other.min_amount
                && self.market_id == other.market_id
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Transfer {
        #[inline]
        fn clone(&self) -> Transfer {
            Transfer {
                owner: ::core::clone::Clone::clone(&self.owner),
                amount: ::core::clone::Clone::clone(&self.amount),
                type_: ::core::clone::Clone::clone(&self.type_),
                min_amount: ::core::clone::Clone::clone(&self.min_amount),
                market_id: ::core::clone::Clone::clone(&self.market_id),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Transfer {
        #[inline]
        fn default() -> Transfer {
            Transfer {
                owner: ::core::default::Default::default(),
                amount: ::core::default::Default::default(),
                type_: ::core::default::Default::default(),
                min_amount: ::core::default::Default::default(),
                market_id: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Transfer {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "owner",
                "amount",
                "type_",
                "min_amount",
                "market_id",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.owner,
                &&self.amount,
                &&self.type_,
                &&self.min_amount,
                &&self.market_id,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "Transfer",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a Transfer {
        fn default() -> &'a Transfer {
            <Transfer as ::protobuf::Message>::default_instance()
        }
    }
    impl Transfer {
        pub fn new() -> Transfer {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "owner",
                        |m: &Transfer| { &m.owner },
                        |m: &mut Transfer| { &mut m.owner },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        FinancialAmount,
                    >(
                        "amount",
                        |m: &Transfer| { &m.amount },
                        |m: &mut Transfer| { &mut m.amount },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "type",
                        |m: &Transfer| { &m.type_ },
                        |m: &mut Transfer| { &mut m.type_ },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "min_amount",
                        |m: &Transfer| { &m.min_amount },
                        |m: &mut Transfer| { &mut m.min_amount },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "market_id",
                        |m: &Transfer| { &m.market_id },
                        |m: &mut Transfer| { &mut m.market_id },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                Transfer,
            >("Transfer", fields, oneofs)
        }
    }
    impl ::protobuf::Message for Transfer {
        const NAME: &'static str = "Transfer";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.owner = is.read_string()?;
                    }
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.amount,
                        )?;
                    }
                    24 => {
                        self.type_ = is.read_enum_or_unknown()?;
                    }
                    34 => {
                        self.min_amount = is.read_string()?;
                    }
                    42 => {
                        self.market_id = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.owner.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.owner);
            }
            if let Some(v) = self.amount.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.type_
                != ::protobuf::EnumOrUnknown::new(
                    TransferType::TRANSFER_TYPE_UNSPECIFIED,
                )
            {
                my_size += ::protobuf::rt::int32_size(3, self.type_.value());
            }
            if !self.min_amount.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.min_amount);
            }
            if !self.market_id.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.market_id);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.owner.is_empty() {
                os.write_string(1, &self.owner)?;
            }
            if let Some(v) = self.amount.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if self.type_
                != ::protobuf::EnumOrUnknown::new(
                    TransferType::TRANSFER_TYPE_UNSPECIFIED,
                )
            {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.type_))?;
            }
            if !self.min_amount.is_empty() {
                os.write_string(4, &self.min_amount)?;
            }
            if !self.market_id.is_empty() {
                os.write_string(5, &self.market_id)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> Transfer {
            Transfer::new()
        }
        fn clear(&mut self) {
            self.owner.clear();
            self.amount.clear();
            self
                .type_ = ::protobuf::EnumOrUnknown::new(
                TransferType::TRANSFER_TYPE_UNSPECIFIED,
            );
            self.min_amount.clear();
            self.market_id.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static Transfer {
            static instance: Transfer = Transfer {
                owner: ::std::string::String::new(),
                amount: ::protobuf::MessageField::none(),
                type_: ::protobuf::EnumOrUnknown::from_i32(0),
                min_amount: ::std::string::String::new(),
                market_id: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for Transfer {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("Transfer")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for Transfer {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for Transfer {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct DispatchStrategy {
        pub asset_for_metric: ::std::string::String,
        pub metric: ::protobuf::EnumOrUnknown<DispatchMetric>,
        pub markets: ::std::vec::Vec<::std::string::String>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DispatchStrategy {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DispatchStrategy {
        #[inline]
        fn eq(&self, other: &DispatchStrategy) -> bool {
            self.asset_for_metric == other.asset_for_metric
                && self.metric == other.metric && self.markets == other.markets
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DispatchStrategy {
        #[inline]
        fn clone(&self) -> DispatchStrategy {
            DispatchStrategy {
                asset_for_metric: ::core::clone::Clone::clone(&self.asset_for_metric),
                metric: ::core::clone::Clone::clone(&self.metric),
                markets: ::core::clone::Clone::clone(&self.markets),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for DispatchStrategy {
        #[inline]
        fn default() -> DispatchStrategy {
            DispatchStrategy {
                asset_for_metric: ::core::default::Default::default(),
                metric: ::core::default::Default::default(),
                markets: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DispatchStrategy {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "DispatchStrategy",
                "asset_for_metric",
                &&self.asset_for_metric,
                "metric",
                &&self.metric,
                "markets",
                &&self.markets,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a DispatchStrategy {
        fn default() -> &'a DispatchStrategy {
            <DispatchStrategy as ::protobuf::Message>::default_instance()
        }
    }
    impl DispatchStrategy {
        pub fn new() -> DispatchStrategy {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "asset_for_metric",
                        |m: &DispatchStrategy| { &m.asset_for_metric },
                        |m: &mut DispatchStrategy| { &mut m.asset_for_metric },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "metric",
                        |m: &DispatchStrategy| { &m.metric },
                        |m: &mut DispatchStrategy| { &mut m.metric },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "markets",
                        |m: &DispatchStrategy| { &m.markets },
                        |m: &mut DispatchStrategy| { &mut m.markets },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                DispatchStrategy,
            >("DispatchStrategy", fields, oneofs)
        }
    }
    impl ::protobuf::Message for DispatchStrategy {
        const NAME: &'static str = "DispatchStrategy";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.asset_for_metric = is.read_string()?;
                    }
                    16 => {
                        self.metric = is.read_enum_or_unknown()?;
                    }
                    26 => {
                        self.markets.push(is.read_string()?);
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.asset_for_metric.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.asset_for_metric);
            }
            if self.metric
                != ::protobuf::EnumOrUnknown::new(
                    DispatchMetric::DISPATCH_METRIC_UNSPECIFIED,
                )
            {
                my_size += ::protobuf::rt::int32_size(2, self.metric.value());
            }
            for value in &self.markets {
                my_size += ::protobuf::rt::string_size(3, &value);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.asset_for_metric.is_empty() {
                os.write_string(1, &self.asset_for_metric)?;
            }
            if self.metric
                != ::protobuf::EnumOrUnknown::new(
                    DispatchMetric::DISPATCH_METRIC_UNSPECIFIED,
                )
            {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.metric))?;
            }
            for v in &self.markets {
                os.write_string(3, &v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> DispatchStrategy {
            DispatchStrategy::new()
        }
        fn clear(&mut self) {
            self.asset_for_metric.clear();
            self
                .metric = ::protobuf::EnumOrUnknown::new(
                DispatchMetric::DISPATCH_METRIC_UNSPECIFIED,
            );
            self.markets.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static DispatchStrategy {
            static instance: DispatchStrategy = DispatchStrategy {
                asset_for_metric: ::std::string::String::new(),
                metric: ::protobuf::EnumOrUnknown::from_i32(0),
                markets: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for DispatchStrategy {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("DispatchStrategy")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for DispatchStrategy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for DispatchStrategy {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct TransferRequest {
        pub from_account: ::std::vec::Vec<Account>,
        pub to_account: ::std::vec::Vec<Account>,
        pub amount: ::std::string::String,
        pub min_amount: ::std::string::String,
        pub asset: ::std::string::String,
        pub type_: ::protobuf::EnumOrUnknown<TransferType>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TransferRequest {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TransferRequest {
        #[inline]
        fn eq(&self, other: &TransferRequest) -> bool {
            self.from_account == other.from_account
                && self.to_account == other.to_account && self.amount == other.amount
                && self.min_amount == other.min_amount && self.asset == other.asset
                && self.type_ == other.type_
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TransferRequest {
        #[inline]
        fn clone(&self) -> TransferRequest {
            TransferRequest {
                from_account: ::core::clone::Clone::clone(&self.from_account),
                to_account: ::core::clone::Clone::clone(&self.to_account),
                amount: ::core::clone::Clone::clone(&self.amount),
                min_amount: ::core::clone::Clone::clone(&self.min_amount),
                asset: ::core::clone::Clone::clone(&self.asset),
                type_: ::core::clone::Clone::clone(&self.type_),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for TransferRequest {
        #[inline]
        fn default() -> TransferRequest {
            TransferRequest {
                from_account: ::core::default::Default::default(),
                to_account: ::core::default::Default::default(),
                amount: ::core::default::Default::default(),
                min_amount: ::core::default::Default::default(),
                asset: ::core::default::Default::default(),
                type_: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TransferRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "from_account",
                "to_account",
                "amount",
                "min_amount",
                "asset",
                "type_",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.from_account,
                &&self.to_account,
                &&self.amount,
                &&self.min_amount,
                &&self.asset,
                &&self.type_,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "TransferRequest",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a TransferRequest {
        fn default() -> &'a TransferRequest {
            <TransferRequest as ::protobuf::Message>::default_instance()
        }
    }
    impl TransferRequest {
        pub fn new() -> TransferRequest {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "from_account",
                        |m: &TransferRequest| { &m.from_account },
                        |m: &mut TransferRequest| { &mut m.from_account },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "to_account",
                        |m: &TransferRequest| { &m.to_account },
                        |m: &mut TransferRequest| { &mut m.to_account },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "amount",
                        |m: &TransferRequest| { &m.amount },
                        |m: &mut TransferRequest| { &mut m.amount },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "min_amount",
                        |m: &TransferRequest| { &m.min_amount },
                        |m: &mut TransferRequest| { &mut m.min_amount },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "asset",
                        |m: &TransferRequest| { &m.asset },
                        |m: &mut TransferRequest| { &mut m.asset },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "type",
                        |m: &TransferRequest| { &m.type_ },
                        |m: &mut TransferRequest| { &mut m.type_ },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                TransferRequest,
            >("TransferRequest", fields, oneofs)
        }
    }
    impl ::protobuf::Message for TransferRequest {
        const NAME: &'static str = "TransferRequest";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.from_account.push(is.read_message()?);
                    }
                    18 => {
                        self.to_account.push(is.read_message()?);
                    }
                    26 => {
                        self.amount = is.read_string()?;
                    }
                    34 => {
                        self.min_amount = is.read_string()?;
                    }
                    42 => {
                        self.asset = is.read_string()?;
                    }
                    56 => {
                        self.type_ = is.read_enum_or_unknown()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.from_account {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.to_account {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.amount.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.amount);
            }
            if !self.min_amount.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.min_amount);
            }
            if !self.asset.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.asset);
            }
            if self.type_
                != ::protobuf::EnumOrUnknown::new(
                    TransferType::TRANSFER_TYPE_UNSPECIFIED,
                )
            {
                my_size += ::protobuf::rt::int32_size(7, self.type_.value());
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            for v in &self.from_account {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            for v in &self.to_account {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if !self.amount.is_empty() {
                os.write_string(3, &self.amount)?;
            }
            if !self.min_amount.is_empty() {
                os.write_string(4, &self.min_amount)?;
            }
            if !self.asset.is_empty() {
                os.write_string(5, &self.asset)?;
            }
            if self.type_
                != ::protobuf::EnumOrUnknown::new(
                    TransferType::TRANSFER_TYPE_UNSPECIFIED,
                )
            {
                os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.type_))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> TransferRequest {
            TransferRequest::new()
        }
        fn clear(&mut self) {
            self.from_account.clear();
            self.to_account.clear();
            self.amount.clear();
            self.min_amount.clear();
            self.asset.clear();
            self
                .type_ = ::protobuf::EnumOrUnknown::new(
                TransferType::TRANSFER_TYPE_UNSPECIFIED,
            );
            self.special_fields.clear();
        }
        fn default_instance() -> &'static TransferRequest {
            static instance: TransferRequest = TransferRequest {
                from_account: ::std::vec::Vec::new(),
                to_account: ::std::vec::Vec::new(),
                amount: ::std::string::String::new(),
                min_amount: ::std::string::String::new(),
                asset: ::std::string::String::new(),
                type_: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for TransferRequest {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("TransferRequest")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for TransferRequest {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for TransferRequest {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct AccountDetails {
        pub asset_id: ::std::string::String,
        pub type_: ::protobuf::EnumOrUnknown<AccountType>,
        pub owner: ::std::option::Option<::std::string::String>,
        pub market_id: ::std::option::Option<::std::string::String>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AccountDetails {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AccountDetails {
        #[inline]
        fn eq(&self, other: &AccountDetails) -> bool {
            self.asset_id == other.asset_id && self.type_ == other.type_
                && self.owner == other.owner && self.market_id == other.market_id
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AccountDetails {
        #[inline]
        fn clone(&self) -> AccountDetails {
            AccountDetails {
                asset_id: ::core::clone::Clone::clone(&self.asset_id),
                type_: ::core::clone::Clone::clone(&self.type_),
                owner: ::core::clone::Clone::clone(&self.owner),
                market_id: ::core::clone::Clone::clone(&self.market_id),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for AccountDetails {
        #[inline]
        fn default() -> AccountDetails {
            AccountDetails {
                asset_id: ::core::default::Default::default(),
                type_: ::core::default::Default::default(),
                owner: ::core::default::Default::default(),
                market_id: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AccountDetails {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "AccountDetails",
                "asset_id",
                &&self.asset_id,
                "type_",
                &&self.type_,
                "owner",
                &&self.owner,
                "market_id",
                &&self.market_id,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a AccountDetails {
        fn default() -> &'a AccountDetails {
            <AccountDetails as ::protobuf::Message>::default_instance()
        }
    }
    impl AccountDetails {
        pub fn new() -> AccountDetails {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "asset_id",
                        |m: &AccountDetails| { &m.asset_id },
                        |m: &mut AccountDetails| { &mut m.asset_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "type",
                        |m: &AccountDetails| { &m.type_ },
                        |m: &mut AccountDetails| { &mut m.type_ },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_option_accessor::<
                        _,
                        _,
                    >(
                        "owner",
                        |m: &AccountDetails| { &m.owner },
                        |m: &mut AccountDetails| { &mut m.owner },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_option_accessor::<
                        _,
                        _,
                    >(
                        "market_id",
                        |m: &AccountDetails| { &m.market_id },
                        |m: &mut AccountDetails| { &mut m.market_id },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                AccountDetails,
            >("AccountDetails", fields, oneofs)
        }
    }
    impl ::protobuf::Message for AccountDetails {
        const NAME: &'static str = "AccountDetails";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.asset_id = is.read_string()?;
                    }
                    16 => {
                        self.type_ = is.read_enum_or_unknown()?;
                    }
                    26 => {
                        self.owner = ::std::option::Option::Some(is.read_string()?);
                    }
                    34 => {
                        self.market_id = ::std::option::Option::Some(is.read_string()?);
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.asset_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.asset_id);
            }
            if self.type_
                != ::protobuf::EnumOrUnknown::new(AccountType::ACCOUNT_TYPE_UNSPECIFIED)
            {
                my_size += ::protobuf::rt::int32_size(2, self.type_.value());
            }
            if let Some(v) = self.owner.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.market_id.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.asset_id.is_empty() {
                os.write_string(1, &self.asset_id)?;
            }
            if self.type_
                != ::protobuf::EnumOrUnknown::new(AccountType::ACCOUNT_TYPE_UNSPECIFIED)
            {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.type_))?;
            }
            if let Some(v) = self.owner.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.market_id.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> AccountDetails {
            AccountDetails::new()
        }
        fn clear(&mut self) {
            self.asset_id.clear();
            self
                .type_ = ::protobuf::EnumOrUnknown::new(
                AccountType::ACCOUNT_TYPE_UNSPECIFIED,
            );
            self.owner = ::std::option::Option::None;
            self.market_id = ::std::option::Option::None;
            self.special_fields.clear();
        }
        fn default_instance() -> &'static AccountDetails {
            static instance: AccountDetails = AccountDetails {
                asset_id: ::std::string::String::new(),
                type_: ::protobuf::EnumOrUnknown::from_i32(0),
                owner: ::std::option::Option::None,
                market_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for AccountDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("AccountDetails")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for AccountDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for AccountDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct LedgerEntry {
        pub from_account: ::protobuf::MessageField<AccountDetails>,
        pub to_account: ::protobuf::MessageField<AccountDetails>,
        pub amount: ::std::string::String,
        pub type_: ::protobuf::EnumOrUnknown<TransferType>,
        pub timestamp: i64,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LedgerEntry {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LedgerEntry {
        #[inline]
        fn eq(&self, other: &LedgerEntry) -> bool {
            self.from_account == other.from_account
                && self.to_account == other.to_account && self.amount == other.amount
                && self.type_ == other.type_ && self.timestamp == other.timestamp
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LedgerEntry {
        #[inline]
        fn clone(&self) -> LedgerEntry {
            LedgerEntry {
                from_account: ::core::clone::Clone::clone(&self.from_account),
                to_account: ::core::clone::Clone::clone(&self.to_account),
                amount: ::core::clone::Clone::clone(&self.amount),
                type_: ::core::clone::Clone::clone(&self.type_),
                timestamp: ::core::clone::Clone::clone(&self.timestamp),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for LedgerEntry {
        #[inline]
        fn default() -> LedgerEntry {
            LedgerEntry {
                from_account: ::core::default::Default::default(),
                to_account: ::core::default::Default::default(),
                amount: ::core::default::Default::default(),
                type_: ::core::default::Default::default(),
                timestamp: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LedgerEntry {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "from_account",
                "to_account",
                "amount",
                "type_",
                "timestamp",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.from_account,
                &&self.to_account,
                &&self.amount,
                &&self.type_,
                &&self.timestamp,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "LedgerEntry",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a LedgerEntry {
        fn default() -> &'a LedgerEntry {
            <LedgerEntry as ::protobuf::Message>::default_instance()
        }
    }
    impl LedgerEntry {
        pub fn new() -> LedgerEntry {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        AccountDetails,
                    >(
                        "from_account",
                        |m: &LedgerEntry| { &m.from_account },
                        |m: &mut LedgerEntry| { &mut m.from_account },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        AccountDetails,
                    >(
                        "to_account",
                        |m: &LedgerEntry| { &m.to_account },
                        |m: &mut LedgerEntry| { &mut m.to_account },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "amount",
                        |m: &LedgerEntry| { &m.amount },
                        |m: &mut LedgerEntry| { &mut m.amount },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "type",
                        |m: &LedgerEntry| { &m.type_ },
                        |m: &mut LedgerEntry| { &mut m.type_ },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "timestamp",
                        |m: &LedgerEntry| { &m.timestamp },
                        |m: &mut LedgerEntry| { &mut m.timestamp },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                LedgerEntry,
            >("LedgerEntry", fields, oneofs)
        }
    }
    impl ::protobuf::Message for LedgerEntry {
        const NAME: &'static str = "LedgerEntry";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.from_account,
                        )?;
                    }
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.to_account,
                        )?;
                    }
                    26 => {
                        self.amount = is.read_string()?;
                    }
                    32 => {
                        self.type_ = is.read_enum_or_unknown()?;
                    }
                    40 => {
                        self.timestamp = is.read_int64()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.from_account.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.to_account.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.amount.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.amount);
            }
            if self.type_
                != ::protobuf::EnumOrUnknown::new(
                    TransferType::TRANSFER_TYPE_UNSPECIFIED,
                )
            {
                my_size += ::protobuf::rt::int32_size(4, self.type_.value());
            }
            if self.timestamp != 0 {
                my_size += ::protobuf::rt::int64_size(5, self.timestamp);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if let Some(v) = self.from_account.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.to_account.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if !self.amount.is_empty() {
                os.write_string(3, &self.amount)?;
            }
            if self.type_
                != ::protobuf::EnumOrUnknown::new(
                    TransferType::TRANSFER_TYPE_UNSPECIFIED,
                )
            {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.type_))?;
            }
            if self.timestamp != 0 {
                os.write_int64(5, self.timestamp)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> LedgerEntry {
            LedgerEntry::new()
        }
        fn clear(&mut self) {
            self.from_account.clear();
            self.to_account.clear();
            self.amount.clear();
            self
                .type_ = ::protobuf::EnumOrUnknown::new(
                TransferType::TRANSFER_TYPE_UNSPECIFIED,
            );
            self.timestamp = 0;
            self.special_fields.clear();
        }
        fn default_instance() -> &'static LedgerEntry {
            static instance: LedgerEntry = LedgerEntry {
                from_account: ::protobuf::MessageField::none(),
                to_account: ::protobuf::MessageField::none(),
                amount: ::std::string::String::new(),
                type_: ::protobuf::EnumOrUnknown::from_i32(0),
                timestamp: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for LedgerEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("LedgerEntry")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for LedgerEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for LedgerEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct PostTransferBalance {
        pub account: ::protobuf::MessageField<AccountDetails>,
        pub balance: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PostTransferBalance {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PostTransferBalance {
        #[inline]
        fn eq(&self, other: &PostTransferBalance) -> bool {
            self.account == other.account && self.balance == other.balance
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PostTransferBalance {
        #[inline]
        fn clone(&self) -> PostTransferBalance {
            PostTransferBalance {
                account: ::core::clone::Clone::clone(&self.account),
                balance: ::core::clone::Clone::clone(&self.balance),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for PostTransferBalance {
        #[inline]
        fn default() -> PostTransferBalance {
            PostTransferBalance {
                account: ::core::default::Default::default(),
                balance: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PostTransferBalance {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "PostTransferBalance",
                "account",
                &&self.account,
                "balance",
                &&self.balance,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a PostTransferBalance {
        fn default() -> &'a PostTransferBalance {
            <PostTransferBalance as ::protobuf::Message>::default_instance()
        }
    }
    impl PostTransferBalance {
        pub fn new() -> PostTransferBalance {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        AccountDetails,
                    >(
                        "account",
                        |m: &PostTransferBalance| { &m.account },
                        |m: &mut PostTransferBalance| { &mut m.account },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "balance",
                        |m: &PostTransferBalance| { &m.balance },
                        |m: &mut PostTransferBalance| { &mut m.balance },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                PostTransferBalance,
            >("PostTransferBalance", fields, oneofs)
        }
    }
    impl ::protobuf::Message for PostTransferBalance {
        const NAME: &'static str = "PostTransferBalance";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.account,
                        )?;
                    }
                    18 => {
                        self.balance = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.balance.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.balance);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if let Some(v) = self.account.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if !self.balance.is_empty() {
                os.write_string(2, &self.balance)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> PostTransferBalance {
            PostTransferBalance::new()
        }
        fn clear(&mut self) {
            self.account.clear();
            self.balance.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static PostTransferBalance {
            static instance: PostTransferBalance = PostTransferBalance {
                account: ::protobuf::MessageField::none(),
                balance: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for PostTransferBalance {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("PostTransferBalance")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for PostTransferBalance {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for PostTransferBalance {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct LedgerMovement {
        pub entries: ::std::vec::Vec<LedgerEntry>,
        pub balances: ::std::vec::Vec<PostTransferBalance>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LedgerMovement {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LedgerMovement {
        #[inline]
        fn eq(&self, other: &LedgerMovement) -> bool {
            self.entries == other.entries && self.balances == other.balances
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LedgerMovement {
        #[inline]
        fn clone(&self) -> LedgerMovement {
            LedgerMovement {
                entries: ::core::clone::Clone::clone(&self.entries),
                balances: ::core::clone::Clone::clone(&self.balances),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for LedgerMovement {
        #[inline]
        fn default() -> LedgerMovement {
            LedgerMovement {
                entries: ::core::default::Default::default(),
                balances: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LedgerMovement {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "LedgerMovement",
                "entries",
                &&self.entries,
                "balances",
                &&self.balances,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a LedgerMovement {
        fn default() -> &'a LedgerMovement {
            <LedgerMovement as ::protobuf::Message>::default_instance()
        }
    }
    impl LedgerMovement {
        pub fn new() -> LedgerMovement {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "entries",
                        |m: &LedgerMovement| { &m.entries },
                        |m: &mut LedgerMovement| { &mut m.entries },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "balances",
                        |m: &LedgerMovement| { &m.balances },
                        |m: &mut LedgerMovement| { &mut m.balances },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                LedgerMovement,
            >("LedgerMovement", fields, oneofs)
        }
    }
    impl ::protobuf::Message for LedgerMovement {
        const NAME: &'static str = "LedgerMovement";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.entries.push(is.read_message()?);
                    }
                    18 => {
                        self.balances.push(is.read_message()?);
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.entries {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.balances {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            for v in &self.entries {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            for v in &self.balances {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> LedgerMovement {
            LedgerMovement::new()
        }
        fn clear(&mut self) {
            self.entries.clear();
            self.balances.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static LedgerMovement {
            static instance: LedgerMovement = LedgerMovement {
                entries: ::std::vec::Vec::new(),
                balances: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for LedgerMovement {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("LedgerMovement")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for LedgerMovement {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for LedgerMovement {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct MarginLevels {
        pub maintenance_margin: ::std::string::String,
        pub search_level: ::std::string::String,
        pub initial_margin: ::std::string::String,
        pub collateral_release_level: ::std::string::String,
        pub party_id: ::std::string::String,
        pub market_id: ::std::string::String,
        pub asset: ::std::string::String,
        pub timestamp: i64,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MarginLevels {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MarginLevels {
        #[inline]
        fn eq(&self, other: &MarginLevels) -> bool {
            self.maintenance_margin == other.maintenance_margin
                && self.search_level == other.search_level
                && self.initial_margin == other.initial_margin
                && self.collateral_release_level == other.collateral_release_level
                && self.party_id == other.party_id && self.market_id == other.market_id
                && self.asset == other.asset && self.timestamp == other.timestamp
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MarginLevels {
        #[inline]
        fn clone(&self) -> MarginLevels {
            MarginLevels {
                maintenance_margin: ::core::clone::Clone::clone(
                    &self.maintenance_margin,
                ),
                search_level: ::core::clone::Clone::clone(&self.search_level),
                initial_margin: ::core::clone::Clone::clone(&self.initial_margin),
                collateral_release_level: ::core::clone::Clone::clone(
                    &self.collateral_release_level,
                ),
                party_id: ::core::clone::Clone::clone(&self.party_id),
                market_id: ::core::clone::Clone::clone(&self.market_id),
                asset: ::core::clone::Clone::clone(&self.asset),
                timestamp: ::core::clone::Clone::clone(&self.timestamp),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for MarginLevels {
        #[inline]
        fn default() -> MarginLevels {
            MarginLevels {
                maintenance_margin: ::core::default::Default::default(),
                search_level: ::core::default::Default::default(),
                initial_margin: ::core::default::Default::default(),
                collateral_release_level: ::core::default::Default::default(),
                party_id: ::core::default::Default::default(),
                market_id: ::core::default::Default::default(),
                asset: ::core::default::Default::default(),
                timestamp: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for MarginLevels {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "maintenance_margin",
                "search_level",
                "initial_margin",
                "collateral_release_level",
                "party_id",
                "market_id",
                "asset",
                "timestamp",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.maintenance_margin,
                &&self.search_level,
                &&self.initial_margin,
                &&self.collateral_release_level,
                &&self.party_id,
                &&self.market_id,
                &&self.asset,
                &&self.timestamp,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "MarginLevels",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a MarginLevels {
        fn default() -> &'a MarginLevels {
            <MarginLevels as ::protobuf::Message>::default_instance()
        }
    }
    impl MarginLevels {
        pub fn new() -> MarginLevels {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "maintenance_margin",
                        |m: &MarginLevels| { &m.maintenance_margin },
                        |m: &mut MarginLevels| { &mut m.maintenance_margin },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "search_level",
                        |m: &MarginLevels| { &m.search_level },
                        |m: &mut MarginLevels| { &mut m.search_level },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "initial_margin",
                        |m: &MarginLevels| { &m.initial_margin },
                        |m: &mut MarginLevels| { &mut m.initial_margin },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "collateral_release_level",
                        |m: &MarginLevels| { &m.collateral_release_level },
                        |m: &mut MarginLevels| { &mut m.collateral_release_level },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "party_id",
                        |m: &MarginLevels| { &m.party_id },
                        |m: &mut MarginLevels| { &mut m.party_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "market_id",
                        |m: &MarginLevels| { &m.market_id },
                        |m: &mut MarginLevels| { &mut m.market_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "asset",
                        |m: &MarginLevels| { &m.asset },
                        |m: &mut MarginLevels| { &mut m.asset },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "timestamp",
                        |m: &MarginLevels| { &m.timestamp },
                        |m: &mut MarginLevels| { &mut m.timestamp },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                MarginLevels,
            >("MarginLevels", fields, oneofs)
        }
    }
    impl ::protobuf::Message for MarginLevels {
        const NAME: &'static str = "MarginLevels";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.maintenance_margin = is.read_string()?;
                    }
                    18 => {
                        self.search_level = is.read_string()?;
                    }
                    26 => {
                        self.initial_margin = is.read_string()?;
                    }
                    34 => {
                        self.collateral_release_level = is.read_string()?;
                    }
                    42 => {
                        self.party_id = is.read_string()?;
                    }
                    50 => {
                        self.market_id = is.read_string()?;
                    }
                    58 => {
                        self.asset = is.read_string()?;
                    }
                    64 => {
                        self.timestamp = is.read_int64()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.maintenance_margin.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.maintenance_margin);
            }
            if !self.search_level.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.search_level);
            }
            if !self.initial_margin.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.initial_margin);
            }
            if !self.collateral_release_level.is_empty() {
                my_size
                    += ::protobuf::rt::string_size(4, &self.collateral_release_level);
            }
            if !self.party_id.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.party_id);
            }
            if !self.market_id.is_empty() {
                my_size += ::protobuf::rt::string_size(6, &self.market_id);
            }
            if !self.asset.is_empty() {
                my_size += ::protobuf::rt::string_size(7, &self.asset);
            }
            if self.timestamp != 0 {
                my_size += ::protobuf::rt::int64_size(8, self.timestamp);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.maintenance_margin.is_empty() {
                os.write_string(1, &self.maintenance_margin)?;
            }
            if !self.search_level.is_empty() {
                os.write_string(2, &self.search_level)?;
            }
            if !self.initial_margin.is_empty() {
                os.write_string(3, &self.initial_margin)?;
            }
            if !self.collateral_release_level.is_empty() {
                os.write_string(4, &self.collateral_release_level)?;
            }
            if !self.party_id.is_empty() {
                os.write_string(5, &self.party_id)?;
            }
            if !self.market_id.is_empty() {
                os.write_string(6, &self.market_id)?;
            }
            if !self.asset.is_empty() {
                os.write_string(7, &self.asset)?;
            }
            if self.timestamp != 0 {
                os.write_int64(8, self.timestamp)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> MarginLevels {
            MarginLevels::new()
        }
        fn clear(&mut self) {
            self.maintenance_margin.clear();
            self.search_level.clear();
            self.initial_margin.clear();
            self.collateral_release_level.clear();
            self.party_id.clear();
            self.market_id.clear();
            self.asset.clear();
            self.timestamp = 0;
            self.special_fields.clear();
        }
        fn default_instance() -> &'static MarginLevels {
            static instance: MarginLevels = MarginLevels {
                maintenance_margin: ::std::string::String::new(),
                search_level: ::std::string::String::new(),
                initial_margin: ::std::string::String::new(),
                collateral_release_level: ::std::string::String::new(),
                party_id: ::std::string::String::new(),
                market_id: ::std::string::String::new(),
                asset: ::std::string::String::new(),
                timestamp: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for MarginLevels {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("MarginLevels")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for MarginLevels {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for MarginLevels {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct MarketData {
        pub mark_price: ::std::string::String,
        pub best_bid_price: ::std::string::String,
        pub best_bid_volume: u64,
        pub best_offer_price: ::std::string::String,
        pub best_offer_volume: u64,
        pub best_static_bid_price: ::std::string::String,
        pub best_static_bid_volume: u64,
        pub best_static_offer_price: ::std::string::String,
        pub best_static_offer_volume: u64,
        pub mid_price: ::std::string::String,
        pub static_mid_price: ::std::string::String,
        pub market: ::std::string::String,
        pub timestamp: i64,
        pub open_interest: u64,
        pub auction_end: i64,
        pub auction_start: i64,
        pub indicative_price: ::std::string::String,
        pub indicative_volume: u64,
        pub market_trading_mode: ::protobuf::EnumOrUnknown<
            super::markets::market::TradingMode,
        >,
        pub trigger: ::protobuf::EnumOrUnknown<AuctionTrigger>,
        pub extension_trigger: ::protobuf::EnumOrUnknown<AuctionTrigger>,
        pub target_stake: ::std::string::String,
        pub supplied_stake: ::std::string::String,
        pub price_monitoring_bounds: ::std::vec::Vec<PriceMonitoringBounds>,
        pub market_value_proxy: ::std::string::String,
        pub liquidity_provider_fee_share: ::std::vec::Vec<LiquidityProviderFeeShare>,
        pub market_state: ::protobuf::EnumOrUnknown<super::markets::market::State>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MarketData {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MarketData {
        #[inline]
        fn eq(&self, other: &MarketData) -> bool {
            self.mark_price == other.mark_price
                && self.best_bid_price == other.best_bid_price
                && self.best_bid_volume == other.best_bid_volume
                && self.best_offer_price == other.best_offer_price
                && self.best_offer_volume == other.best_offer_volume
                && self.best_static_bid_price == other.best_static_bid_price
                && self.best_static_bid_volume == other.best_static_bid_volume
                && self.best_static_offer_price == other.best_static_offer_price
                && self.best_static_offer_volume == other.best_static_offer_volume
                && self.mid_price == other.mid_price
                && self.static_mid_price == other.static_mid_price
                && self.market == other.market && self.timestamp == other.timestamp
                && self.open_interest == other.open_interest
                && self.auction_end == other.auction_end
                && self.auction_start == other.auction_start
                && self.indicative_price == other.indicative_price
                && self.indicative_volume == other.indicative_volume
                && self.market_trading_mode == other.market_trading_mode
                && self.trigger == other.trigger
                && self.extension_trigger == other.extension_trigger
                && self.target_stake == other.target_stake
                && self.supplied_stake == other.supplied_stake
                && self.price_monitoring_bounds == other.price_monitoring_bounds
                && self.market_value_proxy == other.market_value_proxy
                && self.liquidity_provider_fee_share
                    == other.liquidity_provider_fee_share
                && self.market_state == other.market_state
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MarketData {
        #[inline]
        fn clone(&self) -> MarketData {
            MarketData {
                mark_price: ::core::clone::Clone::clone(&self.mark_price),
                best_bid_price: ::core::clone::Clone::clone(&self.best_bid_price),
                best_bid_volume: ::core::clone::Clone::clone(&self.best_bid_volume),
                best_offer_price: ::core::clone::Clone::clone(&self.best_offer_price),
                best_offer_volume: ::core::clone::Clone::clone(&self.best_offer_volume),
                best_static_bid_price: ::core::clone::Clone::clone(
                    &self.best_static_bid_price,
                ),
                best_static_bid_volume: ::core::clone::Clone::clone(
                    &self.best_static_bid_volume,
                ),
                best_static_offer_price: ::core::clone::Clone::clone(
                    &self.best_static_offer_price,
                ),
                best_static_offer_volume: ::core::clone::Clone::clone(
                    &self.best_static_offer_volume,
                ),
                mid_price: ::core::clone::Clone::clone(&self.mid_price),
                static_mid_price: ::core::clone::Clone::clone(&self.static_mid_price),
                market: ::core::clone::Clone::clone(&self.market),
                timestamp: ::core::clone::Clone::clone(&self.timestamp),
                open_interest: ::core::clone::Clone::clone(&self.open_interest),
                auction_end: ::core::clone::Clone::clone(&self.auction_end),
                auction_start: ::core::clone::Clone::clone(&self.auction_start),
                indicative_price: ::core::clone::Clone::clone(&self.indicative_price),
                indicative_volume: ::core::clone::Clone::clone(&self.indicative_volume),
                market_trading_mode: ::core::clone::Clone::clone(
                    &self.market_trading_mode,
                ),
                trigger: ::core::clone::Clone::clone(&self.trigger),
                extension_trigger: ::core::clone::Clone::clone(&self.extension_trigger),
                target_stake: ::core::clone::Clone::clone(&self.target_stake),
                supplied_stake: ::core::clone::Clone::clone(&self.supplied_stake),
                price_monitoring_bounds: ::core::clone::Clone::clone(
                    &self.price_monitoring_bounds,
                ),
                market_value_proxy: ::core::clone::Clone::clone(
                    &self.market_value_proxy,
                ),
                liquidity_provider_fee_share: ::core::clone::Clone::clone(
                    &self.liquidity_provider_fee_share,
                ),
                market_state: ::core::clone::Clone::clone(&self.market_state),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for MarketData {
        #[inline]
        fn default() -> MarketData {
            MarketData {
                mark_price: ::core::default::Default::default(),
                best_bid_price: ::core::default::Default::default(),
                best_bid_volume: ::core::default::Default::default(),
                best_offer_price: ::core::default::Default::default(),
                best_offer_volume: ::core::default::Default::default(),
                best_static_bid_price: ::core::default::Default::default(),
                best_static_bid_volume: ::core::default::Default::default(),
                best_static_offer_price: ::core::default::Default::default(),
                best_static_offer_volume: ::core::default::Default::default(),
                mid_price: ::core::default::Default::default(),
                static_mid_price: ::core::default::Default::default(),
                market: ::core::default::Default::default(),
                timestamp: ::core::default::Default::default(),
                open_interest: ::core::default::Default::default(),
                auction_end: ::core::default::Default::default(),
                auction_start: ::core::default::Default::default(),
                indicative_price: ::core::default::Default::default(),
                indicative_volume: ::core::default::Default::default(),
                market_trading_mode: ::core::default::Default::default(),
                trigger: ::core::default::Default::default(),
                extension_trigger: ::core::default::Default::default(),
                target_stake: ::core::default::Default::default(),
                supplied_stake: ::core::default::Default::default(),
                price_monitoring_bounds: ::core::default::Default::default(),
                market_value_proxy: ::core::default::Default::default(),
                liquidity_provider_fee_share: ::core::default::Default::default(),
                market_state: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for MarketData {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "mark_price",
                "best_bid_price",
                "best_bid_volume",
                "best_offer_price",
                "best_offer_volume",
                "best_static_bid_price",
                "best_static_bid_volume",
                "best_static_offer_price",
                "best_static_offer_volume",
                "mid_price",
                "static_mid_price",
                "market",
                "timestamp",
                "open_interest",
                "auction_end",
                "auction_start",
                "indicative_price",
                "indicative_volume",
                "market_trading_mode",
                "trigger",
                "extension_trigger",
                "target_stake",
                "supplied_stake",
                "price_monitoring_bounds",
                "market_value_proxy",
                "liquidity_provider_fee_share",
                "market_state",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.mark_price,
                &&self.best_bid_price,
                &&self.best_bid_volume,
                &&self.best_offer_price,
                &&self.best_offer_volume,
                &&self.best_static_bid_price,
                &&self.best_static_bid_volume,
                &&self.best_static_offer_price,
                &&self.best_static_offer_volume,
                &&self.mid_price,
                &&self.static_mid_price,
                &&self.market,
                &&self.timestamp,
                &&self.open_interest,
                &&self.auction_end,
                &&self.auction_start,
                &&self.indicative_price,
                &&self.indicative_volume,
                &&self.market_trading_mode,
                &&self.trigger,
                &&self.extension_trigger,
                &&self.target_stake,
                &&self.supplied_stake,
                &&self.price_monitoring_bounds,
                &&self.market_value_proxy,
                &&self.liquidity_provider_fee_share,
                &&self.market_state,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "MarketData",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a MarketData {
        fn default() -> &'a MarketData {
            <MarketData as ::protobuf::Message>::default_instance()
        }
    }
    impl MarketData {
        pub fn new() -> MarketData {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(27);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "mark_price",
                        |m: &MarketData| { &m.mark_price },
                        |m: &mut MarketData| { &mut m.mark_price },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "best_bid_price",
                        |m: &MarketData| { &m.best_bid_price },
                        |m: &mut MarketData| { &mut m.best_bid_price },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "best_bid_volume",
                        |m: &MarketData| { &m.best_bid_volume },
                        |m: &mut MarketData| { &mut m.best_bid_volume },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "best_offer_price",
                        |m: &MarketData| { &m.best_offer_price },
                        |m: &mut MarketData| { &mut m.best_offer_price },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "best_offer_volume",
                        |m: &MarketData| { &m.best_offer_volume },
                        |m: &mut MarketData| { &mut m.best_offer_volume },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "best_static_bid_price",
                        |m: &MarketData| { &m.best_static_bid_price },
                        |m: &mut MarketData| { &mut m.best_static_bid_price },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "best_static_bid_volume",
                        |m: &MarketData| { &m.best_static_bid_volume },
                        |m: &mut MarketData| { &mut m.best_static_bid_volume },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "best_static_offer_price",
                        |m: &MarketData| { &m.best_static_offer_price },
                        |m: &mut MarketData| { &mut m.best_static_offer_price },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "best_static_offer_volume",
                        |m: &MarketData| { &m.best_static_offer_volume },
                        |m: &mut MarketData| { &mut m.best_static_offer_volume },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "mid_price",
                        |m: &MarketData| { &m.mid_price },
                        |m: &mut MarketData| { &mut m.mid_price },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "static_mid_price",
                        |m: &MarketData| { &m.static_mid_price },
                        |m: &mut MarketData| { &mut m.static_mid_price },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "market",
                        |m: &MarketData| { &m.market },
                        |m: &mut MarketData| { &mut m.market },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "timestamp",
                        |m: &MarketData| { &m.timestamp },
                        |m: &mut MarketData| { &mut m.timestamp },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "open_interest",
                        |m: &MarketData| { &m.open_interest },
                        |m: &mut MarketData| { &mut m.open_interest },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "auction_end",
                        |m: &MarketData| { &m.auction_end },
                        |m: &mut MarketData| { &mut m.auction_end },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "auction_start",
                        |m: &MarketData| { &m.auction_start },
                        |m: &mut MarketData| { &mut m.auction_start },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "indicative_price",
                        |m: &MarketData| { &m.indicative_price },
                        |m: &mut MarketData| { &mut m.indicative_price },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "indicative_volume",
                        |m: &MarketData| { &m.indicative_volume },
                        |m: &mut MarketData| { &mut m.indicative_volume },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "market_trading_mode",
                        |m: &MarketData| { &m.market_trading_mode },
                        |m: &mut MarketData| { &mut m.market_trading_mode },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "trigger",
                        |m: &MarketData| { &m.trigger },
                        |m: &mut MarketData| { &mut m.trigger },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "extension_trigger",
                        |m: &MarketData| { &m.extension_trigger },
                        |m: &mut MarketData| { &mut m.extension_trigger },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "target_stake",
                        |m: &MarketData| { &m.target_stake },
                        |m: &mut MarketData| { &mut m.target_stake },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "supplied_stake",
                        |m: &MarketData| { &m.supplied_stake },
                        |m: &mut MarketData| { &mut m.supplied_stake },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "price_monitoring_bounds",
                        |m: &MarketData| { &m.price_monitoring_bounds },
                        |m: &mut MarketData| { &mut m.price_monitoring_bounds },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "market_value_proxy",
                        |m: &MarketData| { &m.market_value_proxy },
                        |m: &mut MarketData| { &mut m.market_value_proxy },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "liquidity_provider_fee_share",
                        |m: &MarketData| { &m.liquidity_provider_fee_share },
                        |m: &mut MarketData| { &mut m.liquidity_provider_fee_share },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "market_state",
                        |m: &MarketData| { &m.market_state },
                        |m: &mut MarketData| { &mut m.market_state },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                MarketData,
            >("MarketData", fields, oneofs)
        }
    }
    impl ::protobuf::Message for MarketData {
        const NAME: &'static str = "MarketData";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.mark_price = is.read_string()?;
                    }
                    18 => {
                        self.best_bid_price = is.read_string()?;
                    }
                    24 => {
                        self.best_bid_volume = is.read_uint64()?;
                    }
                    34 => {
                        self.best_offer_price = is.read_string()?;
                    }
                    40 => {
                        self.best_offer_volume = is.read_uint64()?;
                    }
                    50 => {
                        self.best_static_bid_price = is.read_string()?;
                    }
                    56 => {
                        self.best_static_bid_volume = is.read_uint64()?;
                    }
                    66 => {
                        self.best_static_offer_price = is.read_string()?;
                    }
                    72 => {
                        self.best_static_offer_volume = is.read_uint64()?;
                    }
                    82 => {
                        self.mid_price = is.read_string()?;
                    }
                    90 => {
                        self.static_mid_price = is.read_string()?;
                    }
                    98 => {
                        self.market = is.read_string()?;
                    }
                    104 => {
                        self.timestamp = is.read_int64()?;
                    }
                    112 => {
                        self.open_interest = is.read_uint64()?;
                    }
                    120 => {
                        self.auction_end = is.read_int64()?;
                    }
                    128 => {
                        self.auction_start = is.read_int64()?;
                    }
                    138 => {
                        self.indicative_price = is.read_string()?;
                    }
                    144 => {
                        self.indicative_volume = is.read_uint64()?;
                    }
                    152 => {
                        self.market_trading_mode = is.read_enum_or_unknown()?;
                    }
                    160 => {
                        self.trigger = is.read_enum_or_unknown()?;
                    }
                    168 => {
                        self.extension_trigger = is.read_enum_or_unknown()?;
                    }
                    178 => {
                        self.target_stake = is.read_string()?;
                    }
                    186 => {
                        self.supplied_stake = is.read_string()?;
                    }
                    194 => {
                        self.price_monitoring_bounds.push(is.read_message()?);
                    }
                    202 => {
                        self.market_value_proxy = is.read_string()?;
                    }
                    210 => {
                        self.liquidity_provider_fee_share.push(is.read_message()?);
                    }
                    216 => {
                        self.market_state = is.read_enum_or_unknown()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.mark_price.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.mark_price);
            }
            if !self.best_bid_price.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.best_bid_price);
            }
            if self.best_bid_volume != 0 {
                my_size += ::protobuf::rt::uint64_size(3, self.best_bid_volume);
            }
            if !self.best_offer_price.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.best_offer_price);
            }
            if self.best_offer_volume != 0 {
                my_size += ::protobuf::rt::uint64_size(5, self.best_offer_volume);
            }
            if !self.best_static_bid_price.is_empty() {
                my_size += ::protobuf::rt::string_size(6, &self.best_static_bid_price);
            }
            if self.best_static_bid_volume != 0 {
                my_size += ::protobuf::rt::uint64_size(7, self.best_static_bid_volume);
            }
            if !self.best_static_offer_price.is_empty() {
                my_size += ::protobuf::rt::string_size(8, &self.best_static_offer_price);
            }
            if self.best_static_offer_volume != 0 {
                my_size += ::protobuf::rt::uint64_size(9, self.best_static_offer_volume);
            }
            if !self.mid_price.is_empty() {
                my_size += ::protobuf::rt::string_size(10, &self.mid_price);
            }
            if !self.static_mid_price.is_empty() {
                my_size += ::protobuf::rt::string_size(11, &self.static_mid_price);
            }
            if !self.market.is_empty() {
                my_size += ::protobuf::rt::string_size(12, &self.market);
            }
            if self.timestamp != 0 {
                my_size += ::protobuf::rt::int64_size(13, self.timestamp);
            }
            if self.open_interest != 0 {
                my_size += ::protobuf::rt::uint64_size(14, self.open_interest);
            }
            if self.auction_end != 0 {
                my_size += ::protobuf::rt::int64_size(15, self.auction_end);
            }
            if self.auction_start != 0 {
                my_size += ::protobuf::rt::int64_size(16, self.auction_start);
            }
            if !self.indicative_price.is_empty() {
                my_size += ::protobuf::rt::string_size(17, &self.indicative_price);
            }
            if self.indicative_volume != 0 {
                my_size += ::protobuf::rt::uint64_size(18, self.indicative_volume);
            }
            if self.market_trading_mode
                != ::protobuf::EnumOrUnknown::new(
                    super::markets::market::TradingMode::TRADING_MODE_UNSPECIFIED,
                )
            {
                my_size
                    += ::protobuf::rt::int32_size(19, self.market_trading_mode.value());
            }
            if self.trigger
                != ::protobuf::EnumOrUnknown::new(
                    AuctionTrigger::AUCTION_TRIGGER_UNSPECIFIED,
                )
            {
                my_size += ::protobuf::rt::int32_size(20, self.trigger.value());
            }
            if self.extension_trigger
                != ::protobuf::EnumOrUnknown::new(
                    AuctionTrigger::AUCTION_TRIGGER_UNSPECIFIED,
                )
            {
                my_size
                    += ::protobuf::rt::int32_size(21, self.extension_trigger.value());
            }
            if !self.target_stake.is_empty() {
                my_size += ::protobuf::rt::string_size(22, &self.target_stake);
            }
            if !self.supplied_stake.is_empty() {
                my_size += ::protobuf::rt::string_size(23, &self.supplied_stake);
            }
            for value in &self.price_monitoring_bounds {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.market_value_proxy.is_empty() {
                my_size += ::protobuf::rt::string_size(25, &self.market_value_proxy);
            }
            for value in &self.liquidity_provider_fee_share {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.market_state
                != ::protobuf::EnumOrUnknown::new(
                    super::markets::market::State::STATE_UNSPECIFIED,
                )
            {
                my_size += ::protobuf::rt::int32_size(27, self.market_state.value());
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.mark_price.is_empty() {
                os.write_string(1, &self.mark_price)?;
            }
            if !self.best_bid_price.is_empty() {
                os.write_string(2, &self.best_bid_price)?;
            }
            if self.best_bid_volume != 0 {
                os.write_uint64(3, self.best_bid_volume)?;
            }
            if !self.best_offer_price.is_empty() {
                os.write_string(4, &self.best_offer_price)?;
            }
            if self.best_offer_volume != 0 {
                os.write_uint64(5, self.best_offer_volume)?;
            }
            if !self.best_static_bid_price.is_empty() {
                os.write_string(6, &self.best_static_bid_price)?;
            }
            if self.best_static_bid_volume != 0 {
                os.write_uint64(7, self.best_static_bid_volume)?;
            }
            if !self.best_static_offer_price.is_empty() {
                os.write_string(8, &self.best_static_offer_price)?;
            }
            if self.best_static_offer_volume != 0 {
                os.write_uint64(9, self.best_static_offer_volume)?;
            }
            if !self.mid_price.is_empty() {
                os.write_string(10, &self.mid_price)?;
            }
            if !self.static_mid_price.is_empty() {
                os.write_string(11, &self.static_mid_price)?;
            }
            if !self.market.is_empty() {
                os.write_string(12, &self.market)?;
            }
            if self.timestamp != 0 {
                os.write_int64(13, self.timestamp)?;
            }
            if self.open_interest != 0 {
                os.write_uint64(14, self.open_interest)?;
            }
            if self.auction_end != 0 {
                os.write_int64(15, self.auction_end)?;
            }
            if self.auction_start != 0 {
                os.write_int64(16, self.auction_start)?;
            }
            if !self.indicative_price.is_empty() {
                os.write_string(17, &self.indicative_price)?;
            }
            if self.indicative_volume != 0 {
                os.write_uint64(18, self.indicative_volume)?;
            }
            if self.market_trading_mode
                != ::protobuf::EnumOrUnknown::new(
                    super::markets::market::TradingMode::TRADING_MODE_UNSPECIFIED,
                )
            {
                os.write_enum(
                    19,
                    ::protobuf::EnumOrUnknown::value(&self.market_trading_mode),
                )?;
            }
            if self.trigger
                != ::protobuf::EnumOrUnknown::new(
                    AuctionTrigger::AUCTION_TRIGGER_UNSPECIFIED,
                )
            {
                os.write_enum(20, ::protobuf::EnumOrUnknown::value(&self.trigger))?;
            }
            if self.extension_trigger
                != ::protobuf::EnumOrUnknown::new(
                    AuctionTrigger::AUCTION_TRIGGER_UNSPECIFIED,
                )
            {
                os.write_enum(
                    21,
                    ::protobuf::EnumOrUnknown::value(&self.extension_trigger),
                )?;
            }
            if !self.target_stake.is_empty() {
                os.write_string(22, &self.target_stake)?;
            }
            if !self.supplied_stake.is_empty() {
                os.write_string(23, &self.supplied_stake)?;
            }
            for v in &self.price_monitoring_bounds {
                ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
            }
            if !self.market_value_proxy.is_empty() {
                os.write_string(25, &self.market_value_proxy)?;
            }
            for v in &self.liquidity_provider_fee_share {
                ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
            }
            if self.market_state
                != ::protobuf::EnumOrUnknown::new(
                    super::markets::market::State::STATE_UNSPECIFIED,
                )
            {
                os.write_enum(27, ::protobuf::EnumOrUnknown::value(&self.market_state))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> MarketData {
            MarketData::new()
        }
        fn clear(&mut self) {
            self.mark_price.clear();
            self.best_bid_price.clear();
            self.best_bid_volume = 0;
            self.best_offer_price.clear();
            self.best_offer_volume = 0;
            self.best_static_bid_price.clear();
            self.best_static_bid_volume = 0;
            self.best_static_offer_price.clear();
            self.best_static_offer_volume = 0;
            self.mid_price.clear();
            self.static_mid_price.clear();
            self.market.clear();
            self.timestamp = 0;
            self.open_interest = 0;
            self.auction_end = 0;
            self.auction_start = 0;
            self.indicative_price.clear();
            self.indicative_volume = 0;
            self
                .market_trading_mode = ::protobuf::EnumOrUnknown::new(
                super::markets::market::TradingMode::TRADING_MODE_UNSPECIFIED,
            );
            self
                .trigger = ::protobuf::EnumOrUnknown::new(
                AuctionTrigger::AUCTION_TRIGGER_UNSPECIFIED,
            );
            self
                .extension_trigger = ::protobuf::EnumOrUnknown::new(
                AuctionTrigger::AUCTION_TRIGGER_UNSPECIFIED,
            );
            self.target_stake.clear();
            self.supplied_stake.clear();
            self.price_monitoring_bounds.clear();
            self.market_value_proxy.clear();
            self.liquidity_provider_fee_share.clear();
            self
                .market_state = ::protobuf::EnumOrUnknown::new(
                super::markets::market::State::STATE_UNSPECIFIED,
            );
            self.special_fields.clear();
        }
        fn default_instance() -> &'static MarketData {
            static instance: MarketData = MarketData {
                mark_price: ::std::string::String::new(),
                best_bid_price: ::std::string::String::new(),
                best_bid_volume: 0,
                best_offer_price: ::std::string::String::new(),
                best_offer_volume: 0,
                best_static_bid_price: ::std::string::String::new(),
                best_static_bid_volume: 0,
                best_static_offer_price: ::std::string::String::new(),
                best_static_offer_volume: 0,
                mid_price: ::std::string::String::new(),
                static_mid_price: ::std::string::String::new(),
                market: ::std::string::String::new(),
                timestamp: 0,
                open_interest: 0,
                auction_end: 0,
                auction_start: 0,
                indicative_price: ::std::string::String::new(),
                indicative_volume: 0,
                market_trading_mode: ::protobuf::EnumOrUnknown::from_i32(0),
                trigger: ::protobuf::EnumOrUnknown::from_i32(0),
                extension_trigger: ::protobuf::EnumOrUnknown::from_i32(0),
                target_stake: ::std::string::String::new(),
                supplied_stake: ::std::string::String::new(),
                price_monitoring_bounds: ::std::vec::Vec::new(),
                market_value_proxy: ::std::string::String::new(),
                liquidity_provider_fee_share: ::std::vec::Vec::new(),
                market_state: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for MarketData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("MarketData")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for MarketData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for MarketData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct LiquidityProviderFeeShare {
        pub party: ::std::string::String,
        pub equity_like_share: ::std::string::String,
        pub average_entry_valuation: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LiquidityProviderFeeShare {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LiquidityProviderFeeShare {
        #[inline]
        fn eq(&self, other: &LiquidityProviderFeeShare) -> bool {
            self.party == other.party
                && self.equity_like_share == other.equity_like_share
                && self.average_entry_valuation == other.average_entry_valuation
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LiquidityProviderFeeShare {
        #[inline]
        fn clone(&self) -> LiquidityProviderFeeShare {
            LiquidityProviderFeeShare {
                party: ::core::clone::Clone::clone(&self.party),
                equity_like_share: ::core::clone::Clone::clone(&self.equity_like_share),
                average_entry_valuation: ::core::clone::Clone::clone(
                    &self.average_entry_valuation,
                ),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for LiquidityProviderFeeShare {
        #[inline]
        fn default() -> LiquidityProviderFeeShare {
            LiquidityProviderFeeShare {
                party: ::core::default::Default::default(),
                equity_like_share: ::core::default::Default::default(),
                average_entry_valuation: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LiquidityProviderFeeShare {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "LiquidityProviderFeeShare",
                "party",
                &&self.party,
                "equity_like_share",
                &&self.equity_like_share,
                "average_entry_valuation",
                &&self.average_entry_valuation,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a LiquidityProviderFeeShare {
        fn default() -> &'a LiquidityProviderFeeShare {
            <LiquidityProviderFeeShare as ::protobuf::Message>::default_instance()
        }
    }
    impl LiquidityProviderFeeShare {
        pub fn new() -> LiquidityProviderFeeShare {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "party",
                        |m: &LiquidityProviderFeeShare| { &m.party },
                        |m: &mut LiquidityProviderFeeShare| { &mut m.party },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "equity_like_share",
                        |m: &LiquidityProviderFeeShare| { &m.equity_like_share },
                        |m: &mut LiquidityProviderFeeShare| { &mut m.equity_like_share },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "average_entry_valuation",
                        |m: &LiquidityProviderFeeShare| { &m.average_entry_valuation },
                        |m: &mut LiquidityProviderFeeShare| {
                            &mut m.average_entry_valuation
                        },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                LiquidityProviderFeeShare,
            >("LiquidityProviderFeeShare", fields, oneofs)
        }
    }
    impl ::protobuf::Message for LiquidityProviderFeeShare {
        const NAME: &'static str = "LiquidityProviderFeeShare";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.party = is.read_string()?;
                    }
                    18 => {
                        self.equity_like_share = is.read_string()?;
                    }
                    26 => {
                        self.average_entry_valuation = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.party.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.party);
            }
            if !self.equity_like_share.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.equity_like_share);
            }
            if !self.average_entry_valuation.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.average_entry_valuation);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.party.is_empty() {
                os.write_string(1, &self.party)?;
            }
            if !self.equity_like_share.is_empty() {
                os.write_string(2, &self.equity_like_share)?;
            }
            if !self.average_entry_valuation.is_empty() {
                os.write_string(3, &self.average_entry_valuation)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> LiquidityProviderFeeShare {
            LiquidityProviderFeeShare::new()
        }
        fn clear(&mut self) {
            self.party.clear();
            self.equity_like_share.clear();
            self.average_entry_valuation.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static LiquidityProviderFeeShare {
            static instance: LiquidityProviderFeeShare = LiquidityProviderFeeShare {
                party: ::std::string::String::new(),
                equity_like_share: ::std::string::String::new(),
                average_entry_valuation: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for LiquidityProviderFeeShare {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("LiquidityProviderFeeShare")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for LiquidityProviderFeeShare {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for LiquidityProviderFeeShare {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct PriceMonitoringBounds {
        pub min_valid_price: ::std::string::String,
        pub max_valid_price: ::std::string::String,
        pub trigger: ::protobuf::MessageField<super::markets::PriceMonitoringTrigger>,
        pub reference_price: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PriceMonitoringBounds {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PriceMonitoringBounds {
        #[inline]
        fn eq(&self, other: &PriceMonitoringBounds) -> bool {
            self.min_valid_price == other.min_valid_price
                && self.max_valid_price == other.max_valid_price
                && self.trigger == other.trigger
                && self.reference_price == other.reference_price
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PriceMonitoringBounds {
        #[inline]
        fn clone(&self) -> PriceMonitoringBounds {
            PriceMonitoringBounds {
                min_valid_price: ::core::clone::Clone::clone(&self.min_valid_price),
                max_valid_price: ::core::clone::Clone::clone(&self.max_valid_price),
                trigger: ::core::clone::Clone::clone(&self.trigger),
                reference_price: ::core::clone::Clone::clone(&self.reference_price),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for PriceMonitoringBounds {
        #[inline]
        fn default() -> PriceMonitoringBounds {
            PriceMonitoringBounds {
                min_valid_price: ::core::default::Default::default(),
                max_valid_price: ::core::default::Default::default(),
                trigger: ::core::default::Default::default(),
                reference_price: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PriceMonitoringBounds {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "PriceMonitoringBounds",
                "min_valid_price",
                &&self.min_valid_price,
                "max_valid_price",
                &&self.max_valid_price,
                "trigger",
                &&self.trigger,
                "reference_price",
                &&self.reference_price,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a PriceMonitoringBounds {
        fn default() -> &'a PriceMonitoringBounds {
            <PriceMonitoringBounds as ::protobuf::Message>::default_instance()
        }
    }
    impl PriceMonitoringBounds {
        pub fn new() -> PriceMonitoringBounds {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "min_valid_price",
                        |m: &PriceMonitoringBounds| { &m.min_valid_price },
                        |m: &mut PriceMonitoringBounds| { &mut m.min_valid_price },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "max_valid_price",
                        |m: &PriceMonitoringBounds| { &m.max_valid_price },
                        |m: &mut PriceMonitoringBounds| { &mut m.max_valid_price },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        super::markets::PriceMonitoringTrigger,
                    >(
                        "trigger",
                        |m: &PriceMonitoringBounds| { &m.trigger },
                        |m: &mut PriceMonitoringBounds| { &mut m.trigger },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "reference_price",
                        |m: &PriceMonitoringBounds| { &m.reference_price },
                        |m: &mut PriceMonitoringBounds| { &mut m.reference_price },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                PriceMonitoringBounds,
            >("PriceMonitoringBounds", fields, oneofs)
        }
    }
    impl ::protobuf::Message for PriceMonitoringBounds {
        const NAME: &'static str = "PriceMonitoringBounds";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.min_valid_price = is.read_string()?;
                    }
                    18 => {
                        self.max_valid_price = is.read_string()?;
                    }
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.trigger,
                        )?;
                    }
                    34 => {
                        self.reference_price = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.min_valid_price.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.min_valid_price);
            }
            if !self.max_valid_price.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.max_valid_price);
            }
            if let Some(v) = self.trigger.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.reference_price.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.reference_price);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.min_valid_price.is_empty() {
                os.write_string(1, &self.min_valid_price)?;
            }
            if !self.max_valid_price.is_empty() {
                os.write_string(2, &self.max_valid_price)?;
            }
            if let Some(v) = self.trigger.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if !self.reference_price.is_empty() {
                os.write_string(4, &self.reference_price)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> PriceMonitoringBounds {
            PriceMonitoringBounds::new()
        }
        fn clear(&mut self) {
            self.min_valid_price.clear();
            self.max_valid_price.clear();
            self.trigger.clear();
            self.reference_price.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static PriceMonitoringBounds {
            static instance: PriceMonitoringBounds = PriceMonitoringBounds {
                min_valid_price: ::std::string::String::new(),
                max_valid_price: ::std::string::String::new(),
                trigger: ::protobuf::MessageField::none(),
                reference_price: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for PriceMonitoringBounds {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("PriceMonitoringBounds")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for PriceMonitoringBounds {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for PriceMonitoringBounds {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct ErrorDetail {
        pub code: i32,
        pub message: ::std::string::String,
        pub inner: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ErrorDetail {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ErrorDetail {
        #[inline]
        fn eq(&self, other: &ErrorDetail) -> bool {
            self.code == other.code && self.message == other.message
                && self.inner == other.inner
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ErrorDetail {
        #[inline]
        fn clone(&self) -> ErrorDetail {
            ErrorDetail {
                code: ::core::clone::Clone::clone(&self.code),
                message: ::core::clone::Clone::clone(&self.message),
                inner: ::core::clone::Clone::clone(&self.inner),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for ErrorDetail {
        #[inline]
        fn default() -> ErrorDetail {
            ErrorDetail {
                code: ::core::default::Default::default(),
                message: ::core::default::Default::default(),
                inner: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ErrorDetail {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "ErrorDetail",
                "code",
                &&self.code,
                "message",
                &&self.message,
                "inner",
                &&self.inner,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a ErrorDetail {
        fn default() -> &'a ErrorDetail {
            <ErrorDetail as ::protobuf::Message>::default_instance()
        }
    }
    impl ErrorDetail {
        pub fn new() -> ErrorDetail {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "code",
                        |m: &ErrorDetail| { &m.code },
                        |m: &mut ErrorDetail| { &mut m.code },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "message",
                        |m: &ErrorDetail| { &m.message },
                        |m: &mut ErrorDetail| { &mut m.message },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "inner",
                        |m: &ErrorDetail| { &m.inner },
                        |m: &mut ErrorDetail| { &mut m.inner },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                ErrorDetail,
            >("ErrorDetail", fields, oneofs)
        }
    }
    impl ::protobuf::Message for ErrorDetail {
        const NAME: &'static str = "ErrorDetail";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.code = is.read_int32()?;
                    }
                    18 => {
                        self.message = is.read_string()?;
                    }
                    26 => {
                        self.inner = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.code != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.code);
            }
            if !self.message.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.message);
            }
            if !self.inner.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.inner);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if self.code != 0 {
                os.write_int32(1, self.code)?;
            }
            if !self.message.is_empty() {
                os.write_string(2, &self.message)?;
            }
            if !self.inner.is_empty() {
                os.write_string(3, &self.inner)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> ErrorDetail {
            ErrorDetail::new()
        }
        fn clear(&mut self) {
            self.code = 0;
            self.message.clear();
            self.inner.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static ErrorDetail {
            static instance: ErrorDetail = ErrorDetail {
                code: 0,
                message: ::std::string::String::new(),
                inner: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for ErrorDetail {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("ErrorDetail")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for ErrorDetail {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for ErrorDetail {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct NetworkParameter {
        pub key: ::std::string::String,
        pub value: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for NetworkParameter {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for NetworkParameter {
        #[inline]
        fn eq(&self, other: &NetworkParameter) -> bool {
            self.key == other.key && self.value == other.value
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for NetworkParameter {
        #[inline]
        fn clone(&self) -> NetworkParameter {
            NetworkParameter {
                key: ::core::clone::Clone::clone(&self.key),
                value: ::core::clone::Clone::clone(&self.value),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for NetworkParameter {
        #[inline]
        fn default() -> NetworkParameter {
            NetworkParameter {
                key: ::core::default::Default::default(),
                value: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for NetworkParameter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "NetworkParameter",
                "key",
                &&self.key,
                "value",
                &&self.value,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a NetworkParameter {
        fn default() -> &'a NetworkParameter {
            <NetworkParameter as ::protobuf::Message>::default_instance()
        }
    }
    impl NetworkParameter {
        pub fn new() -> NetworkParameter {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "key",
                        |m: &NetworkParameter| { &m.key },
                        |m: &mut NetworkParameter| { &mut m.key },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "value",
                        |m: &NetworkParameter| { &m.value },
                        |m: &mut NetworkParameter| { &mut m.value },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                NetworkParameter,
            >("NetworkParameter", fields, oneofs)
        }
    }
    impl ::protobuf::Message for NetworkParameter {
        const NAME: &'static str = "NetworkParameter";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.key = is.read_string()?;
                    }
                    18 => {
                        self.value = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.key.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.key);
            }
            if !self.value.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.value);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.key.is_empty() {
                os.write_string(1, &self.key)?;
            }
            if !self.value.is_empty() {
                os.write_string(2, &self.value)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> NetworkParameter {
            NetworkParameter::new()
        }
        fn clear(&mut self) {
            self.key.clear();
            self.value.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static NetworkParameter {
            static instance: NetworkParameter = NetworkParameter {
                key: ::std::string::String::new(),
                value: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for NetworkParameter {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("NetworkParameter")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for NetworkParameter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for NetworkParameter {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct NetworkLimits {
        pub can_propose_market: bool,
        pub can_propose_asset: bool,
        pub bootstrap_finished: bool,
        pub propose_market_enabled: bool,
        pub propose_asset_enabled: bool,
        pub bootstrap_block_count: u32,
        pub genesis_loaded: bool,
        pub propose_market_enabled_from: i64,
        pub propose_asset_enabled_from: i64,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for NetworkLimits {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for NetworkLimits {
        #[inline]
        fn eq(&self, other: &NetworkLimits) -> bool {
            self.can_propose_market == other.can_propose_market
                && self.can_propose_asset == other.can_propose_asset
                && self.bootstrap_finished == other.bootstrap_finished
                && self.propose_market_enabled == other.propose_market_enabled
                && self.propose_asset_enabled == other.propose_asset_enabled
                && self.bootstrap_block_count == other.bootstrap_block_count
                && self.genesis_loaded == other.genesis_loaded
                && self.propose_market_enabled_from == other.propose_market_enabled_from
                && self.propose_asset_enabled_from == other.propose_asset_enabled_from
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for NetworkLimits {
        #[inline]
        fn clone(&self) -> NetworkLimits {
            NetworkLimits {
                can_propose_market: ::core::clone::Clone::clone(
                    &self.can_propose_market,
                ),
                can_propose_asset: ::core::clone::Clone::clone(&self.can_propose_asset),
                bootstrap_finished: ::core::clone::Clone::clone(
                    &self.bootstrap_finished,
                ),
                propose_market_enabled: ::core::clone::Clone::clone(
                    &self.propose_market_enabled,
                ),
                propose_asset_enabled: ::core::clone::Clone::clone(
                    &self.propose_asset_enabled,
                ),
                bootstrap_block_count: ::core::clone::Clone::clone(
                    &self.bootstrap_block_count,
                ),
                genesis_loaded: ::core::clone::Clone::clone(&self.genesis_loaded),
                propose_market_enabled_from: ::core::clone::Clone::clone(
                    &self.propose_market_enabled_from,
                ),
                propose_asset_enabled_from: ::core::clone::Clone::clone(
                    &self.propose_asset_enabled_from,
                ),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for NetworkLimits {
        #[inline]
        fn default() -> NetworkLimits {
            NetworkLimits {
                can_propose_market: ::core::default::Default::default(),
                can_propose_asset: ::core::default::Default::default(),
                bootstrap_finished: ::core::default::Default::default(),
                propose_market_enabled: ::core::default::Default::default(),
                propose_asset_enabled: ::core::default::Default::default(),
                bootstrap_block_count: ::core::default::Default::default(),
                genesis_loaded: ::core::default::Default::default(),
                propose_market_enabled_from: ::core::default::Default::default(),
                propose_asset_enabled_from: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for NetworkLimits {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "can_propose_market",
                "can_propose_asset",
                "bootstrap_finished",
                "propose_market_enabled",
                "propose_asset_enabled",
                "bootstrap_block_count",
                "genesis_loaded",
                "propose_market_enabled_from",
                "propose_asset_enabled_from",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.can_propose_market,
                &&self.can_propose_asset,
                &&self.bootstrap_finished,
                &&self.propose_market_enabled,
                &&self.propose_asset_enabled,
                &&self.bootstrap_block_count,
                &&self.genesis_loaded,
                &&self.propose_market_enabled_from,
                &&self.propose_asset_enabled_from,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "NetworkLimits",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a NetworkLimits {
        fn default() -> &'a NetworkLimits {
            <NetworkLimits as ::protobuf::Message>::default_instance()
        }
    }
    impl NetworkLimits {
        pub fn new() -> NetworkLimits {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "can_propose_market",
                        |m: &NetworkLimits| { &m.can_propose_market },
                        |m: &mut NetworkLimits| { &mut m.can_propose_market },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "can_propose_asset",
                        |m: &NetworkLimits| { &m.can_propose_asset },
                        |m: &mut NetworkLimits| { &mut m.can_propose_asset },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "bootstrap_finished",
                        |m: &NetworkLimits| { &m.bootstrap_finished },
                        |m: &mut NetworkLimits| { &mut m.bootstrap_finished },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "propose_market_enabled",
                        |m: &NetworkLimits| { &m.propose_market_enabled },
                        |m: &mut NetworkLimits| { &mut m.propose_market_enabled },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "propose_asset_enabled",
                        |m: &NetworkLimits| { &m.propose_asset_enabled },
                        |m: &mut NetworkLimits| { &mut m.propose_asset_enabled },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "bootstrap_block_count",
                        |m: &NetworkLimits| { &m.bootstrap_block_count },
                        |m: &mut NetworkLimits| { &mut m.bootstrap_block_count },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "genesis_loaded",
                        |m: &NetworkLimits| { &m.genesis_loaded },
                        |m: &mut NetworkLimits| { &mut m.genesis_loaded },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "propose_market_enabled_from",
                        |m: &NetworkLimits| { &m.propose_market_enabled_from },
                        |m: &mut NetworkLimits| { &mut m.propose_market_enabled_from },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "propose_asset_enabled_from",
                        |m: &NetworkLimits| { &m.propose_asset_enabled_from },
                        |m: &mut NetworkLimits| { &mut m.propose_asset_enabled_from },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                NetworkLimits,
            >("NetworkLimits", fields, oneofs)
        }
    }
    impl ::protobuf::Message for NetworkLimits {
        const NAME: &'static str = "NetworkLimits";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.can_propose_market = is.read_bool()?;
                    }
                    16 => {
                        self.can_propose_asset = is.read_bool()?;
                    }
                    24 => {
                        self.bootstrap_finished = is.read_bool()?;
                    }
                    32 => {
                        self.propose_market_enabled = is.read_bool()?;
                    }
                    40 => {
                        self.propose_asset_enabled = is.read_bool()?;
                    }
                    48 => {
                        self.bootstrap_block_count = is.read_uint32()?;
                    }
                    56 => {
                        self.genesis_loaded = is.read_bool()?;
                    }
                    64 => {
                        self.propose_market_enabled_from = is.read_int64()?;
                    }
                    72 => {
                        self.propose_asset_enabled_from = is.read_int64()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.can_propose_market != false {
                my_size += 1 + 1;
            }
            if self.can_propose_asset != false {
                my_size += 1 + 1;
            }
            if self.bootstrap_finished != false {
                my_size += 1 + 1;
            }
            if self.propose_market_enabled != false {
                my_size += 1 + 1;
            }
            if self.propose_asset_enabled != false {
                my_size += 1 + 1;
            }
            if self.bootstrap_block_count != 0 {
                my_size += ::protobuf::rt::uint32_size(6, self.bootstrap_block_count);
            }
            if self.genesis_loaded != false {
                my_size += 1 + 1;
            }
            if self.propose_market_enabled_from != 0 {
                my_size
                    += ::protobuf::rt::int64_size(8, self.propose_market_enabled_from);
            }
            if self.propose_asset_enabled_from != 0 {
                my_size
                    += ::protobuf::rt::int64_size(9, self.propose_asset_enabled_from);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if self.can_propose_market != false {
                os.write_bool(1, self.can_propose_market)?;
            }
            if self.can_propose_asset != false {
                os.write_bool(2, self.can_propose_asset)?;
            }
            if self.bootstrap_finished != false {
                os.write_bool(3, self.bootstrap_finished)?;
            }
            if self.propose_market_enabled != false {
                os.write_bool(4, self.propose_market_enabled)?;
            }
            if self.propose_asset_enabled != false {
                os.write_bool(5, self.propose_asset_enabled)?;
            }
            if self.bootstrap_block_count != 0 {
                os.write_uint32(6, self.bootstrap_block_count)?;
            }
            if self.genesis_loaded != false {
                os.write_bool(7, self.genesis_loaded)?;
            }
            if self.propose_market_enabled_from != 0 {
                os.write_int64(8, self.propose_market_enabled_from)?;
            }
            if self.propose_asset_enabled_from != 0 {
                os.write_int64(9, self.propose_asset_enabled_from)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> NetworkLimits {
            NetworkLimits::new()
        }
        fn clear(&mut self) {
            self.can_propose_market = false;
            self.can_propose_asset = false;
            self.bootstrap_finished = false;
            self.propose_market_enabled = false;
            self.propose_asset_enabled = false;
            self.bootstrap_block_count = 0;
            self.genesis_loaded = false;
            self.propose_market_enabled_from = 0;
            self.propose_asset_enabled_from = 0;
            self.special_fields.clear();
        }
        fn default_instance() -> &'static NetworkLimits {
            static instance: NetworkLimits = NetworkLimits {
                can_propose_market: false,
                can_propose_asset: false,
                bootstrap_finished: false,
                propose_market_enabled: false,
                propose_asset_enabled: false,
                bootstrap_block_count: 0,
                genesis_loaded: false,
                propose_market_enabled_from: 0,
                propose_asset_enabled_from: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for NetworkLimits {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("NetworkLimits")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for NetworkLimits {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for NetworkLimits {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct LiquidityOrder {
        pub reference: ::protobuf::EnumOrUnknown<PeggedReference>,
        pub proportion: u32,
        pub offset: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LiquidityOrder {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LiquidityOrder {
        #[inline]
        fn eq(&self, other: &LiquidityOrder) -> bool {
            self.reference == other.reference && self.proportion == other.proportion
                && self.offset == other.offset
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LiquidityOrder {
        #[inline]
        fn clone(&self) -> LiquidityOrder {
            LiquidityOrder {
                reference: ::core::clone::Clone::clone(&self.reference),
                proportion: ::core::clone::Clone::clone(&self.proportion),
                offset: ::core::clone::Clone::clone(&self.offset),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for LiquidityOrder {
        #[inline]
        fn default() -> LiquidityOrder {
            LiquidityOrder {
                reference: ::core::default::Default::default(),
                proportion: ::core::default::Default::default(),
                offset: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LiquidityOrder {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "LiquidityOrder",
                "reference",
                &&self.reference,
                "proportion",
                &&self.proportion,
                "offset",
                &&self.offset,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a LiquidityOrder {
        fn default() -> &'a LiquidityOrder {
            <LiquidityOrder as ::protobuf::Message>::default_instance()
        }
    }
    impl LiquidityOrder {
        pub fn new() -> LiquidityOrder {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "reference",
                        |m: &LiquidityOrder| { &m.reference },
                        |m: &mut LiquidityOrder| { &mut m.reference },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "proportion",
                        |m: &LiquidityOrder| { &m.proportion },
                        |m: &mut LiquidityOrder| { &mut m.proportion },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "offset",
                        |m: &LiquidityOrder| { &m.offset },
                        |m: &mut LiquidityOrder| { &mut m.offset },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                LiquidityOrder,
            >("LiquidityOrder", fields, oneofs)
        }
    }
    impl ::protobuf::Message for LiquidityOrder {
        const NAME: &'static str = "LiquidityOrder";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.reference = is.read_enum_or_unknown()?;
                    }
                    16 => {
                        self.proportion = is.read_uint32()?;
                    }
                    26 => {
                        self.offset = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.reference
                != ::protobuf::EnumOrUnknown::new(
                    PeggedReference::PEGGED_REFERENCE_UNSPECIFIED,
                )
            {
                my_size += ::protobuf::rt::int32_size(1, self.reference.value());
            }
            if self.proportion != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.proportion);
            }
            if !self.offset.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.offset);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if self.reference
                != ::protobuf::EnumOrUnknown::new(
                    PeggedReference::PEGGED_REFERENCE_UNSPECIFIED,
                )
            {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.reference))?;
            }
            if self.proportion != 0 {
                os.write_uint32(2, self.proportion)?;
            }
            if !self.offset.is_empty() {
                os.write_string(3, &self.offset)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> LiquidityOrder {
            LiquidityOrder::new()
        }
        fn clear(&mut self) {
            self
                .reference = ::protobuf::EnumOrUnknown::new(
                PeggedReference::PEGGED_REFERENCE_UNSPECIFIED,
            );
            self.proportion = 0;
            self.offset.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static LiquidityOrder {
            static instance: LiquidityOrder = LiquidityOrder {
                reference: ::protobuf::EnumOrUnknown::from_i32(0),
                proportion: 0,
                offset: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for LiquidityOrder {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("LiquidityOrder")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for LiquidityOrder {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for LiquidityOrder {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct LiquidityOrderReference {
        pub order_id: ::std::string::String,
        pub liquidity_order: ::protobuf::MessageField<LiquidityOrder>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LiquidityOrderReference {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LiquidityOrderReference {
        #[inline]
        fn eq(&self, other: &LiquidityOrderReference) -> bool {
            self.order_id == other.order_id
                && self.liquidity_order == other.liquidity_order
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LiquidityOrderReference {
        #[inline]
        fn clone(&self) -> LiquidityOrderReference {
            LiquidityOrderReference {
                order_id: ::core::clone::Clone::clone(&self.order_id),
                liquidity_order: ::core::clone::Clone::clone(&self.liquidity_order),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for LiquidityOrderReference {
        #[inline]
        fn default() -> LiquidityOrderReference {
            LiquidityOrderReference {
                order_id: ::core::default::Default::default(),
                liquidity_order: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LiquidityOrderReference {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "LiquidityOrderReference",
                "order_id",
                &&self.order_id,
                "liquidity_order",
                &&self.liquidity_order,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a LiquidityOrderReference {
        fn default() -> &'a LiquidityOrderReference {
            <LiquidityOrderReference as ::protobuf::Message>::default_instance()
        }
    }
    impl LiquidityOrderReference {
        pub fn new() -> LiquidityOrderReference {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "order_id",
                        |m: &LiquidityOrderReference| { &m.order_id },
                        |m: &mut LiquidityOrderReference| { &mut m.order_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        LiquidityOrder,
                    >(
                        "liquidity_order",
                        |m: &LiquidityOrderReference| { &m.liquidity_order },
                        |m: &mut LiquidityOrderReference| { &mut m.liquidity_order },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                LiquidityOrderReference,
            >("LiquidityOrderReference", fields, oneofs)
        }
    }
    impl ::protobuf::Message for LiquidityOrderReference {
        const NAME: &'static str = "LiquidityOrderReference";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.order_id = is.read_string()?;
                    }
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.liquidity_order,
                        )?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.order_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.order_id);
            }
            if let Some(v) = self.liquidity_order.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.order_id.is_empty() {
                os.write_string(1, &self.order_id)?;
            }
            if let Some(v) = self.liquidity_order.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> LiquidityOrderReference {
            LiquidityOrderReference::new()
        }
        fn clear(&mut self) {
            self.order_id.clear();
            self.liquidity_order.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static LiquidityOrderReference {
            static instance: LiquidityOrderReference = LiquidityOrderReference {
                order_id: ::std::string::String::new(),
                liquidity_order: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for LiquidityOrderReference {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("LiquidityOrderReference")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for LiquidityOrderReference {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for LiquidityOrderReference {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct LiquidityProvision {
        pub id: ::std::string::String,
        pub party_id: ::std::string::String,
        pub created_at: i64,
        pub updated_at: i64,
        pub market_id: ::std::string::String,
        pub commitment_amount: ::std::string::String,
        pub fee: ::std::string::String,
        pub sells: ::std::vec::Vec<LiquidityOrderReference>,
        pub buys: ::std::vec::Vec<LiquidityOrderReference>,
        pub version: u64,
        pub status: ::protobuf::EnumOrUnknown<liquidity_provision::Status>,
        pub reference: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LiquidityProvision {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LiquidityProvision {
        #[inline]
        fn eq(&self, other: &LiquidityProvision) -> bool {
            self.id == other.id && self.party_id == other.party_id
                && self.created_at == other.created_at
                && self.updated_at == other.updated_at
                && self.market_id == other.market_id
                && self.commitment_amount == other.commitment_amount
                && self.fee == other.fee && self.sells == other.sells
                && self.buys == other.buys && self.version == other.version
                && self.status == other.status && self.reference == other.reference
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LiquidityProvision {
        #[inline]
        fn clone(&self) -> LiquidityProvision {
            LiquidityProvision {
                id: ::core::clone::Clone::clone(&self.id),
                party_id: ::core::clone::Clone::clone(&self.party_id),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                updated_at: ::core::clone::Clone::clone(&self.updated_at),
                market_id: ::core::clone::Clone::clone(&self.market_id),
                commitment_amount: ::core::clone::Clone::clone(&self.commitment_amount),
                fee: ::core::clone::Clone::clone(&self.fee),
                sells: ::core::clone::Clone::clone(&self.sells),
                buys: ::core::clone::Clone::clone(&self.buys),
                version: ::core::clone::Clone::clone(&self.version),
                status: ::core::clone::Clone::clone(&self.status),
                reference: ::core::clone::Clone::clone(&self.reference),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for LiquidityProvision {
        #[inline]
        fn default() -> LiquidityProvision {
            LiquidityProvision {
                id: ::core::default::Default::default(),
                party_id: ::core::default::Default::default(),
                created_at: ::core::default::Default::default(),
                updated_at: ::core::default::Default::default(),
                market_id: ::core::default::Default::default(),
                commitment_amount: ::core::default::Default::default(),
                fee: ::core::default::Default::default(),
                sells: ::core::default::Default::default(),
                buys: ::core::default::Default::default(),
                version: ::core::default::Default::default(),
                status: ::core::default::Default::default(),
                reference: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LiquidityProvision {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "party_id",
                "created_at",
                "updated_at",
                "market_id",
                "commitment_amount",
                "fee",
                "sells",
                "buys",
                "version",
                "status",
                "reference",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.id,
                &&self.party_id,
                &&self.created_at,
                &&self.updated_at,
                &&self.market_id,
                &&self.commitment_amount,
                &&self.fee,
                &&self.sells,
                &&self.buys,
                &&self.version,
                &&self.status,
                &&self.reference,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "LiquidityProvision",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a LiquidityProvision {
        fn default() -> &'a LiquidityProvision {
            <LiquidityProvision as ::protobuf::Message>::default_instance()
        }
    }
    impl LiquidityProvision {
        pub fn new() -> LiquidityProvision {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(12);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "id",
                        |m: &LiquidityProvision| { &m.id },
                        |m: &mut LiquidityProvision| { &mut m.id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "party_id",
                        |m: &LiquidityProvision| { &m.party_id },
                        |m: &mut LiquidityProvision| { &mut m.party_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "created_at",
                        |m: &LiquidityProvision| { &m.created_at },
                        |m: &mut LiquidityProvision| { &mut m.created_at },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "updated_at",
                        |m: &LiquidityProvision| { &m.updated_at },
                        |m: &mut LiquidityProvision| { &mut m.updated_at },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "market_id",
                        |m: &LiquidityProvision| { &m.market_id },
                        |m: &mut LiquidityProvision| { &mut m.market_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "commitment_amount",
                        |m: &LiquidityProvision| { &m.commitment_amount },
                        |m: &mut LiquidityProvision| { &mut m.commitment_amount },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "fee",
                        |m: &LiquidityProvision| { &m.fee },
                        |m: &mut LiquidityProvision| { &mut m.fee },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "sells",
                        |m: &LiquidityProvision| { &m.sells },
                        |m: &mut LiquidityProvision| { &mut m.sells },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "buys",
                        |m: &LiquidityProvision| { &m.buys },
                        |m: &mut LiquidityProvision| { &mut m.buys },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "version",
                        |m: &LiquidityProvision| { &m.version },
                        |m: &mut LiquidityProvision| { &mut m.version },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "status",
                        |m: &LiquidityProvision| { &m.status },
                        |m: &mut LiquidityProvision| { &mut m.status },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "reference",
                        |m: &LiquidityProvision| { &m.reference },
                        |m: &mut LiquidityProvision| { &mut m.reference },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                LiquidityProvision,
            >("LiquidityProvision", fields, oneofs)
        }
    }
    impl ::protobuf::Message for LiquidityProvision {
        const NAME: &'static str = "LiquidityProvision";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.id = is.read_string()?;
                    }
                    18 => {
                        self.party_id = is.read_string()?;
                    }
                    24 => {
                        self.created_at = is.read_int64()?;
                    }
                    32 => {
                        self.updated_at = is.read_int64()?;
                    }
                    42 => {
                        self.market_id = is.read_string()?;
                    }
                    50 => {
                        self.commitment_amount = is.read_string()?;
                    }
                    58 => {
                        self.fee = is.read_string()?;
                    }
                    66 => {
                        self.sells.push(is.read_message()?);
                    }
                    74 => {
                        self.buys.push(is.read_message()?);
                    }
                    80 => {
                        self.version = is.read_uint64()?;
                    }
                    88 => {
                        self.status = is.read_enum_or_unknown()?;
                    }
                    98 => {
                        self.reference = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.id);
            }
            if !self.party_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.party_id);
            }
            if self.created_at != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.created_at);
            }
            if self.updated_at != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.updated_at);
            }
            if !self.market_id.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.market_id);
            }
            if !self.commitment_amount.is_empty() {
                my_size += ::protobuf::rt::string_size(6, &self.commitment_amount);
            }
            if !self.fee.is_empty() {
                my_size += ::protobuf::rt::string_size(7, &self.fee);
            }
            for value in &self.sells {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.buys {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.version != 0 {
                my_size += ::protobuf::rt::uint64_size(10, self.version);
            }
            if self.status
                != ::protobuf::EnumOrUnknown::new(
                    liquidity_provision::Status::STATUS_UNSPECIFIED,
                )
            {
                my_size += ::protobuf::rt::int32_size(11, self.status.value());
            }
            if !self.reference.is_empty() {
                my_size += ::protobuf::rt::string_size(12, &self.reference);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.id.is_empty() {
                os.write_string(1, &self.id)?;
            }
            if !self.party_id.is_empty() {
                os.write_string(2, &self.party_id)?;
            }
            if self.created_at != 0 {
                os.write_int64(3, self.created_at)?;
            }
            if self.updated_at != 0 {
                os.write_int64(4, self.updated_at)?;
            }
            if !self.market_id.is_empty() {
                os.write_string(5, &self.market_id)?;
            }
            if !self.commitment_amount.is_empty() {
                os.write_string(6, &self.commitment_amount)?;
            }
            if !self.fee.is_empty() {
                os.write_string(7, &self.fee)?;
            }
            for v in &self.sells {
                ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            }
            for v in &self.buys {
                ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
            }
            if self.version != 0 {
                os.write_uint64(10, self.version)?;
            }
            if self.status
                != ::protobuf::EnumOrUnknown::new(
                    liquidity_provision::Status::STATUS_UNSPECIFIED,
                )
            {
                os.write_enum(11, ::protobuf::EnumOrUnknown::value(&self.status))?;
            }
            if !self.reference.is_empty() {
                os.write_string(12, &self.reference)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> LiquidityProvision {
            LiquidityProvision::new()
        }
        fn clear(&mut self) {
            self.id.clear();
            self.party_id.clear();
            self.created_at = 0;
            self.updated_at = 0;
            self.market_id.clear();
            self.commitment_amount.clear();
            self.fee.clear();
            self.sells.clear();
            self.buys.clear();
            self.version = 0;
            self
                .status = ::protobuf::EnumOrUnknown::new(
                liquidity_provision::Status::STATUS_UNSPECIFIED,
            );
            self.reference.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static LiquidityProvision {
            static instance: LiquidityProvision = LiquidityProvision {
                id: ::std::string::String::new(),
                party_id: ::std::string::String::new(),
                created_at: 0,
                updated_at: 0,
                market_id: ::std::string::String::new(),
                commitment_amount: ::std::string::String::new(),
                fee: ::std::string::String::new(),
                sells: ::std::vec::Vec::new(),
                buys: ::std::vec::Vec::new(),
                version: 0,
                status: ::protobuf::EnumOrUnknown::from_i32(0),
                reference: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for LiquidityProvision {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("LiquidityProvision")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for LiquidityProvision {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for LiquidityProvision {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    /// Nested message and enums of message `LiquidityProvision`
    pub mod liquidity_provision {
        #[postgres(name = "transfer_type")]
        pub enum Status {
            STATUS_UNSPECIFIED = 0,
            STATUS_ACTIVE = 1,
            STATUS_STOPPED = 2,
            STATUS_CANCELLED = 3,
            STATUS_REJECTED = 4,
            STATUS_UNDEPLOYED = 5,
            STATUS_PENDING = 6,
        }
        impl<'a> postgres_types::FromSql<'a> for Status {
            fn from_sql(
                _type: &postgres_types::Type,
                buf: &'a [u8],
            ) -> std::result::Result<
                Status,
                std::boxed::Box<
                    dyn std::error::Error + std::marker::Sync + std::marker::Send,
                >,
            > {
                match std::str::from_utf8(buf)? {
                    "STATUS_UNSPECIFIED" => {
                        std::result::Result::Ok(Status::STATUS_UNSPECIFIED)
                    }
                    "STATUS_ACTIVE" => std::result::Result::Ok(Status::STATUS_ACTIVE),
                    "STATUS_STOPPED" => std::result::Result::Ok(Status::STATUS_STOPPED),
                    "STATUS_CANCELLED" => {
                        std::result::Result::Ok(Status::STATUS_CANCELLED)
                    }
                    "STATUS_REJECTED" => std::result::Result::Ok(Status::STATUS_REJECTED),
                    "STATUS_UNDEPLOYED" => {
                        std::result::Result::Ok(Status::STATUS_UNDEPLOYED)
                    }
                    "STATUS_PENDING" => std::result::Result::Ok(Status::STATUS_PENDING),
                    s => {
                        std::result::Result::Err(
                            std::convert::Into::into({
                                let res = ::alloc::fmt::format(
                                    ::core::fmt::Arguments::new_v1(
                                        &["invalid variant `", "`"],
                                        &[::core::fmt::ArgumentV1::new_display(&s)],
                                    ),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            fn accepts(type_: &postgres_types::Type) -> bool {
                if type_.name() != "transfer_type" {
                    return false;
                }
                match *type_.kind() {
                    ::postgres_types::Kind::Enum(ref variants) => {
                        if variants.len() != 7usize {
                            return false;
                        }
                        variants
                            .iter()
                            .all(|v| {
                                match &**v {
                                    "STATUS_UNSPECIFIED" => true,
                                    "STATUS_ACTIVE" => true,
                                    "STATUS_STOPPED" => true,
                                    "STATUS_CANCELLED" => true,
                                    "STATUS_REJECTED" => true,
                                    "STATUS_UNDEPLOYED" => true,
                                    "STATUS_PENDING" => true,
                                    _ => false,
                                }
                            })
                    }
                    _ => false,
                }
            }
        }
        impl postgres_types::ToSql for Status {
            fn to_sql(
                &self,
                _type: &postgres_types::Type,
                buf: &mut postgres_types::private::BytesMut,
            ) -> std::result::Result<
                postgres_types::IsNull,
                std::boxed::Box<
                    dyn std::error::Error + std::marker::Sync + std::marker::Send,
                >,
            > {
                let s = match *self {
                    Status::STATUS_UNSPECIFIED => "STATUS_UNSPECIFIED",
                    Status::STATUS_ACTIVE => "STATUS_ACTIVE",
                    Status::STATUS_STOPPED => "STATUS_STOPPED",
                    Status::STATUS_CANCELLED => "STATUS_CANCELLED",
                    Status::STATUS_REJECTED => "STATUS_REJECTED",
                    Status::STATUS_UNDEPLOYED => "STATUS_UNDEPLOYED",
                    Status::STATUS_PENDING => "STATUS_PENDING",
                };
                buf.extend_from_slice(s.as_bytes());
                std::result::Result::Ok(postgres_types::IsNull::No)
            }
            fn accepts(type_: &postgres_types::Type) -> bool {
                if type_.name() != "transfer_type" {
                    return false;
                }
                match *type_.kind() {
                    ::postgres_types::Kind::Enum(ref variants) => {
                        if variants.len() != 7usize {
                            return false;
                        }
                        variants
                            .iter()
                            .all(|v| {
                                match &**v {
                                    "STATUS_UNSPECIFIED" => true,
                                    "STATUS_ACTIVE" => true,
                                    "STATUS_STOPPED" => true,
                                    "STATUS_CANCELLED" => true,
                                    "STATUS_REJECTED" => true,
                                    "STATUS_UNDEPLOYED" => true,
                                    "STATUS_PENDING" => true,
                                    _ => false,
                                }
                            })
                    }
                    _ => false,
                }
            }
            fn to_sql_checked(
                &self,
                ty: &::postgres_types::Type,
                out: &mut ::postgres_types::private::BytesMut,
            ) -> ::std::result::Result<
                ::postgres_types::IsNull,
                Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
            > {
                ::postgres_types::__to_sql_checked(self, ty, out)
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Status {
            #[inline]
            fn clone(&self) -> Status {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Status {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Status {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Status {
            #[inline]
            fn eq(&self, other: &Status) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Status {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Status {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Status {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Status::STATUS_UNSPECIFIED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_UNSPECIFIED")
                    }
                    Status::STATUS_ACTIVE => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_ACTIVE")
                    }
                    Status::STATUS_STOPPED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_STOPPED")
                    }
                    Status::STATUS_CANCELLED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_CANCELLED")
                    }
                    Status::STATUS_REJECTED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_REJECTED")
                    }
                    Status::STATUS_UNDEPLOYED => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_UNDEPLOYED")
                    }
                    Status::STATUS_PENDING => {
                        ::core::fmt::Formatter::write_str(f, "STATUS_PENDING")
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Status {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state)
            }
        }
        impl ::protobuf::Enum for Status {
            const NAME: &'static str = "Status";
            fn value(&self) -> i32 {
                *self as i32
            }
            fn from_i32(value: i32) -> ::std::option::Option<Status> {
                match value {
                    0 => ::std::option::Option::Some(Status::STATUS_UNSPECIFIED),
                    1 => ::std::option::Option::Some(Status::STATUS_ACTIVE),
                    2 => ::std::option::Option::Some(Status::STATUS_STOPPED),
                    3 => ::std::option::Option::Some(Status::STATUS_CANCELLED),
                    4 => ::std::option::Option::Some(Status::STATUS_REJECTED),
                    5 => ::std::option::Option::Some(Status::STATUS_UNDEPLOYED),
                    6 => ::std::option::Option::Some(Status::STATUS_PENDING),
                    _ => ::std::option::Option::None,
                }
            }
            const VALUES: &'static [Status] = &[
                Status::STATUS_UNSPECIFIED,
                Status::STATUS_ACTIVE,
                Status::STATUS_STOPPED,
                Status::STATUS_CANCELLED,
                Status::STATUS_REJECTED,
                Status::STATUS_UNDEPLOYED,
                Status::STATUS_PENDING,
            ];
        }
        impl ::protobuf::EnumFull for Status {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<
                    ::protobuf::reflect::EnumDescriptor,
                > = ::protobuf::rt::Lazy::new();
                descriptor
                    .get(|| {
                        super::file_descriptor()
                            .enum_by_package_relative_name("LiquidityProvision.Status")
                            .unwrap()
                    })
                    .clone()
            }
            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }
        impl ::std::default::Default for Status {
            fn default() -> Self {
                Status::STATUS_UNSPECIFIED
            }
        }
        impl Status {
            pub(super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<
                    Status,
                >("LiquidityProvision.Status")
            }
        }
    }
    pub struct EthereumConfig {
        pub network_id: ::std::string::String,
        pub chain_id: ::std::string::String,
        pub collateral_bridge_contract: ::protobuf::MessageField<EthereumContractConfig>,
        pub confirmations: u32,
        pub staking_bridge_contract: ::protobuf::MessageField<EthereumContractConfig>,
        pub token_vesting_contract: ::protobuf::MessageField<EthereumContractConfig>,
        pub multisig_control_contract: ::protobuf::MessageField<EthereumContractConfig>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EthereumConfig {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EthereumConfig {
        #[inline]
        fn eq(&self, other: &EthereumConfig) -> bool {
            self.network_id == other.network_id && self.chain_id == other.chain_id
                && self.collateral_bridge_contract == other.collateral_bridge_contract
                && self.confirmations == other.confirmations
                && self.staking_bridge_contract == other.staking_bridge_contract
                && self.token_vesting_contract == other.token_vesting_contract
                && self.multisig_control_contract == other.multisig_control_contract
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EthereumConfig {
        #[inline]
        fn clone(&self) -> EthereumConfig {
            EthereumConfig {
                network_id: ::core::clone::Clone::clone(&self.network_id),
                chain_id: ::core::clone::Clone::clone(&self.chain_id),
                collateral_bridge_contract: ::core::clone::Clone::clone(
                    &self.collateral_bridge_contract,
                ),
                confirmations: ::core::clone::Clone::clone(&self.confirmations),
                staking_bridge_contract: ::core::clone::Clone::clone(
                    &self.staking_bridge_contract,
                ),
                token_vesting_contract: ::core::clone::Clone::clone(
                    &self.token_vesting_contract,
                ),
                multisig_control_contract: ::core::clone::Clone::clone(
                    &self.multisig_control_contract,
                ),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for EthereumConfig {
        #[inline]
        fn default() -> EthereumConfig {
            EthereumConfig {
                network_id: ::core::default::Default::default(),
                chain_id: ::core::default::Default::default(),
                collateral_bridge_contract: ::core::default::Default::default(),
                confirmations: ::core::default::Default::default(),
                staking_bridge_contract: ::core::default::Default::default(),
                token_vesting_contract: ::core::default::Default::default(),
                multisig_control_contract: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EthereumConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "network_id",
                "chain_id",
                "collateral_bridge_contract",
                "confirmations",
                "staking_bridge_contract",
                "token_vesting_contract",
                "multisig_control_contract",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.network_id,
                &&self.chain_id,
                &&self.collateral_bridge_contract,
                &&self.confirmations,
                &&self.staking_bridge_contract,
                &&self.token_vesting_contract,
                &&self.multisig_control_contract,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "EthereumConfig",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a EthereumConfig {
        fn default() -> &'a EthereumConfig {
            <EthereumConfig as ::protobuf::Message>::default_instance()
        }
    }
    impl EthereumConfig {
        pub fn new() -> EthereumConfig {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "network_id",
                        |m: &EthereumConfig| { &m.network_id },
                        |m: &mut EthereumConfig| { &mut m.network_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "chain_id",
                        |m: &EthereumConfig| { &m.chain_id },
                        |m: &mut EthereumConfig| { &mut m.chain_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        EthereumContractConfig,
                    >(
                        "collateral_bridge_contract",
                        |m: &EthereumConfig| { &m.collateral_bridge_contract },
                        |m: &mut EthereumConfig| { &mut m.collateral_bridge_contract },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "confirmations",
                        |m: &EthereumConfig| { &m.confirmations },
                        |m: &mut EthereumConfig| { &mut m.confirmations },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        EthereumContractConfig,
                    >(
                        "staking_bridge_contract",
                        |m: &EthereumConfig| { &m.staking_bridge_contract },
                        |m: &mut EthereumConfig| { &mut m.staking_bridge_contract },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        EthereumContractConfig,
                    >(
                        "token_vesting_contract",
                        |m: &EthereumConfig| { &m.token_vesting_contract },
                        |m: &mut EthereumConfig| { &mut m.token_vesting_contract },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        EthereumContractConfig,
                    >(
                        "multisig_control_contract",
                        |m: &EthereumConfig| { &m.multisig_control_contract },
                        |m: &mut EthereumConfig| { &mut m.multisig_control_contract },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                EthereumConfig,
            >("EthereumConfig", fields, oneofs)
        }
    }
    impl ::protobuf::Message for EthereumConfig {
        const NAME: &'static str = "EthereumConfig";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.network_id = is.read_string()?;
                    }
                    18 => {
                        self.chain_id = is.read_string()?;
                    }
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.collateral_bridge_contract,
                        )?;
                    }
                    32 => {
                        self.confirmations = is.read_uint32()?;
                    }
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.staking_bridge_contract,
                        )?;
                    }
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.token_vesting_contract,
                        )?;
                    }
                    58 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.multisig_control_contract,
                        )?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.network_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.network_id);
            }
            if !self.chain_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.chain_id);
            }
            if let Some(v) = self.collateral_bridge_contract.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.confirmations != 0 {
                my_size += ::protobuf::rt::uint32_size(4, self.confirmations);
            }
            if let Some(v) = self.staking_bridge_contract.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.token_vesting_contract.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.multisig_control_contract.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.network_id.is_empty() {
                os.write_string(1, &self.network_id)?;
            }
            if !self.chain_id.is_empty() {
                os.write_string(2, &self.chain_id)?;
            }
            if let Some(v) = self.collateral_bridge_contract.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if self.confirmations != 0 {
                os.write_uint32(4, self.confirmations)?;
            }
            if let Some(v) = self.staking_bridge_contract.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.token_vesting_contract.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            if let Some(v) = self.multisig_control_contract.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> EthereumConfig {
            EthereumConfig::new()
        }
        fn clear(&mut self) {
            self.network_id.clear();
            self.chain_id.clear();
            self.collateral_bridge_contract.clear();
            self.confirmations = 0;
            self.staking_bridge_contract.clear();
            self.token_vesting_contract.clear();
            self.multisig_control_contract.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static EthereumConfig {
            static instance: EthereumConfig = EthereumConfig {
                network_id: ::std::string::String::new(),
                chain_id: ::std::string::String::new(),
                collateral_bridge_contract: ::protobuf::MessageField::none(),
                confirmations: 0,
                staking_bridge_contract: ::protobuf::MessageField::none(),
                token_vesting_contract: ::protobuf::MessageField::none(),
                multisig_control_contract: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for EthereumConfig {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("EthereumConfig")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for EthereumConfig {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for EthereumConfig {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct EthereumContractConfig {
        pub address: ::std::string::String,
        pub deployment_block_height: u64,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EthereumContractConfig {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EthereumContractConfig {
        #[inline]
        fn eq(&self, other: &EthereumContractConfig) -> bool {
            self.address == other.address
                && self.deployment_block_height == other.deployment_block_height
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EthereumContractConfig {
        #[inline]
        fn clone(&self) -> EthereumContractConfig {
            EthereumContractConfig {
                address: ::core::clone::Clone::clone(&self.address),
                deployment_block_height: ::core::clone::Clone::clone(
                    &self.deployment_block_height,
                ),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for EthereumContractConfig {
        #[inline]
        fn default() -> EthereumContractConfig {
            EthereumContractConfig {
                address: ::core::default::Default::default(),
                deployment_block_height: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EthereumContractConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "EthereumContractConfig",
                "address",
                &&self.address,
                "deployment_block_height",
                &&self.deployment_block_height,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a EthereumContractConfig {
        fn default() -> &'a EthereumContractConfig {
            <EthereumContractConfig as ::protobuf::Message>::default_instance()
        }
    }
    impl EthereumContractConfig {
        pub fn new() -> EthereumContractConfig {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "address",
                        |m: &EthereumContractConfig| { &m.address },
                        |m: &mut EthereumContractConfig| { &mut m.address },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "deployment_block_height",
                        |m: &EthereumContractConfig| { &m.deployment_block_height },
                        |m: &mut EthereumContractConfig| {
                            &mut m.deployment_block_height
                        },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                EthereumContractConfig,
            >("EthereumContractConfig", fields, oneofs)
        }
    }
    impl ::protobuf::Message for EthereumContractConfig {
        const NAME: &'static str = "EthereumContractConfig";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.address = is.read_string()?;
                    }
                    48 => {
                        self.deployment_block_height = is.read_uint64()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.address.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.address);
            }
            if self.deployment_block_height != 0 {
                my_size += ::protobuf::rt::uint64_size(6, self.deployment_block_height);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.address.is_empty() {
                os.write_string(1, &self.address)?;
            }
            if self.deployment_block_height != 0 {
                os.write_uint64(6, self.deployment_block_height)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> EthereumContractConfig {
            EthereumContractConfig::new()
        }
        fn clear(&mut self) {
            self.address.clear();
            self.deployment_block_height = 0;
            self.special_fields.clear();
        }
        fn default_instance() -> &'static EthereumContractConfig {
            static instance: EthereumContractConfig = EthereumContractConfig {
                address: ::std::string::String::new(),
                deployment_block_height: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for EthereumContractConfig {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("EthereumContractConfig")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for EthereumContractConfig {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for EthereumContractConfig {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct EpochTimestamps {
        pub start_time: i64,
        pub expiry_time: i64,
        pub end_time: i64,
        pub first_block: u64,
        pub last_block: u64,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EpochTimestamps {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EpochTimestamps {
        #[inline]
        fn eq(&self, other: &EpochTimestamps) -> bool {
            self.start_time == other.start_time && self.expiry_time == other.expiry_time
                && self.end_time == other.end_time
                && self.first_block == other.first_block
                && self.last_block == other.last_block
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EpochTimestamps {
        #[inline]
        fn clone(&self) -> EpochTimestamps {
            EpochTimestamps {
                start_time: ::core::clone::Clone::clone(&self.start_time),
                expiry_time: ::core::clone::Clone::clone(&self.expiry_time),
                end_time: ::core::clone::Clone::clone(&self.end_time),
                first_block: ::core::clone::Clone::clone(&self.first_block),
                last_block: ::core::clone::Clone::clone(&self.last_block),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for EpochTimestamps {
        #[inline]
        fn default() -> EpochTimestamps {
            EpochTimestamps {
                start_time: ::core::default::Default::default(),
                expiry_time: ::core::default::Default::default(),
                end_time: ::core::default::Default::default(),
                first_block: ::core::default::Default::default(),
                last_block: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EpochTimestamps {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "start_time",
                "expiry_time",
                "end_time",
                "first_block",
                "last_block",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.start_time,
                &&self.expiry_time,
                &&self.end_time,
                &&self.first_block,
                &&self.last_block,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "EpochTimestamps",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a EpochTimestamps {
        fn default() -> &'a EpochTimestamps {
            <EpochTimestamps as ::protobuf::Message>::default_instance()
        }
    }
    impl EpochTimestamps {
        pub fn new() -> EpochTimestamps {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "start_time",
                        |m: &EpochTimestamps| { &m.start_time },
                        |m: &mut EpochTimestamps| { &mut m.start_time },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "expiry_time",
                        |m: &EpochTimestamps| { &m.expiry_time },
                        |m: &mut EpochTimestamps| { &mut m.expiry_time },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "end_time",
                        |m: &EpochTimestamps| { &m.end_time },
                        |m: &mut EpochTimestamps| { &mut m.end_time },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "first_block",
                        |m: &EpochTimestamps| { &m.first_block },
                        |m: &mut EpochTimestamps| { &mut m.first_block },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "last_block",
                        |m: &EpochTimestamps| { &m.last_block },
                        |m: &mut EpochTimestamps| { &mut m.last_block },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                EpochTimestamps,
            >("EpochTimestamps", fields, oneofs)
        }
    }
    impl ::protobuf::Message for EpochTimestamps {
        const NAME: &'static str = "EpochTimestamps";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.start_time = is.read_int64()?;
                    }
                    16 => {
                        self.expiry_time = is.read_int64()?;
                    }
                    24 => {
                        self.end_time = is.read_int64()?;
                    }
                    32 => {
                        self.first_block = is.read_uint64()?;
                    }
                    40 => {
                        self.last_block = is.read_uint64()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.start_time != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.start_time);
            }
            if self.expiry_time != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.expiry_time);
            }
            if self.end_time != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.end_time);
            }
            if self.first_block != 0 {
                my_size += ::protobuf::rt::uint64_size(4, self.first_block);
            }
            if self.last_block != 0 {
                my_size += ::protobuf::rt::uint64_size(5, self.last_block);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if self.start_time != 0 {
                os.write_int64(1, self.start_time)?;
            }
            if self.expiry_time != 0 {
                os.write_int64(2, self.expiry_time)?;
            }
            if self.end_time != 0 {
                os.write_int64(3, self.end_time)?;
            }
            if self.first_block != 0 {
                os.write_uint64(4, self.first_block)?;
            }
            if self.last_block != 0 {
                os.write_uint64(5, self.last_block)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> EpochTimestamps {
            EpochTimestamps::new()
        }
        fn clear(&mut self) {
            self.start_time = 0;
            self.expiry_time = 0;
            self.end_time = 0;
            self.first_block = 0;
            self.last_block = 0;
            self.special_fields.clear();
        }
        fn default_instance() -> &'static EpochTimestamps {
            static instance: EpochTimestamps = EpochTimestamps {
                start_time: 0,
                expiry_time: 0,
                end_time: 0,
                first_block: 0,
                last_block: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for EpochTimestamps {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("EpochTimestamps")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for EpochTimestamps {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for EpochTimestamps {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct Epoch {
        pub seq: u64,
        pub timestamps: ::protobuf::MessageField<EpochTimestamps>,
        pub validators: ::std::vec::Vec<Node>,
        pub delegations: ::std::vec::Vec<Delegation>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Epoch {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Epoch {
        #[inline]
        fn eq(&self, other: &Epoch) -> bool {
            self.seq == other.seq && self.timestamps == other.timestamps
                && self.validators == other.validators
                && self.delegations == other.delegations
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Epoch {
        #[inline]
        fn clone(&self) -> Epoch {
            Epoch {
                seq: ::core::clone::Clone::clone(&self.seq),
                timestamps: ::core::clone::Clone::clone(&self.timestamps),
                validators: ::core::clone::Clone::clone(&self.validators),
                delegations: ::core::clone::Clone::clone(&self.delegations),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Epoch {
        #[inline]
        fn default() -> Epoch {
            Epoch {
                seq: ::core::default::Default::default(),
                timestamps: ::core::default::Default::default(),
                validators: ::core::default::Default::default(),
                delegations: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Epoch {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "Epoch",
                "seq",
                &&self.seq,
                "timestamps",
                &&self.timestamps,
                "validators",
                &&self.validators,
                "delegations",
                &&self.delegations,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a Epoch {
        fn default() -> &'a Epoch {
            <Epoch as ::protobuf::Message>::default_instance()
        }
    }
    impl Epoch {
        pub fn new() -> Epoch {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >("seq", |m: &Epoch| { &m.seq }, |m: &mut Epoch| { &mut m.seq }),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        EpochTimestamps,
                    >(
                        "timestamps",
                        |m: &Epoch| { &m.timestamps },
                        |m: &mut Epoch| { &mut m.timestamps },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "validators",
                        |m: &Epoch| { &m.validators },
                        |m: &mut Epoch| { &mut m.validators },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "delegations",
                        |m: &Epoch| { &m.delegations },
                        |m: &mut Epoch| { &mut m.delegations },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                Epoch,
            >("Epoch", fields, oneofs)
        }
    }
    impl ::protobuf::Message for Epoch {
        const NAME: &'static str = "Epoch";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.seq = is.read_uint64()?;
                    }
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.timestamps,
                        )?;
                    }
                    26 => {
                        self.validators.push(is.read_message()?);
                    }
                    34 => {
                        self.delegations.push(is.read_message()?);
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.seq != 0 {
                my_size += ::protobuf::rt::uint64_size(1, self.seq);
            }
            if let Some(v) = self.timestamps.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.validators {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.delegations {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if self.seq != 0 {
                os.write_uint64(1, self.seq)?;
            }
            if let Some(v) = self.timestamps.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            for v in &self.validators {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            for v in &self.delegations {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> Epoch {
            Epoch::new()
        }
        fn clear(&mut self) {
            self.seq = 0;
            self.timestamps.clear();
            self.validators.clear();
            self.delegations.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static Epoch {
            static instance: Epoch = Epoch {
                seq: 0,
                timestamps: ::protobuf::MessageField::none(),
                validators: ::std::vec::Vec::new(),
                delegations: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for Epoch {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor().message_by_package_relative_name("Epoch").unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for Epoch {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for Epoch {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct EpochParticipation {
        pub epoch: ::protobuf::MessageField<Epoch>,
        pub offline: u64,
        pub online: u64,
        pub total_rewards: f64,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EpochParticipation {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EpochParticipation {
        #[inline]
        fn eq(&self, other: &EpochParticipation) -> bool {
            self.epoch == other.epoch && self.offline == other.offline
                && self.online == other.online
                && self.total_rewards == other.total_rewards
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EpochParticipation {
        #[inline]
        fn clone(&self) -> EpochParticipation {
            EpochParticipation {
                epoch: ::core::clone::Clone::clone(&self.epoch),
                offline: ::core::clone::Clone::clone(&self.offline),
                online: ::core::clone::Clone::clone(&self.online),
                total_rewards: ::core::clone::Clone::clone(&self.total_rewards),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for EpochParticipation {
        #[inline]
        fn default() -> EpochParticipation {
            EpochParticipation {
                epoch: ::core::default::Default::default(),
                offline: ::core::default::Default::default(),
                online: ::core::default::Default::default(),
                total_rewards: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EpochParticipation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "EpochParticipation",
                "epoch",
                &&self.epoch,
                "offline",
                &&self.offline,
                "online",
                &&self.online,
                "total_rewards",
                &&self.total_rewards,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a EpochParticipation {
        fn default() -> &'a EpochParticipation {
            <EpochParticipation as ::protobuf::Message>::default_instance()
        }
    }
    impl EpochParticipation {
        pub fn new() -> EpochParticipation {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        Epoch,
                    >(
                        "epoch",
                        |m: &EpochParticipation| { &m.epoch },
                        |m: &mut EpochParticipation| { &mut m.epoch },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "offline",
                        |m: &EpochParticipation| { &m.offline },
                        |m: &mut EpochParticipation| { &mut m.offline },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "online",
                        |m: &EpochParticipation| { &m.online },
                        |m: &mut EpochParticipation| { &mut m.online },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "total_rewards",
                        |m: &EpochParticipation| { &m.total_rewards },
                        |m: &mut EpochParticipation| { &mut m.total_rewards },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                EpochParticipation,
            >("EpochParticipation", fields, oneofs)
        }
    }
    impl ::protobuf::Message for EpochParticipation {
        const NAME: &'static str = "EpochParticipation";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.epoch,
                        )?;
                    }
                    16 => {
                        self.offline = is.read_uint64()?;
                    }
                    24 => {
                        self.online = is.read_uint64()?;
                    }
                    33 => {
                        self.total_rewards = is.read_double()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.epoch.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.offline != 0 {
                my_size += ::protobuf::rt::uint64_size(2, self.offline);
            }
            if self.online != 0 {
                my_size += ::protobuf::rt::uint64_size(3, self.online);
            }
            if self.total_rewards != 0. {
                my_size += 1 + 8;
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if let Some(v) = self.epoch.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if self.offline != 0 {
                os.write_uint64(2, self.offline)?;
            }
            if self.online != 0 {
                os.write_uint64(3, self.online)?;
            }
            if self.total_rewards != 0. {
                os.write_double(4, self.total_rewards)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> EpochParticipation {
            EpochParticipation::new()
        }
        fn clear(&mut self) {
            self.epoch.clear();
            self.offline = 0;
            self.online = 0;
            self.total_rewards = 0.;
            self.special_fields.clear();
        }
        fn default_instance() -> &'static EpochParticipation {
            static instance: EpochParticipation = EpochParticipation {
                epoch: ::protobuf::MessageField::none(),
                offline: 0,
                online: 0,
                total_rewards: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for EpochParticipation {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("EpochParticipation")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for EpochParticipation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for EpochParticipation {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct EpochData {
        pub total: i32,
        pub offline: i32,
        pub online: i32,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EpochData {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EpochData {
        #[inline]
        fn eq(&self, other: &EpochData) -> bool {
            self.total == other.total && self.offline == other.offline
                && self.online == other.online
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EpochData {
        #[inline]
        fn clone(&self) -> EpochData {
            EpochData {
                total: ::core::clone::Clone::clone(&self.total),
                offline: ::core::clone::Clone::clone(&self.offline),
                online: ::core::clone::Clone::clone(&self.online),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for EpochData {
        #[inline]
        fn default() -> EpochData {
            EpochData {
                total: ::core::default::Default::default(),
                offline: ::core::default::Default::default(),
                online: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EpochData {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "EpochData",
                "total",
                &&self.total,
                "offline",
                &&self.offline,
                "online",
                &&self.online,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a EpochData {
        fn default() -> &'a EpochData {
            <EpochData as ::protobuf::Message>::default_instance()
        }
    }
    impl EpochData {
        pub fn new() -> EpochData {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "total",
                        |m: &EpochData| { &m.total },
                        |m: &mut EpochData| { &mut m.total },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "offline",
                        |m: &EpochData| { &m.offline },
                        |m: &mut EpochData| { &mut m.offline },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "online",
                        |m: &EpochData| { &m.online },
                        |m: &mut EpochData| { &mut m.online },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                EpochData,
            >("EpochData", fields, oneofs)
        }
    }
    impl ::protobuf::Message for EpochData {
        const NAME: &'static str = "EpochData";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.total = is.read_int32()?;
                    }
                    16 => {
                        self.offline = is.read_int32()?;
                    }
                    24 => {
                        self.online = is.read_int32()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.total != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.total);
            }
            if self.offline != 0 {
                my_size += ::protobuf::rt::int32_size(2, self.offline);
            }
            if self.online != 0 {
                my_size += ::protobuf::rt::int32_size(3, self.online);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if self.total != 0 {
                os.write_int32(1, self.total)?;
            }
            if self.offline != 0 {
                os.write_int32(2, self.offline)?;
            }
            if self.online != 0 {
                os.write_int32(3, self.online)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> EpochData {
            EpochData::new()
        }
        fn clear(&mut self) {
            self.total = 0;
            self.offline = 0;
            self.online = 0;
            self.special_fields.clear();
        }
        fn default_instance() -> &'static EpochData {
            static instance: EpochData = EpochData {
                total: 0,
                offline: 0,
                online: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for EpochData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("EpochData")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for EpochData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for EpochData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct RankingScore {
        pub stake_score: ::std::string::String,
        pub performance_score: ::std::string::String,
        pub previous_status: ::protobuf::EnumOrUnknown<ValidatorNodeStatus>,
        pub status: ::protobuf::EnumOrUnknown<ValidatorNodeStatus>,
        pub voting_power: u32,
        pub ranking_score: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for RankingScore {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for RankingScore {
        #[inline]
        fn eq(&self, other: &RankingScore) -> bool {
            self.stake_score == other.stake_score
                && self.performance_score == other.performance_score
                && self.previous_status == other.previous_status
                && self.status == other.status && self.voting_power == other.voting_power
                && self.ranking_score == other.ranking_score
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RankingScore {
        #[inline]
        fn clone(&self) -> RankingScore {
            RankingScore {
                stake_score: ::core::clone::Clone::clone(&self.stake_score),
                performance_score: ::core::clone::Clone::clone(&self.performance_score),
                previous_status: ::core::clone::Clone::clone(&self.previous_status),
                status: ::core::clone::Clone::clone(&self.status),
                voting_power: ::core::clone::Clone::clone(&self.voting_power),
                ranking_score: ::core::clone::Clone::clone(&self.ranking_score),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for RankingScore {
        #[inline]
        fn default() -> RankingScore {
            RankingScore {
                stake_score: ::core::default::Default::default(),
                performance_score: ::core::default::Default::default(),
                previous_status: ::core::default::Default::default(),
                status: ::core::default::Default::default(),
                voting_power: ::core::default::Default::default(),
                ranking_score: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for RankingScore {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "stake_score",
                "performance_score",
                "previous_status",
                "status",
                "voting_power",
                "ranking_score",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.stake_score,
                &&self.performance_score,
                &&self.previous_status,
                &&self.status,
                &&self.voting_power,
                &&self.ranking_score,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "RankingScore",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a RankingScore {
        fn default() -> &'a RankingScore {
            <RankingScore as ::protobuf::Message>::default_instance()
        }
    }
    impl RankingScore {
        pub fn new() -> RankingScore {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "stake_score",
                        |m: &RankingScore| { &m.stake_score },
                        |m: &mut RankingScore| { &mut m.stake_score },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "performance_score",
                        |m: &RankingScore| { &m.performance_score },
                        |m: &mut RankingScore| { &mut m.performance_score },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "previous_status",
                        |m: &RankingScore| { &m.previous_status },
                        |m: &mut RankingScore| { &mut m.previous_status },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "status",
                        |m: &RankingScore| { &m.status },
                        |m: &mut RankingScore| { &mut m.status },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "voting_power",
                        |m: &RankingScore| { &m.voting_power },
                        |m: &mut RankingScore| { &mut m.voting_power },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "ranking_score",
                        |m: &RankingScore| { &m.ranking_score },
                        |m: &mut RankingScore| { &mut m.ranking_score },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                RankingScore,
            >("RankingScore", fields, oneofs)
        }
    }
    impl ::protobuf::Message for RankingScore {
        const NAME: &'static str = "RankingScore";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.stake_score = is.read_string()?;
                    }
                    18 => {
                        self.performance_score = is.read_string()?;
                    }
                    24 => {
                        self.previous_status = is.read_enum_or_unknown()?;
                    }
                    32 => {
                        self.status = is.read_enum_or_unknown()?;
                    }
                    40 => {
                        self.voting_power = is.read_uint32()?;
                    }
                    50 => {
                        self.ranking_score = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.stake_score.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.stake_score);
            }
            if !self.performance_score.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.performance_score);
            }
            if self.previous_status
                != ::protobuf::EnumOrUnknown::new(
                    ValidatorNodeStatus::VALIDATOR_NODE_STATUS_UNSPECIFIED,
                )
            {
                my_size += ::protobuf::rt::int32_size(3, self.previous_status.value());
            }
            if self.status
                != ::protobuf::EnumOrUnknown::new(
                    ValidatorNodeStatus::VALIDATOR_NODE_STATUS_UNSPECIFIED,
                )
            {
                my_size += ::protobuf::rt::int32_size(4, self.status.value());
            }
            if self.voting_power != 0 {
                my_size += ::protobuf::rt::uint32_size(5, self.voting_power);
            }
            if !self.ranking_score.is_empty() {
                my_size += ::protobuf::rt::string_size(6, &self.ranking_score);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.stake_score.is_empty() {
                os.write_string(1, &self.stake_score)?;
            }
            if !self.performance_score.is_empty() {
                os.write_string(2, &self.performance_score)?;
            }
            if self.previous_status
                != ::protobuf::EnumOrUnknown::new(
                    ValidatorNodeStatus::VALIDATOR_NODE_STATUS_UNSPECIFIED,
                )
            {
                os.write_enum(
                    3,
                    ::protobuf::EnumOrUnknown::value(&self.previous_status),
                )?;
            }
            if self.status
                != ::protobuf::EnumOrUnknown::new(
                    ValidatorNodeStatus::VALIDATOR_NODE_STATUS_UNSPECIFIED,
                )
            {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.status))?;
            }
            if self.voting_power != 0 {
                os.write_uint32(5, self.voting_power)?;
            }
            if !self.ranking_score.is_empty() {
                os.write_string(6, &self.ranking_score)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> RankingScore {
            RankingScore::new()
        }
        fn clear(&mut self) {
            self.stake_score.clear();
            self.performance_score.clear();
            self
                .previous_status = ::protobuf::EnumOrUnknown::new(
                ValidatorNodeStatus::VALIDATOR_NODE_STATUS_UNSPECIFIED,
            );
            self
                .status = ::protobuf::EnumOrUnknown::new(
                ValidatorNodeStatus::VALIDATOR_NODE_STATUS_UNSPECIFIED,
            );
            self.voting_power = 0;
            self.ranking_score.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static RankingScore {
            static instance: RankingScore = RankingScore {
                stake_score: ::std::string::String::new(),
                performance_score: ::std::string::String::new(),
                previous_status: ::protobuf::EnumOrUnknown::from_i32(0),
                status: ::protobuf::EnumOrUnknown::from_i32(0),
                voting_power: 0,
                ranking_score: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for RankingScore {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("RankingScore")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for RankingScore {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for RankingScore {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct RewardScore {
        pub raw_validator_score: ::std::string::String,
        pub performance_score: ::std::string::String,
        pub multisig_score: ::std::string::String,
        pub validator_score: ::std::string::String,
        pub normalised_score: ::std::string::String,
        pub validator_status: ::protobuf::EnumOrUnknown<ValidatorNodeStatus>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for RewardScore {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for RewardScore {
        #[inline]
        fn eq(&self, other: &RewardScore) -> bool {
            self.raw_validator_score == other.raw_validator_score
                && self.performance_score == other.performance_score
                && self.multisig_score == other.multisig_score
                && self.validator_score == other.validator_score
                && self.normalised_score == other.normalised_score
                && self.validator_status == other.validator_status
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RewardScore {
        #[inline]
        fn clone(&self) -> RewardScore {
            RewardScore {
                raw_validator_score: ::core::clone::Clone::clone(
                    &self.raw_validator_score,
                ),
                performance_score: ::core::clone::Clone::clone(&self.performance_score),
                multisig_score: ::core::clone::Clone::clone(&self.multisig_score),
                validator_score: ::core::clone::Clone::clone(&self.validator_score),
                normalised_score: ::core::clone::Clone::clone(&self.normalised_score),
                validator_status: ::core::clone::Clone::clone(&self.validator_status),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for RewardScore {
        #[inline]
        fn default() -> RewardScore {
            RewardScore {
                raw_validator_score: ::core::default::Default::default(),
                performance_score: ::core::default::Default::default(),
                multisig_score: ::core::default::Default::default(),
                validator_score: ::core::default::Default::default(),
                normalised_score: ::core::default::Default::default(),
                validator_status: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for RewardScore {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "raw_validator_score",
                "performance_score",
                "multisig_score",
                "validator_score",
                "normalised_score",
                "validator_status",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.raw_validator_score,
                &&self.performance_score,
                &&self.multisig_score,
                &&self.validator_score,
                &&self.normalised_score,
                &&self.validator_status,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "RewardScore",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a RewardScore {
        fn default() -> &'a RewardScore {
            <RewardScore as ::protobuf::Message>::default_instance()
        }
    }
    impl RewardScore {
        pub fn new() -> RewardScore {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "raw_validator_score",
                        |m: &RewardScore| { &m.raw_validator_score },
                        |m: &mut RewardScore| { &mut m.raw_validator_score },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "performance_score",
                        |m: &RewardScore| { &m.performance_score },
                        |m: &mut RewardScore| { &mut m.performance_score },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "multisig_score",
                        |m: &RewardScore| { &m.multisig_score },
                        |m: &mut RewardScore| { &mut m.multisig_score },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "validator_score",
                        |m: &RewardScore| { &m.validator_score },
                        |m: &mut RewardScore| { &mut m.validator_score },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "normalised_score",
                        |m: &RewardScore| { &m.normalised_score },
                        |m: &mut RewardScore| { &mut m.normalised_score },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "validator_status",
                        |m: &RewardScore| { &m.validator_status },
                        |m: &mut RewardScore| { &mut m.validator_status },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                RewardScore,
            >("RewardScore", fields, oneofs)
        }
    }
    impl ::protobuf::Message for RewardScore {
        const NAME: &'static str = "RewardScore";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.raw_validator_score = is.read_string()?;
                    }
                    18 => {
                        self.performance_score = is.read_string()?;
                    }
                    26 => {
                        self.multisig_score = is.read_string()?;
                    }
                    34 => {
                        self.validator_score = is.read_string()?;
                    }
                    42 => {
                        self.normalised_score = is.read_string()?;
                    }
                    48 => {
                        self.validator_status = is.read_enum_or_unknown()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.raw_validator_score.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.raw_validator_score);
            }
            if !self.performance_score.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.performance_score);
            }
            if !self.multisig_score.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.multisig_score);
            }
            if !self.validator_score.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.validator_score);
            }
            if !self.normalised_score.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.normalised_score);
            }
            if self.validator_status
                != ::protobuf::EnumOrUnknown::new(
                    ValidatorNodeStatus::VALIDATOR_NODE_STATUS_UNSPECIFIED,
                )
            {
                my_size += ::protobuf::rt::int32_size(6, self.validator_status.value());
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.raw_validator_score.is_empty() {
                os.write_string(1, &self.raw_validator_score)?;
            }
            if !self.performance_score.is_empty() {
                os.write_string(2, &self.performance_score)?;
            }
            if !self.multisig_score.is_empty() {
                os.write_string(3, &self.multisig_score)?;
            }
            if !self.validator_score.is_empty() {
                os.write_string(4, &self.validator_score)?;
            }
            if !self.normalised_score.is_empty() {
                os.write_string(5, &self.normalised_score)?;
            }
            if self.validator_status
                != ::protobuf::EnumOrUnknown::new(
                    ValidatorNodeStatus::VALIDATOR_NODE_STATUS_UNSPECIFIED,
                )
            {
                os.write_enum(
                    6,
                    ::protobuf::EnumOrUnknown::value(&self.validator_status),
                )?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> RewardScore {
            RewardScore::new()
        }
        fn clear(&mut self) {
            self.raw_validator_score.clear();
            self.performance_score.clear();
            self.multisig_score.clear();
            self.validator_score.clear();
            self.normalised_score.clear();
            self
                .validator_status = ::protobuf::EnumOrUnknown::new(
                ValidatorNodeStatus::VALIDATOR_NODE_STATUS_UNSPECIFIED,
            );
            self.special_fields.clear();
        }
        fn default_instance() -> &'static RewardScore {
            static instance: RewardScore = RewardScore {
                raw_validator_score: ::std::string::String::new(),
                performance_score: ::std::string::String::new(),
                multisig_score: ::std::string::String::new(),
                validator_score: ::std::string::String::new(),
                normalised_score: ::std::string::String::new(),
                validator_status: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for RewardScore {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("RewardScore")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for RewardScore {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for RewardScore {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct Node {
        pub id: ::std::string::String,
        pub pub_key: ::std::string::String,
        pub tm_pub_key: ::std::string::String,
        pub ethereum_address: ::std::string::String,
        pub info_url: ::std::string::String,
        pub location: ::std::string::String,
        pub staked_by_operator: ::std::string::String,
        pub staked_by_delegates: ::std::string::String,
        pub staked_total: ::std::string::String,
        pub max_intended_stake: ::std::string::String,
        pub pending_stake: ::std::string::String,
        pub epoch_data: ::protobuf::MessageField<EpochData>,
        pub status: ::protobuf::EnumOrUnknown<NodeStatus>,
        pub delegations: ::std::vec::Vec<Delegation>,
        pub reward_score: ::protobuf::MessageField<RewardScore>,
        pub ranking_score: ::protobuf::MessageField<RankingScore>,
        pub name: ::std::string::String,
        pub avatar_url: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Node {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Node {
        #[inline]
        fn eq(&self, other: &Node) -> bool {
            self.id == other.id && self.pub_key == other.pub_key
                && self.tm_pub_key == other.tm_pub_key
                && self.ethereum_address == other.ethereum_address
                && self.info_url == other.info_url && self.location == other.location
                && self.staked_by_operator == other.staked_by_operator
                && self.staked_by_delegates == other.staked_by_delegates
                && self.staked_total == other.staked_total
                && self.max_intended_stake == other.max_intended_stake
                && self.pending_stake == other.pending_stake
                && self.epoch_data == other.epoch_data && self.status == other.status
                && self.delegations == other.delegations
                && self.reward_score == other.reward_score
                && self.ranking_score == other.ranking_score && self.name == other.name
                && self.avatar_url == other.avatar_url
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Node {
        #[inline]
        fn clone(&self) -> Node {
            Node {
                id: ::core::clone::Clone::clone(&self.id),
                pub_key: ::core::clone::Clone::clone(&self.pub_key),
                tm_pub_key: ::core::clone::Clone::clone(&self.tm_pub_key),
                ethereum_address: ::core::clone::Clone::clone(&self.ethereum_address),
                info_url: ::core::clone::Clone::clone(&self.info_url),
                location: ::core::clone::Clone::clone(&self.location),
                staked_by_operator: ::core::clone::Clone::clone(
                    &self.staked_by_operator,
                ),
                staked_by_delegates: ::core::clone::Clone::clone(
                    &self.staked_by_delegates,
                ),
                staked_total: ::core::clone::Clone::clone(&self.staked_total),
                max_intended_stake: ::core::clone::Clone::clone(
                    &self.max_intended_stake,
                ),
                pending_stake: ::core::clone::Clone::clone(&self.pending_stake),
                epoch_data: ::core::clone::Clone::clone(&self.epoch_data),
                status: ::core::clone::Clone::clone(&self.status),
                delegations: ::core::clone::Clone::clone(&self.delegations),
                reward_score: ::core::clone::Clone::clone(&self.reward_score),
                ranking_score: ::core::clone::Clone::clone(&self.ranking_score),
                name: ::core::clone::Clone::clone(&self.name),
                avatar_url: ::core::clone::Clone::clone(&self.avatar_url),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Node {
        #[inline]
        fn default() -> Node {
            Node {
                id: ::core::default::Default::default(),
                pub_key: ::core::default::Default::default(),
                tm_pub_key: ::core::default::Default::default(),
                ethereum_address: ::core::default::Default::default(),
                info_url: ::core::default::Default::default(),
                location: ::core::default::Default::default(),
                staked_by_operator: ::core::default::Default::default(),
                staked_by_delegates: ::core::default::Default::default(),
                staked_total: ::core::default::Default::default(),
                max_intended_stake: ::core::default::Default::default(),
                pending_stake: ::core::default::Default::default(),
                epoch_data: ::core::default::Default::default(),
                status: ::core::default::Default::default(),
                delegations: ::core::default::Default::default(),
                reward_score: ::core::default::Default::default(),
                ranking_score: ::core::default::Default::default(),
                name: ::core::default::Default::default(),
                avatar_url: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Node {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "pub_key",
                "tm_pub_key",
                "ethereum_address",
                "info_url",
                "location",
                "staked_by_operator",
                "staked_by_delegates",
                "staked_total",
                "max_intended_stake",
                "pending_stake",
                "epoch_data",
                "status",
                "delegations",
                "reward_score",
                "ranking_score",
                "name",
                "avatar_url",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.id,
                &&self.pub_key,
                &&self.tm_pub_key,
                &&self.ethereum_address,
                &&self.info_url,
                &&self.location,
                &&self.staked_by_operator,
                &&self.staked_by_delegates,
                &&self.staked_total,
                &&self.max_intended_stake,
                &&self.pending_stake,
                &&self.epoch_data,
                &&self.status,
                &&self.delegations,
                &&self.reward_score,
                &&self.ranking_score,
                &&self.name,
                &&self.avatar_url,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Node", names, values)
        }
    }
    impl<'a> ::std::default::Default for &'a Node {
        fn default() -> &'a Node {
            <Node as ::protobuf::Message>::default_instance()
        }
    }
    impl Node {
        pub fn new() -> Node {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(18);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >("id", |m: &Node| { &m.id }, |m: &mut Node| { &mut m.id }),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "pub_key",
                        |m: &Node| { &m.pub_key },
                        |m: &mut Node| { &mut m.pub_key },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "tm_pub_key",
                        |m: &Node| { &m.tm_pub_key },
                        |m: &mut Node| { &mut m.tm_pub_key },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "ethereum_address",
                        |m: &Node| { &m.ethereum_address },
                        |m: &mut Node| { &mut m.ethereum_address },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "info_url",
                        |m: &Node| { &m.info_url },
                        |m: &mut Node| { &mut m.info_url },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "location",
                        |m: &Node| { &m.location },
                        |m: &mut Node| { &mut m.location },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "staked_by_operator",
                        |m: &Node| { &m.staked_by_operator },
                        |m: &mut Node| { &mut m.staked_by_operator },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "staked_by_delegates",
                        |m: &Node| { &m.staked_by_delegates },
                        |m: &mut Node| { &mut m.staked_by_delegates },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "staked_total",
                        |m: &Node| { &m.staked_total },
                        |m: &mut Node| { &mut m.staked_total },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "max_intended_stake",
                        |m: &Node| { &m.max_intended_stake },
                        |m: &mut Node| { &mut m.max_intended_stake },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "pending_stake",
                        |m: &Node| { &m.pending_stake },
                        |m: &mut Node| { &mut m.pending_stake },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        EpochData,
                    >(
                        "epoch_data",
                        |m: &Node| { &m.epoch_data },
                        |m: &mut Node| { &mut m.epoch_data },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "status",
                        |m: &Node| { &m.status },
                        |m: &mut Node| { &mut m.status },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "delegations",
                        |m: &Node| { &m.delegations },
                        |m: &mut Node| { &mut m.delegations },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        RewardScore,
                    >(
                        "reward_score",
                        |m: &Node| { &m.reward_score },
                        |m: &mut Node| { &mut m.reward_score },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        RankingScore,
                    >(
                        "ranking_score",
                        |m: &Node| { &m.ranking_score },
                        |m: &mut Node| { &mut m.ranking_score },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >("name", |m: &Node| { &m.name }, |m: &mut Node| { &mut m.name }),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "avatar_url",
                        |m: &Node| { &m.avatar_url },
                        |m: &mut Node| { &mut m.avatar_url },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                Node,
            >("Node", fields, oneofs)
        }
    }
    impl ::protobuf::Message for Node {
        const NAME: &'static str = "Node";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.id = is.read_string()?;
                    }
                    18 => {
                        self.pub_key = is.read_string()?;
                    }
                    26 => {
                        self.tm_pub_key = is.read_string()?;
                    }
                    34 => {
                        self.ethereum_address = is.read_string()?;
                    }
                    42 => {
                        self.info_url = is.read_string()?;
                    }
                    50 => {
                        self.location = is.read_string()?;
                    }
                    58 => {
                        self.staked_by_operator = is.read_string()?;
                    }
                    66 => {
                        self.staked_by_delegates = is.read_string()?;
                    }
                    74 => {
                        self.staked_total = is.read_string()?;
                    }
                    82 => {
                        self.max_intended_stake = is.read_string()?;
                    }
                    90 => {
                        self.pending_stake = is.read_string()?;
                    }
                    98 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.epoch_data,
                        )?;
                    }
                    104 => {
                        self.status = is.read_enum_or_unknown()?;
                    }
                    114 => {
                        self.delegations.push(is.read_message()?);
                    }
                    122 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.reward_score,
                        )?;
                    }
                    130 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.ranking_score,
                        )?;
                    }
                    138 => {
                        self.name = is.read_string()?;
                    }
                    146 => {
                        self.avatar_url = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.id);
            }
            if !self.pub_key.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.pub_key);
            }
            if !self.tm_pub_key.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.tm_pub_key);
            }
            if !self.ethereum_address.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.ethereum_address);
            }
            if !self.info_url.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.info_url);
            }
            if !self.location.is_empty() {
                my_size += ::protobuf::rt::string_size(6, &self.location);
            }
            if !self.staked_by_operator.is_empty() {
                my_size += ::protobuf::rt::string_size(7, &self.staked_by_operator);
            }
            if !self.staked_by_delegates.is_empty() {
                my_size += ::protobuf::rt::string_size(8, &self.staked_by_delegates);
            }
            if !self.staked_total.is_empty() {
                my_size += ::protobuf::rt::string_size(9, &self.staked_total);
            }
            if !self.max_intended_stake.is_empty() {
                my_size += ::protobuf::rt::string_size(10, &self.max_intended_stake);
            }
            if !self.pending_stake.is_empty() {
                my_size += ::protobuf::rt::string_size(11, &self.pending_stake);
            }
            if let Some(v) = self.epoch_data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.status
                != ::protobuf::EnumOrUnknown::new(NodeStatus::NODE_STATUS_UNSPECIFIED)
            {
                my_size += ::protobuf::rt::int32_size(13, self.status.value());
            }
            for value in &self.delegations {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.reward_score.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.ranking_score.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(17, &self.name);
            }
            if !self.avatar_url.is_empty() {
                my_size += ::protobuf::rt::string_size(18, &self.avatar_url);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.id.is_empty() {
                os.write_string(1, &self.id)?;
            }
            if !self.pub_key.is_empty() {
                os.write_string(2, &self.pub_key)?;
            }
            if !self.tm_pub_key.is_empty() {
                os.write_string(3, &self.tm_pub_key)?;
            }
            if !self.ethereum_address.is_empty() {
                os.write_string(4, &self.ethereum_address)?;
            }
            if !self.info_url.is_empty() {
                os.write_string(5, &self.info_url)?;
            }
            if !self.location.is_empty() {
                os.write_string(6, &self.location)?;
            }
            if !self.staked_by_operator.is_empty() {
                os.write_string(7, &self.staked_by_operator)?;
            }
            if !self.staked_by_delegates.is_empty() {
                os.write_string(8, &self.staked_by_delegates)?;
            }
            if !self.staked_total.is_empty() {
                os.write_string(9, &self.staked_total)?;
            }
            if !self.max_intended_stake.is_empty() {
                os.write_string(10, &self.max_intended_stake)?;
            }
            if !self.pending_stake.is_empty() {
                os.write_string(11, &self.pending_stake)?;
            }
            if let Some(v) = self.epoch_data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
            }
            if self.status
                != ::protobuf::EnumOrUnknown::new(NodeStatus::NODE_STATUS_UNSPECIFIED)
            {
                os.write_enum(13, ::protobuf::EnumOrUnknown::value(&self.status))?;
            }
            for v in &self.delegations {
                ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
            }
            if let Some(v) = self.reward_score.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
            }
            if let Some(v) = self.ranking_score.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
            }
            if !self.name.is_empty() {
                os.write_string(17, &self.name)?;
            }
            if !self.avatar_url.is_empty() {
                os.write_string(18, &self.avatar_url)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> Node {
            Node::new()
        }
        fn clear(&mut self) {
            self.id.clear();
            self.pub_key.clear();
            self.tm_pub_key.clear();
            self.ethereum_address.clear();
            self.info_url.clear();
            self.location.clear();
            self.staked_by_operator.clear();
            self.staked_by_delegates.clear();
            self.staked_total.clear();
            self.max_intended_stake.clear();
            self.pending_stake.clear();
            self.epoch_data.clear();
            self
                .status = ::protobuf::EnumOrUnknown::new(
                NodeStatus::NODE_STATUS_UNSPECIFIED,
            );
            self.delegations.clear();
            self.reward_score.clear();
            self.ranking_score.clear();
            self.name.clear();
            self.avatar_url.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static Node {
            static instance: Node = Node {
                id: ::std::string::String::new(),
                pub_key: ::std::string::String::new(),
                tm_pub_key: ::std::string::String::new(),
                ethereum_address: ::std::string::String::new(),
                info_url: ::std::string::String::new(),
                location: ::std::string::String::new(),
                staked_by_operator: ::std::string::String::new(),
                staked_by_delegates: ::std::string::String::new(),
                staked_total: ::std::string::String::new(),
                max_intended_stake: ::std::string::String::new(),
                pending_stake: ::std::string::String::new(),
                epoch_data: ::protobuf::MessageField::none(),
                status: ::protobuf::EnumOrUnknown::from_i32(0),
                delegations: ::std::vec::Vec::new(),
                reward_score: ::protobuf::MessageField::none(),
                ranking_score: ::protobuf::MessageField::none(),
                name: ::std::string::String::new(),
                avatar_url: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for Node {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor().message_by_package_relative_name("Node").unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for Node {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for Node {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct NodeData {
        pub staked_total: ::std::string::String,
        pub total_nodes: u32,
        pub inactive_nodes: u32,
        pub validating_nodes: u32,
        pub uptime: f32,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for NodeData {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for NodeData {
        #[inline]
        fn eq(&self, other: &NodeData) -> bool {
            self.staked_total == other.staked_total
                && self.total_nodes == other.total_nodes
                && self.inactive_nodes == other.inactive_nodes
                && self.validating_nodes == other.validating_nodes
                && self.uptime == other.uptime
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for NodeData {
        #[inline]
        fn clone(&self) -> NodeData {
            NodeData {
                staked_total: ::core::clone::Clone::clone(&self.staked_total),
                total_nodes: ::core::clone::Clone::clone(&self.total_nodes),
                inactive_nodes: ::core::clone::Clone::clone(&self.inactive_nodes),
                validating_nodes: ::core::clone::Clone::clone(&self.validating_nodes),
                uptime: ::core::clone::Clone::clone(&self.uptime),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for NodeData {
        #[inline]
        fn default() -> NodeData {
            NodeData {
                staked_total: ::core::default::Default::default(),
                total_nodes: ::core::default::Default::default(),
                inactive_nodes: ::core::default::Default::default(),
                validating_nodes: ::core::default::Default::default(),
                uptime: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for NodeData {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "staked_total",
                "total_nodes",
                "inactive_nodes",
                "validating_nodes",
                "uptime",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.staked_total,
                &&self.total_nodes,
                &&self.inactive_nodes,
                &&self.validating_nodes,
                &&self.uptime,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "NodeData",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a NodeData {
        fn default() -> &'a NodeData {
            <NodeData as ::protobuf::Message>::default_instance()
        }
    }
    impl NodeData {
        pub fn new() -> NodeData {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "staked_total",
                        |m: &NodeData| { &m.staked_total },
                        |m: &mut NodeData| { &mut m.staked_total },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "total_nodes",
                        |m: &NodeData| { &m.total_nodes },
                        |m: &mut NodeData| { &mut m.total_nodes },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "inactive_nodes",
                        |m: &NodeData| { &m.inactive_nodes },
                        |m: &mut NodeData| { &mut m.inactive_nodes },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "validating_nodes",
                        |m: &NodeData| { &m.validating_nodes },
                        |m: &mut NodeData| { &mut m.validating_nodes },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "uptime",
                        |m: &NodeData| { &m.uptime },
                        |m: &mut NodeData| { &mut m.uptime },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                NodeData,
            >("NodeData", fields, oneofs)
        }
    }
    impl ::protobuf::Message for NodeData {
        const NAME: &'static str = "NodeData";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.staked_total = is.read_string()?;
                    }
                    16 => {
                        self.total_nodes = is.read_uint32()?;
                    }
                    24 => {
                        self.inactive_nodes = is.read_uint32()?;
                    }
                    32 => {
                        self.validating_nodes = is.read_uint32()?;
                    }
                    45 => {
                        self.uptime = is.read_float()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.staked_total.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.staked_total);
            }
            if self.total_nodes != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.total_nodes);
            }
            if self.inactive_nodes != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.inactive_nodes);
            }
            if self.validating_nodes != 0 {
                my_size += ::protobuf::rt::uint32_size(4, self.validating_nodes);
            }
            if self.uptime != 0. {
                my_size += 1 + 4;
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.staked_total.is_empty() {
                os.write_string(1, &self.staked_total)?;
            }
            if self.total_nodes != 0 {
                os.write_uint32(2, self.total_nodes)?;
            }
            if self.inactive_nodes != 0 {
                os.write_uint32(3, self.inactive_nodes)?;
            }
            if self.validating_nodes != 0 {
                os.write_uint32(4, self.validating_nodes)?;
            }
            if self.uptime != 0. {
                os.write_float(5, self.uptime)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> NodeData {
            NodeData::new()
        }
        fn clear(&mut self) {
            self.staked_total.clear();
            self.total_nodes = 0;
            self.inactive_nodes = 0;
            self.validating_nodes = 0;
            self.uptime = 0.;
            self.special_fields.clear();
        }
        fn default_instance() -> &'static NodeData {
            static instance: NodeData = NodeData {
                staked_total: ::std::string::String::new(),
                total_nodes: 0,
                inactive_nodes: 0,
                validating_nodes: 0,
                uptime: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for NodeData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("NodeData")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for NodeData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for NodeData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct Delegation {
        pub party: ::std::string::String,
        pub node_id: ::std::string::String,
        pub amount: ::std::string::String,
        pub epoch_seq: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Delegation {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Delegation {
        #[inline]
        fn eq(&self, other: &Delegation) -> bool {
            self.party == other.party && self.node_id == other.node_id
                && self.amount == other.amount && self.epoch_seq == other.epoch_seq
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Delegation {
        #[inline]
        fn clone(&self) -> Delegation {
            Delegation {
                party: ::core::clone::Clone::clone(&self.party),
                node_id: ::core::clone::Clone::clone(&self.node_id),
                amount: ::core::clone::Clone::clone(&self.amount),
                epoch_seq: ::core::clone::Clone::clone(&self.epoch_seq),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Delegation {
        #[inline]
        fn default() -> Delegation {
            Delegation {
                party: ::core::default::Default::default(),
                node_id: ::core::default::Default::default(),
                amount: ::core::default::Default::default(),
                epoch_seq: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Delegation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "Delegation",
                "party",
                &&self.party,
                "node_id",
                &&self.node_id,
                "amount",
                &&self.amount,
                "epoch_seq",
                &&self.epoch_seq,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a Delegation {
        fn default() -> &'a Delegation {
            <Delegation as ::protobuf::Message>::default_instance()
        }
    }
    impl Delegation {
        pub fn new() -> Delegation {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "party",
                        |m: &Delegation| { &m.party },
                        |m: &mut Delegation| { &mut m.party },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "node_id",
                        |m: &Delegation| { &m.node_id },
                        |m: &mut Delegation| { &mut m.node_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "amount",
                        |m: &Delegation| { &m.amount },
                        |m: &mut Delegation| { &mut m.amount },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "epoch_seq",
                        |m: &Delegation| { &m.epoch_seq },
                        |m: &mut Delegation| { &mut m.epoch_seq },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                Delegation,
            >("Delegation", fields, oneofs)
        }
    }
    impl ::protobuf::Message for Delegation {
        const NAME: &'static str = "Delegation";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.party = is.read_string()?;
                    }
                    18 => {
                        self.node_id = is.read_string()?;
                    }
                    26 => {
                        self.amount = is.read_string()?;
                    }
                    34 => {
                        self.epoch_seq = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.party.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.party);
            }
            if !self.node_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.node_id);
            }
            if !self.amount.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.amount);
            }
            if !self.epoch_seq.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.epoch_seq);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.party.is_empty() {
                os.write_string(1, &self.party)?;
            }
            if !self.node_id.is_empty() {
                os.write_string(2, &self.node_id)?;
            }
            if !self.amount.is_empty() {
                os.write_string(3, &self.amount)?;
            }
            if !self.epoch_seq.is_empty() {
                os.write_string(4, &self.epoch_seq)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> Delegation {
            Delegation::new()
        }
        fn clear(&mut self) {
            self.party.clear();
            self.node_id.clear();
            self.amount.clear();
            self.epoch_seq.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static Delegation {
            static instance: Delegation = Delegation {
                party: ::std::string::String::new(),
                node_id: ::std::string::String::new(),
                amount: ::std::string::String::new(),
                epoch_seq: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for Delegation {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("Delegation")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for Delegation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for Delegation {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct Reward {
        pub asset_id: ::std::string::String,
        pub party_id: ::std::string::String,
        pub epoch: u64,
        pub amount: ::std::string::String,
        pub percentage_of_total: ::std::string::String,
        pub received_at: i64,
        pub market_id: ::std::string::String,
        pub reward_type: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Reward {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Reward {
        #[inline]
        fn eq(&self, other: &Reward) -> bool {
            self.asset_id == other.asset_id && self.party_id == other.party_id
                && self.epoch == other.epoch && self.amount == other.amount
                && self.percentage_of_total == other.percentage_of_total
                && self.received_at == other.received_at
                && self.market_id == other.market_id
                && self.reward_type == other.reward_type
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Reward {
        #[inline]
        fn clone(&self) -> Reward {
            Reward {
                asset_id: ::core::clone::Clone::clone(&self.asset_id),
                party_id: ::core::clone::Clone::clone(&self.party_id),
                epoch: ::core::clone::Clone::clone(&self.epoch),
                amount: ::core::clone::Clone::clone(&self.amount),
                percentage_of_total: ::core::clone::Clone::clone(
                    &self.percentage_of_total,
                ),
                received_at: ::core::clone::Clone::clone(&self.received_at),
                market_id: ::core::clone::Clone::clone(&self.market_id),
                reward_type: ::core::clone::Clone::clone(&self.reward_type),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Reward {
        #[inline]
        fn default() -> Reward {
            Reward {
                asset_id: ::core::default::Default::default(),
                party_id: ::core::default::Default::default(),
                epoch: ::core::default::Default::default(),
                amount: ::core::default::Default::default(),
                percentage_of_total: ::core::default::Default::default(),
                received_at: ::core::default::Default::default(),
                market_id: ::core::default::Default::default(),
                reward_type: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Reward {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "asset_id",
                "party_id",
                "epoch",
                "amount",
                "percentage_of_total",
                "received_at",
                "market_id",
                "reward_type",
                "special_fields",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.asset_id,
                &&self.party_id,
                &&self.epoch,
                &&self.amount,
                &&self.percentage_of_total,
                &&self.received_at,
                &&self.market_id,
                &&self.reward_type,
                &&self.special_fields,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "Reward",
                names,
                values,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a Reward {
        fn default() -> &'a Reward {
            <Reward as ::protobuf::Message>::default_instance()
        }
    }
    impl Reward {
        pub fn new() -> Reward {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "asset_id",
                        |m: &Reward| { &m.asset_id },
                        |m: &mut Reward| { &mut m.asset_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "party_id",
                        |m: &Reward| { &m.party_id },
                        |m: &mut Reward| { &mut m.party_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "epoch",
                        |m: &Reward| { &m.epoch },
                        |m: &mut Reward| { &mut m.epoch },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "amount",
                        |m: &Reward| { &m.amount },
                        |m: &mut Reward| { &mut m.amount },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "percentage_of_total",
                        |m: &Reward| { &m.percentage_of_total },
                        |m: &mut Reward| { &mut m.percentage_of_total },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "received_at",
                        |m: &Reward| { &m.received_at },
                        |m: &mut Reward| { &mut m.received_at },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "market_id",
                        |m: &Reward| { &m.market_id },
                        |m: &mut Reward| { &mut m.market_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "reward_type",
                        |m: &Reward| { &m.reward_type },
                        |m: &mut Reward| { &mut m.reward_type },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                Reward,
            >("Reward", fields, oneofs)
        }
    }
    impl ::protobuf::Message for Reward {
        const NAME: &'static str = "Reward";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.asset_id = is.read_string()?;
                    }
                    18 => {
                        self.party_id = is.read_string()?;
                    }
                    24 => {
                        self.epoch = is.read_uint64()?;
                    }
                    34 => {
                        self.amount = is.read_string()?;
                    }
                    42 => {
                        self.percentage_of_total = is.read_string()?;
                    }
                    48 => {
                        self.received_at = is.read_int64()?;
                    }
                    58 => {
                        self.market_id = is.read_string()?;
                    }
                    66 => {
                        self.reward_type = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.asset_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.asset_id);
            }
            if !self.party_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.party_id);
            }
            if self.epoch != 0 {
                my_size += ::protobuf::rt::uint64_size(3, self.epoch);
            }
            if !self.amount.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.amount);
            }
            if !self.percentage_of_total.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.percentage_of_total);
            }
            if self.received_at != 0 {
                my_size += ::protobuf::rt::int64_size(6, self.received_at);
            }
            if !self.market_id.is_empty() {
                my_size += ::protobuf::rt::string_size(7, &self.market_id);
            }
            if !self.reward_type.is_empty() {
                my_size += ::protobuf::rt::string_size(8, &self.reward_type);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.asset_id.is_empty() {
                os.write_string(1, &self.asset_id)?;
            }
            if !self.party_id.is_empty() {
                os.write_string(2, &self.party_id)?;
            }
            if self.epoch != 0 {
                os.write_uint64(3, self.epoch)?;
            }
            if !self.amount.is_empty() {
                os.write_string(4, &self.amount)?;
            }
            if !self.percentage_of_total.is_empty() {
                os.write_string(5, &self.percentage_of_total)?;
            }
            if self.received_at != 0 {
                os.write_int64(6, self.received_at)?;
            }
            if !self.market_id.is_empty() {
                os.write_string(7, &self.market_id)?;
            }
            if !self.reward_type.is_empty() {
                os.write_string(8, &self.reward_type)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> Reward {
            Reward::new()
        }
        fn clear(&mut self) {
            self.asset_id.clear();
            self.party_id.clear();
            self.epoch = 0;
            self.amount.clear();
            self.percentage_of_total.clear();
            self.received_at = 0;
            self.market_id.clear();
            self.reward_type.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static Reward {
            static instance: Reward = Reward {
                asset_id: ::std::string::String::new(),
                party_id: ::std::string::String::new(),
                epoch: 0,
                amount: ::std::string::String::new(),
                percentage_of_total: ::std::string::String::new(),
                received_at: 0,
                market_id: ::std::string::String::new(),
                reward_type: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for Reward {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor().message_by_package_relative_name("Reward").unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for Reward {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for Reward {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct RewardSummary {
        pub asset_id: ::std::string::String,
        pub party_id: ::std::string::String,
        pub amount: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for RewardSummary {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for RewardSummary {
        #[inline]
        fn eq(&self, other: &RewardSummary) -> bool {
            self.asset_id == other.asset_id && self.party_id == other.party_id
                && self.amount == other.amount
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RewardSummary {
        #[inline]
        fn clone(&self) -> RewardSummary {
            RewardSummary {
                asset_id: ::core::clone::Clone::clone(&self.asset_id),
                party_id: ::core::clone::Clone::clone(&self.party_id),
                amount: ::core::clone::Clone::clone(&self.amount),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for RewardSummary {
        #[inline]
        fn default() -> RewardSummary {
            RewardSummary {
                asset_id: ::core::default::Default::default(),
                party_id: ::core::default::Default::default(),
                amount: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for RewardSummary {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "RewardSummary",
                "asset_id",
                &&self.asset_id,
                "party_id",
                &&self.party_id,
                "amount",
                &&self.amount,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a RewardSummary {
        fn default() -> &'a RewardSummary {
            <RewardSummary as ::protobuf::Message>::default_instance()
        }
    }
    impl RewardSummary {
        pub fn new() -> RewardSummary {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "asset_id",
                        |m: &RewardSummary| { &m.asset_id },
                        |m: &mut RewardSummary| { &mut m.asset_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "party_id",
                        |m: &RewardSummary| { &m.party_id },
                        |m: &mut RewardSummary| { &mut m.party_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "amount",
                        |m: &RewardSummary| { &m.amount },
                        |m: &mut RewardSummary| { &mut m.amount },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                RewardSummary,
            >("RewardSummary", fields, oneofs)
        }
    }
    impl ::protobuf::Message for RewardSummary {
        const NAME: &'static str = "RewardSummary";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.asset_id = is.read_string()?;
                    }
                    18 => {
                        self.party_id = is.read_string()?;
                    }
                    26 => {
                        self.amount = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.asset_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.asset_id);
            }
            if !self.party_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.party_id);
            }
            if !self.amount.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.amount);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.asset_id.is_empty() {
                os.write_string(1, &self.asset_id)?;
            }
            if !self.party_id.is_empty() {
                os.write_string(2, &self.party_id)?;
            }
            if !self.amount.is_empty() {
                os.write_string(3, &self.amount)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> RewardSummary {
            RewardSummary::new()
        }
        fn clear(&mut self) {
            self.asset_id.clear();
            self.party_id.clear();
            self.amount.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static RewardSummary {
            static instance: RewardSummary = RewardSummary {
                asset_id: ::std::string::String::new(),
                party_id: ::std::string::String::new(),
                amount: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for RewardSummary {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("RewardSummary")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for RewardSummary {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for RewardSummary {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct StateValueProposal {
        pub state_var_id: ::std::string::String,
        pub event_id: ::std::string::String,
        pub kvb: ::std::vec::Vec<KeyValueBundle>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StateValueProposal {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StateValueProposal {
        #[inline]
        fn eq(&self, other: &StateValueProposal) -> bool {
            self.state_var_id == other.state_var_id && self.event_id == other.event_id
                && self.kvb == other.kvb && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StateValueProposal {
        #[inline]
        fn clone(&self) -> StateValueProposal {
            StateValueProposal {
                state_var_id: ::core::clone::Clone::clone(&self.state_var_id),
                event_id: ::core::clone::Clone::clone(&self.event_id),
                kvb: ::core::clone::Clone::clone(&self.kvb),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for StateValueProposal {
        #[inline]
        fn default() -> StateValueProposal {
            StateValueProposal {
                state_var_id: ::core::default::Default::default(),
                event_id: ::core::default::Default::default(),
                kvb: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StateValueProposal {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "StateValueProposal",
                "state_var_id",
                &&self.state_var_id,
                "event_id",
                &&self.event_id,
                "kvb",
                &&self.kvb,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a StateValueProposal {
        fn default() -> &'a StateValueProposal {
            <StateValueProposal as ::protobuf::Message>::default_instance()
        }
    }
    impl StateValueProposal {
        pub fn new() -> StateValueProposal {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "state_var_id",
                        |m: &StateValueProposal| { &m.state_var_id },
                        |m: &mut StateValueProposal| { &mut m.state_var_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "event_id",
                        |m: &StateValueProposal| { &m.event_id },
                        |m: &mut StateValueProposal| { &mut m.event_id },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "kvb",
                        |m: &StateValueProposal| { &m.kvb },
                        |m: &mut StateValueProposal| { &mut m.kvb },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                StateValueProposal,
            >("StateValueProposal", fields, oneofs)
        }
    }
    impl ::protobuf::Message for StateValueProposal {
        const NAME: &'static str = "StateValueProposal";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.state_var_id = is.read_string()?;
                    }
                    18 => {
                        self.event_id = is.read_string()?;
                    }
                    26 => {
                        self.kvb.push(is.read_message()?);
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.state_var_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.state_var_id);
            }
            if !self.event_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.event_id);
            }
            for value in &self.kvb {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.state_var_id.is_empty() {
                os.write_string(1, &self.state_var_id)?;
            }
            if !self.event_id.is_empty() {
                os.write_string(2, &self.event_id)?;
            }
            for v in &self.kvb {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> StateValueProposal {
            StateValueProposal::new()
        }
        fn clear(&mut self) {
            self.state_var_id.clear();
            self.event_id.clear();
            self.kvb.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static StateValueProposal {
            static instance: StateValueProposal = StateValueProposal {
                state_var_id: ::std::string::String::new(),
                event_id: ::std::string::String::new(),
                kvb: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for StateValueProposal {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("StateValueProposal")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for StateValueProposal {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for StateValueProposal {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct KeyValueBundle {
        pub key: ::std::string::String,
        pub tolerance: ::std::string::String,
        pub value: ::protobuf::MessageField<StateVarValue>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for KeyValueBundle {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for KeyValueBundle {
        #[inline]
        fn eq(&self, other: &KeyValueBundle) -> bool {
            self.key == other.key && self.tolerance == other.tolerance
                && self.value == other.value
                && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for KeyValueBundle {
        #[inline]
        fn clone(&self) -> KeyValueBundle {
            KeyValueBundle {
                key: ::core::clone::Clone::clone(&self.key),
                tolerance: ::core::clone::Clone::clone(&self.tolerance),
                value: ::core::clone::Clone::clone(&self.value),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for KeyValueBundle {
        #[inline]
        fn default() -> KeyValueBundle {
            KeyValueBundle {
                key: ::core::default::Default::default(),
                tolerance: ::core::default::Default::default(),
                value: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for KeyValueBundle {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "KeyValueBundle",
                "key",
                &&self.key,
                "tolerance",
                &&self.tolerance,
                "value",
                &&self.value,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a KeyValueBundle {
        fn default() -> &'a KeyValueBundle {
            <KeyValueBundle as ::protobuf::Message>::default_instance()
        }
    }
    impl KeyValueBundle {
        pub fn new() -> KeyValueBundle {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "key",
                        |m: &KeyValueBundle| { &m.key },
                        |m: &mut KeyValueBundle| { &mut m.key },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "tolerance",
                        |m: &KeyValueBundle| { &m.tolerance },
                        |m: &mut KeyValueBundle| { &mut m.tolerance },
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_message_field_accessor::<
                        _,
                        StateVarValue,
                    >(
                        "value",
                        |m: &KeyValueBundle| { &m.value },
                        |m: &mut KeyValueBundle| { &mut m.value },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                KeyValueBundle,
            >("KeyValueBundle", fields, oneofs)
        }
    }
    impl ::protobuf::Message for KeyValueBundle {
        const NAME: &'static str = "KeyValueBundle";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.key = is.read_string()?;
                    }
                    18 => {
                        self.tolerance = is.read_string()?;
                    }
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(
                            is,
                            &mut self.value,
                        )?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.key.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.key);
            }
            if !self.tolerance.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.tolerance);
            }
            if let Some(v) = self.value.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.key.is_empty() {
                os.write_string(1, &self.key)?;
            }
            if !self.tolerance.is_empty() {
                os.write_string(2, &self.tolerance)?;
            }
            if let Some(v) = self.value.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> KeyValueBundle {
            KeyValueBundle::new()
        }
        fn clear(&mut self) {
            self.key.clear();
            self.tolerance.clear();
            self.value.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static KeyValueBundle {
            static instance: KeyValueBundle = KeyValueBundle {
                key: ::std::string::String::new(),
                tolerance: ::std::string::String::new(),
                value: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for KeyValueBundle {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("KeyValueBundle")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for KeyValueBundle {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for KeyValueBundle {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct StateVarValue {
        pub value: ::std::option::Option<state_var_value::Value>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StateVarValue {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StateVarValue {
        #[inline]
        fn eq(&self, other: &StateVarValue) -> bool {
            self.value == other.value && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StateVarValue {
        #[inline]
        fn clone(&self) -> StateVarValue {
            StateVarValue {
                value: ::core::clone::Clone::clone(&self.value),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for StateVarValue {
        #[inline]
        fn default() -> StateVarValue {
            StateVarValue {
                value: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StateVarValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "StateVarValue",
                "value",
                &&self.value,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a StateVarValue {
        fn default() -> &'a StateVarValue {
            <StateVarValue as ::protobuf::Message>::default_instance()
        }
    }
    impl StateVarValue {
        pub fn new() -> StateVarValue {
            ::std::default::Default::default()
        }
        pub fn scalar_val(&self) -> &ScalarValue {
            match self.value {
                ::std::option::Option::Some(state_var_value::Value::ScalarVal(ref v)) => {
                    v
                }
                _ => <ScalarValue as ::protobuf::Message>::default_instance(),
            }
        }
        pub fn clear_scalar_val(&mut self) {
            self.value = ::std::option::Option::None;
        }
        pub fn has_scalar_val(&self) -> bool {
            match self.value {
                ::std::option::Option::Some(state_var_value::Value::ScalarVal(..)) => {
                    true
                }
                _ => false,
            }
        }
        pub fn set_scalar_val(&mut self, v: ScalarValue) {
            self
                .value = ::std::option::Option::Some(
                state_var_value::Value::ScalarVal(v),
            );
        }
        pub fn mut_scalar_val(&mut self) -> &mut ScalarValue {
            if let ::std::option::Option::Some(state_var_value::Value::ScalarVal(_))
                = self.value
            {} else {
                self
                    .value = ::std::option::Option::Some(
                    state_var_value::Value::ScalarVal(ScalarValue::new()),
                );
            }
            match self.value {
                ::std::option::Option::Some(
                    state_var_value::Value::ScalarVal(ref mut v),
                ) => v,
                _ => ::core::panicking::panic("explicit panic"),
            }
        }
        pub fn take_scalar_val(&mut self) -> ScalarValue {
            if self.has_scalar_val() {
                match self.value.take() {
                    ::std::option::Option::Some(state_var_value::Value::ScalarVal(v)) => {
                        v
                    }
                    _ => ::core::panicking::panic("explicit panic"),
                }
            } else {
                ScalarValue::new()
            }
        }
        pub fn vector_val(&self) -> &VectorValue {
            match self.value {
                ::std::option::Option::Some(state_var_value::Value::VectorVal(ref v)) => {
                    v
                }
                _ => <VectorValue as ::protobuf::Message>::default_instance(),
            }
        }
        pub fn clear_vector_val(&mut self) {
            self.value = ::std::option::Option::None;
        }
        pub fn has_vector_val(&self) -> bool {
            match self.value {
                ::std::option::Option::Some(state_var_value::Value::VectorVal(..)) => {
                    true
                }
                _ => false,
            }
        }
        pub fn set_vector_val(&mut self, v: VectorValue) {
            self
                .value = ::std::option::Option::Some(
                state_var_value::Value::VectorVal(v),
            );
        }
        pub fn mut_vector_val(&mut self) -> &mut VectorValue {
            if let ::std::option::Option::Some(state_var_value::Value::VectorVal(_))
                = self.value
            {} else {
                self
                    .value = ::std::option::Option::Some(
                    state_var_value::Value::VectorVal(VectorValue::new()),
                );
            }
            match self.value {
                ::std::option::Option::Some(
                    state_var_value::Value::VectorVal(ref mut v),
                ) => v,
                _ => ::core::panicking::panic("explicit panic"),
            }
        }
        pub fn take_vector_val(&mut self) -> VectorValue {
            if self.has_vector_val() {
                match self.value.take() {
                    ::std::option::Option::Some(state_var_value::Value::VectorVal(v)) => {
                        v
                    }
                    _ => ::core::panicking::panic("explicit panic"),
                }
            } else {
                VectorValue::new()
            }
        }
        pub fn matrix_val(&self) -> &MatrixValue {
            match self.value {
                ::std::option::Option::Some(state_var_value::Value::MatrixVal(ref v)) => {
                    v
                }
                _ => <MatrixValue as ::protobuf::Message>::default_instance(),
            }
        }
        pub fn clear_matrix_val(&mut self) {
            self.value = ::std::option::Option::None;
        }
        pub fn has_matrix_val(&self) -> bool {
            match self.value {
                ::std::option::Option::Some(state_var_value::Value::MatrixVal(..)) => {
                    true
                }
                _ => false,
            }
        }
        pub fn set_matrix_val(&mut self, v: MatrixValue) {
            self
                .value = ::std::option::Option::Some(
                state_var_value::Value::MatrixVal(v),
            );
        }
        pub fn mut_matrix_val(&mut self) -> &mut MatrixValue {
            if let ::std::option::Option::Some(state_var_value::Value::MatrixVal(_))
                = self.value
            {} else {
                self
                    .value = ::std::option::Option::Some(
                    state_var_value::Value::MatrixVal(MatrixValue::new()),
                );
            }
            match self.value {
                ::std::option::Option::Some(
                    state_var_value::Value::MatrixVal(ref mut v),
                ) => v,
                _ => ::core::panicking::panic("explicit panic"),
            }
        }
        pub fn take_matrix_val(&mut self) -> MatrixValue {
            if self.has_matrix_val() {
                match self.value.take() {
                    ::std::option::Option::Some(state_var_value::Value::MatrixVal(v)) => {
                        v
                    }
                    _ => ::core::panicking::panic("explicit panic"),
                }
            } else {
                MatrixValue::new()
            }
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<
                        _,
                        ScalarValue,
                    >(
                        "scalar_val",
                        StateVarValue::has_scalar_val,
                        StateVarValue::scalar_val,
                        StateVarValue::mut_scalar_val,
                        StateVarValue::set_scalar_val,
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<
                        _,
                        VectorValue,
                    >(
                        "vector_val",
                        StateVarValue::has_vector_val,
                        StateVarValue::vector_val,
                        StateVarValue::mut_vector_val,
                        StateVarValue::set_vector_val,
                    ),
                );
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<
                        _,
                        MatrixValue,
                    >(
                        "matrix_val",
                        StateVarValue::has_matrix_val,
                        StateVarValue::matrix_val,
                        StateVarValue::mut_matrix_val,
                        StateVarValue::set_matrix_val,
                    ),
                );
            oneofs.push(state_var_value::Value::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                StateVarValue,
            >("StateVarValue", fields, oneofs)
        }
    }
    impl ::protobuf::Message for StateVarValue {
        const NAME: &'static str = "StateVarValue";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self
                            .value = ::std::option::Option::Some(
                            state_var_value::Value::ScalarVal(is.read_message()?),
                        );
                    }
                    18 => {
                        self
                            .value = ::std::option::Option::Some(
                            state_var_value::Value::VectorVal(is.read_message()?),
                        );
                    }
                    26 => {
                        self
                            .value = ::std::option::Option::Some(
                            state_var_value::Value::MatrixVal(is.read_message()?),
                        );
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.value {
                match v {
                    &state_var_value::Value::ScalarVal(ref v) => {
                        let len = v.compute_size();
                        my_size
                            += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    }
                    &state_var_value::Value::VectorVal(ref v) => {
                        let len = v.compute_size();
                        my_size
                            += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    }
                    &state_var_value::Value::MatrixVal(ref v) => {
                        let len = v.compute_size();
                        my_size
                            += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    }
                };
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.value {
                match v {
                    &state_var_value::Value::ScalarVal(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    }
                    &state_var_value::Value::VectorVal(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    }
                    &state_var_value::Value::MatrixVal(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    }
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> StateVarValue {
            StateVarValue::new()
        }
        fn clear(&mut self) {
            self.value = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }
        fn default_instance() -> &'static StateVarValue {
            static instance: StateVarValue = StateVarValue {
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for StateVarValue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("StateVarValue")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for StateVarValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for StateVarValue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    /// Nested message and enums of message `StateVarValue`
    pub mod state_var_value {
        #[non_exhaustive]
        pub enum Value {
            ScalarVal(super::ScalarValue),
            VectorVal(super::VectorValue),
            MatrixVal(super::MatrixValue),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Value {
            #[inline]
            fn clone(&self) -> Value {
                match self {
                    Value::ScalarVal(__self_0) => {
                        Value::ScalarVal(::core::clone::Clone::clone(__self_0))
                    }
                    Value::VectorVal(__self_0) => {
                        Value::VectorVal(::core::clone::Clone::clone(__self_0))
                    }
                    Value::MatrixVal(__self_0) => {
                        Value::MatrixVal(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Value {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Value {
            #[inline]
            fn eq(&self, other: &Value) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (Value::ScalarVal(__self_0), Value::ScalarVal(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Value::VectorVal(__self_0), Value::VectorVal(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Value::MatrixVal(__self_0), Value::MatrixVal(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Value {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Value::ScalarVal(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "ScalarVal",
                            &__self_0,
                        )
                    }
                    Value::VectorVal(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "VectorVal",
                            &__self_0,
                        )
                    }
                    Value::MatrixVal(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "MatrixVal",
                            &__self_0,
                        )
                    }
                }
            }
        }
        impl ::protobuf::Oneof for Value {}
        impl ::protobuf::OneofFull for Value {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<
                    ::protobuf::reflect::OneofDescriptor,
                > = ::protobuf::rt::Lazy::new();
                descriptor
                    .get(|| {
                        <super::StateVarValue as ::protobuf::MessageFull>::descriptor()
                            .oneof_by_name("value")
                            .unwrap()
                    })
                    .clone()
            }
        }
        impl Value {
            pub(super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
            }
        }
    }
    pub struct ScalarValue {
        pub value: ::std::string::String,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ScalarValue {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ScalarValue {
        #[inline]
        fn eq(&self, other: &ScalarValue) -> bool {
            self.value == other.value && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ScalarValue {
        #[inline]
        fn clone(&self) -> ScalarValue {
            ScalarValue {
                value: ::core::clone::Clone::clone(&self.value),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for ScalarValue {
        #[inline]
        fn default() -> ScalarValue {
            ScalarValue {
                value: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ScalarValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "ScalarValue",
                "value",
                &&self.value,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a ScalarValue {
        fn default() -> &'a ScalarValue {
            <ScalarValue as ::protobuf::Message>::default_instance()
        }
    }
    impl ScalarValue {
        pub fn new() -> ScalarValue {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_simpler_field_accessor::<
                        _,
                        _,
                    >(
                        "value",
                        |m: &ScalarValue| { &m.value },
                        |m: &mut ScalarValue| { &mut m.value },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                ScalarValue,
            >("ScalarValue", fields, oneofs)
        }
    }
    impl ::protobuf::Message for ScalarValue {
        const NAME: &'static str = "ScalarValue";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.value = is.read_string()?;
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.value.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.value);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            if !self.value.is_empty() {
                os.write_string(1, &self.value)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> ScalarValue {
            ScalarValue::new()
        }
        fn clear(&mut self) {
            self.value.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static ScalarValue {
            static instance: ScalarValue = ScalarValue {
                value: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for ScalarValue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("ScalarValue")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for ScalarValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for ScalarValue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct VectorValue {
        pub value: ::std::vec::Vec<::std::string::String>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VectorValue {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VectorValue {
        #[inline]
        fn eq(&self, other: &VectorValue) -> bool {
            self.value == other.value && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VectorValue {
        #[inline]
        fn clone(&self) -> VectorValue {
            VectorValue {
                value: ::core::clone::Clone::clone(&self.value),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for VectorValue {
        #[inline]
        fn default() -> VectorValue {
            VectorValue {
                value: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VectorValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "VectorValue",
                "value",
                &&self.value,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a VectorValue {
        fn default() -> &'a VectorValue {
            <VectorValue as ::protobuf::Message>::default_instance()
        }
    }
    impl VectorValue {
        pub fn new() -> VectorValue {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "value",
                        |m: &VectorValue| { &m.value },
                        |m: &mut VectorValue| { &mut m.value },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                VectorValue,
            >("VectorValue", fields, oneofs)
        }
    }
    impl ::protobuf::Message for VectorValue {
        const NAME: &'static str = "VectorValue";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.value.push(is.read_string()?);
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.value {
                my_size += ::protobuf::rt::string_size(1, &value);
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            for v in &self.value {
                os.write_string(1, &v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> VectorValue {
            VectorValue::new()
        }
        fn clear(&mut self) {
            self.value.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static VectorValue {
            static instance: VectorValue = VectorValue {
                value: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for VectorValue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("VectorValue")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for VectorValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for VectorValue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    pub struct MatrixValue {
        pub value: ::std::vec::Vec<VectorValue>,
        pub special_fields: ::protobuf::SpecialFields,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MatrixValue {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MatrixValue {
        #[inline]
        fn eq(&self, other: &MatrixValue) -> bool {
            self.value == other.value && self.special_fields == other.special_fields
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MatrixValue {
        #[inline]
        fn clone(&self) -> MatrixValue {
            MatrixValue {
                value: ::core::clone::Clone::clone(&self.value),
                special_fields: ::core::clone::Clone::clone(&self.special_fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for MatrixValue {
        #[inline]
        fn default() -> MatrixValue {
            MatrixValue {
                value: ::core::default::Default::default(),
                special_fields: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for MatrixValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "MatrixValue",
                "value",
                &&self.value,
                "special_fields",
                &&self.special_fields,
            )
        }
    }
    impl<'a> ::std::default::Default for &'a MatrixValue {
        fn default() -> &'a MatrixValue {
            <MatrixValue as ::protobuf::Message>::default_instance()
        }
    }
    impl MatrixValue {
        pub fn new() -> MatrixValue {
            ::std::default::Default::default()
        }
        fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields
                .push(
                    ::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<
                        _,
                        _,
                    >(
                        "value",
                        |m: &MatrixValue| { &m.value },
                        |m: &mut MatrixValue| { &mut m.value },
                    ),
                );
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<
                MatrixValue,
            >("MatrixValue", fields, oneofs)
        }
    }
    impl ::protobuf::Message for MatrixValue {
        const NAME: &'static str = "MatrixValue";
        fn is_initialized(&self) -> bool {
            true
        }
        fn merge_from(
            &mut self,
            is: &mut ::protobuf::CodedInputStream<'_>,
        ) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.value.push(is.read_message()?);
                    }
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(
                            tag,
                            is,
                            self.special_fields.mut_unknown_fields(),
                        )?;
                    }
                };
            }
            ::std::result::Result::Ok(())
        }
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.value {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size
                += ::protobuf::rt::unknown_fields_size(
                    self.special_fields.unknown_fields(),
                );
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }
        fn write_to_with_cached_sizes(
            &self,
            os: &mut ::protobuf::CodedOutputStream<'_>,
        ) -> ::protobuf::Result<()> {
            for v in &self.value {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }
        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }
        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }
        fn new() -> MatrixValue {
            MatrixValue::new()
        }
        fn clear(&mut self) {
            self.value.clear();
            self.special_fields.clear();
        }
        fn default_instance() -> &'static MatrixValue {
            static instance: MatrixValue = MatrixValue {
                value: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
    impl ::protobuf::MessageFull for MatrixValue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::MessageDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .message_by_package_relative_name("MatrixValue")
                        .unwrap()
                })
                .clone()
        }
    }
    impl ::std::fmt::Display for MatrixValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }
    impl ::protobuf::reflect::ProtobufValue for MatrixValue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
    #[postgres(name = "transfer_type")]
    pub enum Side {
        SIDE_UNSPECIFIED = 0,
        SIDE_BUY = 1,
        SIDE_SELL = 2,
    }
    impl<'a> postgres_types::FromSql<'a> for Side {
        fn from_sql(
            _type: &postgres_types::Type,
            buf: &'a [u8],
        ) -> std::result::Result<
            Side,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            match std::str::from_utf8(buf)? {
                "SIDE_UNSPECIFIED" => std::result::Result::Ok(Side::SIDE_UNSPECIFIED),
                "SIDE_BUY" => std::result::Result::Ok(Side::SIDE_BUY),
                "SIDE_SELL" => std::result::Result::Ok(Side::SIDE_SELL),
                s => {
                    std::result::Result::Err(
                        std::convert::Into::into({
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &["invalid variant `", "`"],
                                    &[::core::fmt::ArgumentV1::new_display(&s)],
                                ),
                            );
                            res
                        }),
                    )
                }
            }
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 3usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "SIDE_UNSPECIFIED" => true,
                                "SIDE_BUY" => true,
                                "SIDE_SELL" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
    }
    impl postgres_types::ToSql for Side {
        fn to_sql(
            &self,
            _type: &postgres_types::Type,
            buf: &mut postgres_types::private::BytesMut,
        ) -> std::result::Result<
            postgres_types::IsNull,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            let s = match *self {
                Side::SIDE_UNSPECIFIED => "SIDE_UNSPECIFIED",
                Side::SIDE_BUY => "SIDE_BUY",
                Side::SIDE_SELL => "SIDE_SELL",
            };
            buf.extend_from_slice(s.as_bytes());
            std::result::Result::Ok(postgres_types::IsNull::No)
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 3usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "SIDE_UNSPECIFIED" => true,
                                "SIDE_BUY" => true,
                                "SIDE_SELL" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
        fn to_sql_checked(
            &self,
            ty: &::postgres_types::Type,
            out: &mut ::postgres_types::private::BytesMut,
        ) -> ::std::result::Result<
            ::postgres_types::IsNull,
            Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
        > {
            ::postgres_types::__to_sql_checked(self, ty, out)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Side {
        #[inline]
        fn clone(&self) -> Side {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Side {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Side {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Side {
        #[inline]
        fn eq(&self, other: &Side) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Side {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Side {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Side {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Side::SIDE_UNSPECIFIED => {
                    ::core::fmt::Formatter::write_str(f, "SIDE_UNSPECIFIED")
                }
                Side::SIDE_BUY => ::core::fmt::Formatter::write_str(f, "SIDE_BUY"),
                Side::SIDE_SELL => ::core::fmt::Formatter::write_str(f, "SIDE_SELL"),
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Side {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    impl ::protobuf::Enum for Side {
        const NAME: &'static str = "Side";
        fn value(&self) -> i32 {
            *self as i32
        }
        fn from_i32(value: i32) -> ::std::option::Option<Side> {
            match value {
                0 => ::std::option::Option::Some(Side::SIDE_UNSPECIFIED),
                1 => ::std::option::Option::Some(Side::SIDE_BUY),
                2 => ::std::option::Option::Some(Side::SIDE_SELL),
                _ => ::std::option::Option::None,
            }
        }
        const VALUES: &'static [Side] = &[
            Side::SIDE_UNSPECIFIED,
            Side::SIDE_BUY,
            Side::SIDE_SELL,
        ];
    }
    impl ::protobuf::EnumFull for Side {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::EnumDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| file_descriptor().enum_by_package_relative_name("Side").unwrap())
                .clone()
        }
        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }
    impl ::std::default::Default for Side {
        fn default() -> Self {
            Side::SIDE_UNSPECIFIED
        }
    }
    impl Side {
        fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Side>("Side")
        }
    }
    #[postgres(name = "transfer_type")]
    pub enum Interval {
        INTERVAL_UNSPECIFIED = 0,
        INTERVAL_I1M = 60,
        INTERVAL_I5M = 300,
        INTERVAL_I15M = 900,
        INTERVAL_I1H = 3600,
        INTERVAL_I6H = 21600,
        INTERVAL_I1D = 86400,
    }
    impl<'a> postgres_types::FromSql<'a> for Interval {
        fn from_sql(
            _type: &postgres_types::Type,
            buf: &'a [u8],
        ) -> std::result::Result<
            Interval,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            match std::str::from_utf8(buf)? {
                "INTERVAL_UNSPECIFIED" => {
                    std::result::Result::Ok(Interval::INTERVAL_UNSPECIFIED)
                }
                "INTERVAL_I1M" => std::result::Result::Ok(Interval::INTERVAL_I1M),
                "INTERVAL_I5M" => std::result::Result::Ok(Interval::INTERVAL_I5M),
                "INTERVAL_I15M" => std::result::Result::Ok(Interval::INTERVAL_I15M),
                "INTERVAL_I1H" => std::result::Result::Ok(Interval::INTERVAL_I1H),
                "INTERVAL_I6H" => std::result::Result::Ok(Interval::INTERVAL_I6H),
                "INTERVAL_I1D" => std::result::Result::Ok(Interval::INTERVAL_I1D),
                s => {
                    std::result::Result::Err(
                        std::convert::Into::into({
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &["invalid variant `", "`"],
                                    &[::core::fmt::ArgumentV1::new_display(&s)],
                                ),
                            );
                            res
                        }),
                    )
                }
            }
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 7usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "INTERVAL_UNSPECIFIED" => true,
                                "INTERVAL_I1M" => true,
                                "INTERVAL_I5M" => true,
                                "INTERVAL_I15M" => true,
                                "INTERVAL_I1H" => true,
                                "INTERVAL_I6H" => true,
                                "INTERVAL_I1D" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
    }
    impl postgres_types::ToSql for Interval {
        fn to_sql(
            &self,
            _type: &postgres_types::Type,
            buf: &mut postgres_types::private::BytesMut,
        ) -> std::result::Result<
            postgres_types::IsNull,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            let s = match *self {
                Interval::INTERVAL_UNSPECIFIED => "INTERVAL_UNSPECIFIED",
                Interval::INTERVAL_I1M => "INTERVAL_I1M",
                Interval::INTERVAL_I5M => "INTERVAL_I5M",
                Interval::INTERVAL_I15M => "INTERVAL_I15M",
                Interval::INTERVAL_I1H => "INTERVAL_I1H",
                Interval::INTERVAL_I6H => "INTERVAL_I6H",
                Interval::INTERVAL_I1D => "INTERVAL_I1D",
            };
            buf.extend_from_slice(s.as_bytes());
            std::result::Result::Ok(postgres_types::IsNull::No)
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 7usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "INTERVAL_UNSPECIFIED" => true,
                                "INTERVAL_I1M" => true,
                                "INTERVAL_I5M" => true,
                                "INTERVAL_I15M" => true,
                                "INTERVAL_I1H" => true,
                                "INTERVAL_I6H" => true,
                                "INTERVAL_I1D" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
        fn to_sql_checked(
            &self,
            ty: &::postgres_types::Type,
            out: &mut ::postgres_types::private::BytesMut,
        ) -> ::std::result::Result<
            ::postgres_types::IsNull,
            Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
        > {
            ::postgres_types::__to_sql_checked(self, ty, out)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Interval {
        #[inline]
        fn clone(&self) -> Interval {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Interval {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Interval {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Interval {
        #[inline]
        fn eq(&self, other: &Interval) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Interval {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Interval {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Interval {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Interval::INTERVAL_UNSPECIFIED => {
                    ::core::fmt::Formatter::write_str(f, "INTERVAL_UNSPECIFIED")
                }
                Interval::INTERVAL_I1M => {
                    ::core::fmt::Formatter::write_str(f, "INTERVAL_I1M")
                }
                Interval::INTERVAL_I5M => {
                    ::core::fmt::Formatter::write_str(f, "INTERVAL_I5M")
                }
                Interval::INTERVAL_I15M => {
                    ::core::fmt::Formatter::write_str(f, "INTERVAL_I15M")
                }
                Interval::INTERVAL_I1H => {
                    ::core::fmt::Formatter::write_str(f, "INTERVAL_I1H")
                }
                Interval::INTERVAL_I6H => {
                    ::core::fmt::Formatter::write_str(f, "INTERVAL_I6H")
                }
                Interval::INTERVAL_I1D => {
                    ::core::fmt::Formatter::write_str(f, "INTERVAL_I1D")
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Interval {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    impl ::protobuf::Enum for Interval {
        const NAME: &'static str = "Interval";
        fn value(&self) -> i32 {
            *self as i32
        }
        fn from_i32(value: i32) -> ::std::option::Option<Interval> {
            match value {
                0 => ::std::option::Option::Some(Interval::INTERVAL_UNSPECIFIED),
                60 => ::std::option::Option::Some(Interval::INTERVAL_I1M),
                300 => ::std::option::Option::Some(Interval::INTERVAL_I5M),
                900 => ::std::option::Option::Some(Interval::INTERVAL_I15M),
                3600 => ::std::option::Option::Some(Interval::INTERVAL_I1H),
                21600 => ::std::option::Option::Some(Interval::INTERVAL_I6H),
                86400 => ::std::option::Option::Some(Interval::INTERVAL_I1D),
                _ => ::std::option::Option::None,
            }
        }
        const VALUES: &'static [Interval] = &[
            Interval::INTERVAL_UNSPECIFIED,
            Interval::INTERVAL_I1M,
            Interval::INTERVAL_I5M,
            Interval::INTERVAL_I15M,
            Interval::INTERVAL_I1H,
            Interval::INTERVAL_I6H,
            Interval::INTERVAL_I1D,
        ];
    }
    impl ::protobuf::EnumFull for Interval {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::EnumDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor().enum_by_package_relative_name("Interval").unwrap()
                })
                .clone()
        }
        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Interval::INTERVAL_UNSPECIFIED => 0,
                Interval::INTERVAL_I1M => 1,
                Interval::INTERVAL_I5M => 2,
                Interval::INTERVAL_I15M => 3,
                Interval::INTERVAL_I1H => 4,
                Interval::INTERVAL_I6H => 5,
                Interval::INTERVAL_I1D => 6,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }
    impl ::std::default::Default for Interval {
        fn default() -> Self {
            Interval::INTERVAL_UNSPECIFIED
        }
    }
    impl Interval {
        fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Interval>("Interval")
        }
    }
    #[postgres(name = "transfer_type")]
    pub enum AuctionTrigger {
        AUCTION_TRIGGER_UNSPECIFIED = 0,
        AUCTION_TRIGGER_BATCH = 1,
        AUCTION_TRIGGER_OPENING = 2,
        AUCTION_TRIGGER_PRICE = 3,
        AUCTION_TRIGGER_LIQUIDITY = 4,
    }
    impl<'a> postgres_types::FromSql<'a> for AuctionTrigger {
        fn from_sql(
            _type: &postgres_types::Type,
            buf: &'a [u8],
        ) -> std::result::Result<
            AuctionTrigger,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            match std::str::from_utf8(buf)? {
                "AUCTION_TRIGGER_UNSPECIFIED" => {
                    std::result::Result::Ok(AuctionTrigger::AUCTION_TRIGGER_UNSPECIFIED)
                }
                "AUCTION_TRIGGER_BATCH" => {
                    std::result::Result::Ok(AuctionTrigger::AUCTION_TRIGGER_BATCH)
                }
                "AUCTION_TRIGGER_OPENING" => {
                    std::result::Result::Ok(AuctionTrigger::AUCTION_TRIGGER_OPENING)
                }
                "AUCTION_TRIGGER_PRICE" => {
                    std::result::Result::Ok(AuctionTrigger::AUCTION_TRIGGER_PRICE)
                }
                "AUCTION_TRIGGER_LIQUIDITY" => {
                    std::result::Result::Ok(AuctionTrigger::AUCTION_TRIGGER_LIQUIDITY)
                }
                s => {
                    std::result::Result::Err(
                        std::convert::Into::into({
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &["invalid variant `", "`"],
                                    &[::core::fmt::ArgumentV1::new_display(&s)],
                                ),
                            );
                            res
                        }),
                    )
                }
            }
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 5usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "AUCTION_TRIGGER_UNSPECIFIED" => true,
                                "AUCTION_TRIGGER_BATCH" => true,
                                "AUCTION_TRIGGER_OPENING" => true,
                                "AUCTION_TRIGGER_PRICE" => true,
                                "AUCTION_TRIGGER_LIQUIDITY" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
    }
    impl postgres_types::ToSql for AuctionTrigger {
        fn to_sql(
            &self,
            _type: &postgres_types::Type,
            buf: &mut postgres_types::private::BytesMut,
        ) -> std::result::Result<
            postgres_types::IsNull,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            let s = match *self {
                AuctionTrigger::AUCTION_TRIGGER_UNSPECIFIED => {
                    "AUCTION_TRIGGER_UNSPECIFIED"
                }
                AuctionTrigger::AUCTION_TRIGGER_BATCH => "AUCTION_TRIGGER_BATCH",
                AuctionTrigger::AUCTION_TRIGGER_OPENING => "AUCTION_TRIGGER_OPENING",
                AuctionTrigger::AUCTION_TRIGGER_PRICE => "AUCTION_TRIGGER_PRICE",
                AuctionTrigger::AUCTION_TRIGGER_LIQUIDITY => "AUCTION_TRIGGER_LIQUIDITY",
            };
            buf.extend_from_slice(s.as_bytes());
            std::result::Result::Ok(postgres_types::IsNull::No)
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 5usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "AUCTION_TRIGGER_UNSPECIFIED" => true,
                                "AUCTION_TRIGGER_BATCH" => true,
                                "AUCTION_TRIGGER_OPENING" => true,
                                "AUCTION_TRIGGER_PRICE" => true,
                                "AUCTION_TRIGGER_LIQUIDITY" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
        fn to_sql_checked(
            &self,
            ty: &::postgres_types::Type,
            out: &mut ::postgres_types::private::BytesMut,
        ) -> ::std::result::Result<
            ::postgres_types::IsNull,
            Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
        > {
            ::postgres_types::__to_sql_checked(self, ty, out)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AuctionTrigger {
        #[inline]
        fn clone(&self) -> AuctionTrigger {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for AuctionTrigger {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AuctionTrigger {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AuctionTrigger {
        #[inline]
        fn eq(&self, other: &AuctionTrigger) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for AuctionTrigger {}
    #[automatically_derived]
    impl ::core::cmp::Eq for AuctionTrigger {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AuctionTrigger {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                AuctionTrigger::AUCTION_TRIGGER_UNSPECIFIED => {
                    ::core::fmt::Formatter::write_str(f, "AUCTION_TRIGGER_UNSPECIFIED")
                }
                AuctionTrigger::AUCTION_TRIGGER_BATCH => {
                    ::core::fmt::Formatter::write_str(f, "AUCTION_TRIGGER_BATCH")
                }
                AuctionTrigger::AUCTION_TRIGGER_OPENING => {
                    ::core::fmt::Formatter::write_str(f, "AUCTION_TRIGGER_OPENING")
                }
                AuctionTrigger::AUCTION_TRIGGER_PRICE => {
                    ::core::fmt::Formatter::write_str(f, "AUCTION_TRIGGER_PRICE")
                }
                AuctionTrigger::AUCTION_TRIGGER_LIQUIDITY => {
                    ::core::fmt::Formatter::write_str(f, "AUCTION_TRIGGER_LIQUIDITY")
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for AuctionTrigger {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    impl ::protobuf::Enum for AuctionTrigger {
        const NAME: &'static str = "AuctionTrigger";
        fn value(&self) -> i32 {
            *self as i32
        }
        fn from_i32(value: i32) -> ::std::option::Option<AuctionTrigger> {
            match value {
                0 => {
                    ::std::option::Option::Some(
                        AuctionTrigger::AUCTION_TRIGGER_UNSPECIFIED,
                    )
                }
                1 => ::std::option::Option::Some(AuctionTrigger::AUCTION_TRIGGER_BATCH),
                2 => ::std::option::Option::Some(AuctionTrigger::AUCTION_TRIGGER_OPENING),
                3 => ::std::option::Option::Some(AuctionTrigger::AUCTION_TRIGGER_PRICE),
                4 => {
                    ::std::option::Option::Some(
                        AuctionTrigger::AUCTION_TRIGGER_LIQUIDITY,
                    )
                }
                _ => ::std::option::Option::None,
            }
        }
        const VALUES: &'static [AuctionTrigger] = &[
            AuctionTrigger::AUCTION_TRIGGER_UNSPECIFIED,
            AuctionTrigger::AUCTION_TRIGGER_BATCH,
            AuctionTrigger::AUCTION_TRIGGER_OPENING,
            AuctionTrigger::AUCTION_TRIGGER_PRICE,
            AuctionTrigger::AUCTION_TRIGGER_LIQUIDITY,
        ];
    }
    impl ::protobuf::EnumFull for AuctionTrigger {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::EnumDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .enum_by_package_relative_name("AuctionTrigger")
                        .unwrap()
                })
                .clone()
        }
        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }
    impl ::std::default::Default for AuctionTrigger {
        fn default() -> Self {
            AuctionTrigger::AUCTION_TRIGGER_UNSPECIFIED
        }
    }
    impl AuctionTrigger {
        fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<
                AuctionTrigger,
            >("AuctionTrigger")
        }
    }
    #[postgres(name = "transfer_type")]
    pub enum PeggedReference {
        PEGGED_REFERENCE_UNSPECIFIED = 0,
        PEGGED_REFERENCE_MID = 1,
        PEGGED_REFERENCE_BEST_BID = 2,
        PEGGED_REFERENCE_BEST_ASK = 3,
    }
    impl<'a> postgres_types::FromSql<'a> for PeggedReference {
        fn from_sql(
            _type: &postgres_types::Type,
            buf: &'a [u8],
        ) -> std::result::Result<
            PeggedReference,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            match std::str::from_utf8(buf)? {
                "PEGGED_REFERENCE_UNSPECIFIED" => {
                    std::result::Result::Ok(
                        PeggedReference::PEGGED_REFERENCE_UNSPECIFIED,
                    )
                }
                "PEGGED_REFERENCE_MID" => {
                    std::result::Result::Ok(PeggedReference::PEGGED_REFERENCE_MID)
                }
                "PEGGED_REFERENCE_BEST_BID" => {
                    std::result::Result::Ok(PeggedReference::PEGGED_REFERENCE_BEST_BID)
                }
                "PEGGED_REFERENCE_BEST_ASK" => {
                    std::result::Result::Ok(PeggedReference::PEGGED_REFERENCE_BEST_ASK)
                }
                s => {
                    std::result::Result::Err(
                        std::convert::Into::into({
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &["invalid variant `", "`"],
                                    &[::core::fmt::ArgumentV1::new_display(&s)],
                                ),
                            );
                            res
                        }),
                    )
                }
            }
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 4usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "PEGGED_REFERENCE_UNSPECIFIED" => true,
                                "PEGGED_REFERENCE_MID" => true,
                                "PEGGED_REFERENCE_BEST_BID" => true,
                                "PEGGED_REFERENCE_BEST_ASK" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
    }
    impl postgres_types::ToSql for PeggedReference {
        fn to_sql(
            &self,
            _type: &postgres_types::Type,
            buf: &mut postgres_types::private::BytesMut,
        ) -> std::result::Result<
            postgres_types::IsNull,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            let s = match *self {
                PeggedReference::PEGGED_REFERENCE_UNSPECIFIED => {
                    "PEGGED_REFERENCE_UNSPECIFIED"
                }
                PeggedReference::PEGGED_REFERENCE_MID => "PEGGED_REFERENCE_MID",
                PeggedReference::PEGGED_REFERENCE_BEST_BID => "PEGGED_REFERENCE_BEST_BID",
                PeggedReference::PEGGED_REFERENCE_BEST_ASK => "PEGGED_REFERENCE_BEST_ASK",
            };
            buf.extend_from_slice(s.as_bytes());
            std::result::Result::Ok(postgres_types::IsNull::No)
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 4usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "PEGGED_REFERENCE_UNSPECIFIED" => true,
                                "PEGGED_REFERENCE_MID" => true,
                                "PEGGED_REFERENCE_BEST_BID" => true,
                                "PEGGED_REFERENCE_BEST_ASK" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
        fn to_sql_checked(
            &self,
            ty: &::postgres_types::Type,
            out: &mut ::postgres_types::private::BytesMut,
        ) -> ::std::result::Result<
            ::postgres_types::IsNull,
            Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
        > {
            ::postgres_types::__to_sql_checked(self, ty, out)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PeggedReference {
        #[inline]
        fn clone(&self) -> PeggedReference {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for PeggedReference {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PeggedReference {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PeggedReference {
        #[inline]
        fn eq(&self, other: &PeggedReference) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for PeggedReference {}
    #[automatically_derived]
    impl ::core::cmp::Eq for PeggedReference {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PeggedReference {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                PeggedReference::PEGGED_REFERENCE_UNSPECIFIED => {
                    ::core::fmt::Formatter::write_str(f, "PEGGED_REFERENCE_UNSPECIFIED")
                }
                PeggedReference::PEGGED_REFERENCE_MID => {
                    ::core::fmt::Formatter::write_str(f, "PEGGED_REFERENCE_MID")
                }
                PeggedReference::PEGGED_REFERENCE_BEST_BID => {
                    ::core::fmt::Formatter::write_str(f, "PEGGED_REFERENCE_BEST_BID")
                }
                PeggedReference::PEGGED_REFERENCE_BEST_ASK => {
                    ::core::fmt::Formatter::write_str(f, "PEGGED_REFERENCE_BEST_ASK")
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for PeggedReference {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    impl ::protobuf::Enum for PeggedReference {
        const NAME: &'static str = "PeggedReference";
        fn value(&self) -> i32 {
            *self as i32
        }
        fn from_i32(value: i32) -> ::std::option::Option<PeggedReference> {
            match value {
                0 => {
                    ::std::option::Option::Some(
                        PeggedReference::PEGGED_REFERENCE_UNSPECIFIED,
                    )
                }
                1 => ::std::option::Option::Some(PeggedReference::PEGGED_REFERENCE_MID),
                2 => {
                    ::std::option::Option::Some(
                        PeggedReference::PEGGED_REFERENCE_BEST_BID,
                    )
                }
                3 => {
                    ::std::option::Option::Some(
                        PeggedReference::PEGGED_REFERENCE_BEST_ASK,
                    )
                }
                _ => ::std::option::Option::None,
            }
        }
        const VALUES: &'static [PeggedReference] = &[
            PeggedReference::PEGGED_REFERENCE_UNSPECIFIED,
            PeggedReference::PEGGED_REFERENCE_MID,
            PeggedReference::PEGGED_REFERENCE_BEST_BID,
            PeggedReference::PEGGED_REFERENCE_BEST_ASK,
        ];
    }
    impl ::protobuf::EnumFull for PeggedReference {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::EnumDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .enum_by_package_relative_name("PeggedReference")
                        .unwrap()
                })
                .clone()
        }
        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }
    impl ::std::default::Default for PeggedReference {
        fn default() -> Self {
            PeggedReference::PEGGED_REFERENCE_UNSPECIFIED
        }
    }
    impl PeggedReference {
        fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<
                PeggedReference,
            >("PeggedReference")
        }
    }
    #[postgres(name = "transfer_type")]
    pub enum OrderError {
        ORDER_ERROR_UNSPECIFIED = 0,
        ORDER_ERROR_INVALID_MARKET_ID = 1,
        ORDER_ERROR_INVALID_ORDER_ID = 2,
        ORDER_ERROR_OUT_OF_SEQUENCE = 3,
        ORDER_ERROR_INVALID_REMAINING_SIZE = 4,
        ORDER_ERROR_TIME_FAILURE = 5,
        ORDER_ERROR_REMOVAL_FAILURE = 6,
        ORDER_ERROR_INVALID_EXPIRATION_DATETIME = 7,
        ORDER_ERROR_INVALID_ORDER_REFERENCE = 8,
        ORDER_ERROR_EDIT_NOT_ALLOWED = 9,
        ORDER_ERROR_AMEND_FAILURE = 10,
        ORDER_ERROR_NOT_FOUND = 11,
        ORDER_ERROR_INVALID_PARTY_ID = 12,
        ORDER_ERROR_MARKET_CLOSED = 13,
        ORDER_ERROR_MARGIN_CHECK_FAILED = 14,
        ORDER_ERROR_MISSING_GENERAL_ACCOUNT = 15,
        ORDER_ERROR_INTERNAL_ERROR = 16,
        ORDER_ERROR_INVALID_SIZE = 17,
        ORDER_ERROR_INVALID_PERSISTENCE = 18,
        ORDER_ERROR_INVALID_TYPE = 19,
        ORDER_ERROR_SELF_TRADING = 20,
        ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES = 21,
        ORDER_ERROR_INCORRECT_MARKET_TYPE = 22,
        ORDER_ERROR_INVALID_TIME_IN_FORCE = 23,
        ORDER_ERROR_GFN_ORDER_DURING_AN_AUCTION = 24,
        ORDER_ERROR_GFA_ORDER_DURING_CONTINUOUS_TRADING = 25,
        ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT = 26,
        ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT = 27,
        ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT = 28,
        ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC = 29,
        ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN = 30,
        ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN = 31,
        ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION = 32,
        ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION = 33,
        ORDER_ERROR_MUST_BE_LIMIT_ORDER = 34,
        ORDER_ERROR_MUST_BE_GTT_OR_GTC = 35,
        ORDER_ERROR_WITHOUT_REFERENCE_PRICE = 36,
        ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE = 37,
        ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO = 40,
        ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE = 41,
        ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO = 42,
        ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE = 43,
        ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER = 44,
        ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER = 45,
        ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER = 46,
        ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS = 47,
    }
    impl<'a> postgres_types::FromSql<'a> for OrderError {
        fn from_sql(
            _type: &postgres_types::Type,
            buf: &'a [u8],
        ) -> std::result::Result<
            OrderError,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            match std::str::from_utf8(buf)? {
                "ORDER_ERROR_UNSPECIFIED" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_UNSPECIFIED)
                }
                "ORDER_ERROR_INVALID_MARKET_ID" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_INVALID_MARKET_ID)
                }
                "ORDER_ERROR_INVALID_ORDER_ID" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_INVALID_ORDER_ID)
                }
                "ORDER_ERROR_OUT_OF_SEQUENCE" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_OUT_OF_SEQUENCE)
                }
                "ORDER_ERROR_INVALID_REMAINING_SIZE" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_INVALID_REMAINING_SIZE,
                    )
                }
                "ORDER_ERROR_TIME_FAILURE" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_TIME_FAILURE)
                }
                "ORDER_ERROR_REMOVAL_FAILURE" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_REMOVAL_FAILURE)
                }
                "ORDER_ERROR_INVALID_EXPIRATION_DATETIME" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_INVALID_EXPIRATION_DATETIME,
                    )
                }
                "ORDER_ERROR_INVALID_ORDER_REFERENCE" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_INVALID_ORDER_REFERENCE,
                    )
                }
                "ORDER_ERROR_EDIT_NOT_ALLOWED" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_EDIT_NOT_ALLOWED)
                }
                "ORDER_ERROR_AMEND_FAILURE" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_AMEND_FAILURE)
                }
                "ORDER_ERROR_NOT_FOUND" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_NOT_FOUND)
                }
                "ORDER_ERROR_INVALID_PARTY_ID" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_INVALID_PARTY_ID)
                }
                "ORDER_ERROR_MARKET_CLOSED" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_MARKET_CLOSED)
                }
                "ORDER_ERROR_MARGIN_CHECK_FAILED" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_MARGIN_CHECK_FAILED)
                }
                "ORDER_ERROR_MISSING_GENERAL_ACCOUNT" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_MISSING_GENERAL_ACCOUNT,
                    )
                }
                "ORDER_ERROR_INTERNAL_ERROR" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_INTERNAL_ERROR)
                }
                "ORDER_ERROR_INVALID_SIZE" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_INVALID_SIZE)
                }
                "ORDER_ERROR_INVALID_PERSISTENCE" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_INVALID_PERSISTENCE)
                }
                "ORDER_ERROR_INVALID_TYPE" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_INVALID_TYPE)
                }
                "ORDER_ERROR_SELF_TRADING" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_SELF_TRADING)
                }
                "ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES,
                    )
                }
                "ORDER_ERROR_INCORRECT_MARKET_TYPE" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_INCORRECT_MARKET_TYPE,
                    )
                }
                "ORDER_ERROR_INVALID_TIME_IN_FORCE" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_INVALID_TIME_IN_FORCE,
                    )
                }
                "ORDER_ERROR_GFN_ORDER_DURING_AN_AUCTION" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_GFN_ORDER_DURING_AN_AUCTION,
                    )
                }
                "ORDER_ERROR_GFA_ORDER_DURING_CONTINUOUS_TRADING" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_GFA_ORDER_DURING_CONTINUOUS_TRADING,
                    )
                }
                "ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT,
                    )
                }
                "ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT,
                    )
                }
                "ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT,
                    )
                }
                "ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC,
                    )
                }
                "ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN,
                    )
                }
                "ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN,
                    )
                }
                "ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION,
                    )
                }
                "ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION,
                    )
                }
                "ORDER_ERROR_MUST_BE_LIMIT_ORDER" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_MUST_BE_LIMIT_ORDER)
                }
                "ORDER_ERROR_MUST_BE_GTT_OR_GTC" => {
                    std::result::Result::Ok(OrderError::ORDER_ERROR_MUST_BE_GTT_OR_GTC)
                }
                "ORDER_ERROR_WITHOUT_REFERENCE_PRICE" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_WITHOUT_REFERENCE_PRICE,
                    )
                }
                "ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE,
                    )
                }
                "ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO,
                    )
                }
                "ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE,
                    )
                }
                "ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO,
                    )
                }
                "ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE,
                    )
                }
                "ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER,
                    )
                }
                "ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER,
                    )
                }
                "ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER,
                    )
                }
                "ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS" => {
                    std::result::Result::Ok(
                        OrderError::ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS,
                    )
                }
                s => {
                    std::result::Result::Err(
                        std::convert::Into::into({
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &["invalid variant `", "`"],
                                    &[::core::fmt::ArgumentV1::new_display(&s)],
                                ),
                            );
                            res
                        }),
                    )
                }
            }
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 46usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "ORDER_ERROR_UNSPECIFIED" => true,
                                "ORDER_ERROR_INVALID_MARKET_ID" => true,
                                "ORDER_ERROR_INVALID_ORDER_ID" => true,
                                "ORDER_ERROR_OUT_OF_SEQUENCE" => true,
                                "ORDER_ERROR_INVALID_REMAINING_SIZE" => true,
                                "ORDER_ERROR_TIME_FAILURE" => true,
                                "ORDER_ERROR_REMOVAL_FAILURE" => true,
                                "ORDER_ERROR_INVALID_EXPIRATION_DATETIME" => true,
                                "ORDER_ERROR_INVALID_ORDER_REFERENCE" => true,
                                "ORDER_ERROR_EDIT_NOT_ALLOWED" => true,
                                "ORDER_ERROR_AMEND_FAILURE" => true,
                                "ORDER_ERROR_NOT_FOUND" => true,
                                "ORDER_ERROR_INVALID_PARTY_ID" => true,
                                "ORDER_ERROR_MARKET_CLOSED" => true,
                                "ORDER_ERROR_MARGIN_CHECK_FAILED" => true,
                                "ORDER_ERROR_MISSING_GENERAL_ACCOUNT" => true,
                                "ORDER_ERROR_INTERNAL_ERROR" => true,
                                "ORDER_ERROR_INVALID_SIZE" => true,
                                "ORDER_ERROR_INVALID_PERSISTENCE" => true,
                                "ORDER_ERROR_INVALID_TYPE" => true,
                                "ORDER_ERROR_SELF_TRADING" => true,
                                "ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES" => true,
                                "ORDER_ERROR_INCORRECT_MARKET_TYPE" => true,
                                "ORDER_ERROR_INVALID_TIME_IN_FORCE" => true,
                                "ORDER_ERROR_GFN_ORDER_DURING_AN_AUCTION" => true,
                                "ORDER_ERROR_GFA_ORDER_DURING_CONTINUOUS_TRADING" => true,
                                "ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT" => true,
                                "ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT" => true,
                                "ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT" => true,
                                "ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC" => true,
                                "ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN" => true,
                                "ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN" => true,
                                "ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION" => true,
                                "ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION" => true,
                                "ORDER_ERROR_MUST_BE_LIMIT_ORDER" => true,
                                "ORDER_ERROR_MUST_BE_GTT_OR_GTC" => true,
                                "ORDER_ERROR_WITHOUT_REFERENCE_PRICE" => true,
                                "ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE" => true,
                                "ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO" => {
                                    true
                                }
                                "ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE" => true,
                                "ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO" => true,
                                "ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE" => true,
                                "ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER" => {
                                    true
                                }
                                "ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER" => true,
                                "ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER" => true,
                                "ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS" => {
                                    true
                                }
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
    }
    impl postgres_types::ToSql for OrderError {
        fn to_sql(
            &self,
            _type: &postgres_types::Type,
            buf: &mut postgres_types::private::BytesMut,
        ) -> std::result::Result<
            postgres_types::IsNull,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            let s = match *self {
                OrderError::ORDER_ERROR_UNSPECIFIED => "ORDER_ERROR_UNSPECIFIED",
                OrderError::ORDER_ERROR_INVALID_MARKET_ID => {
                    "ORDER_ERROR_INVALID_MARKET_ID"
                }
                OrderError::ORDER_ERROR_INVALID_ORDER_ID => {
                    "ORDER_ERROR_INVALID_ORDER_ID"
                }
                OrderError::ORDER_ERROR_OUT_OF_SEQUENCE => "ORDER_ERROR_OUT_OF_SEQUENCE",
                OrderError::ORDER_ERROR_INVALID_REMAINING_SIZE => {
                    "ORDER_ERROR_INVALID_REMAINING_SIZE"
                }
                OrderError::ORDER_ERROR_TIME_FAILURE => "ORDER_ERROR_TIME_FAILURE",
                OrderError::ORDER_ERROR_REMOVAL_FAILURE => "ORDER_ERROR_REMOVAL_FAILURE",
                OrderError::ORDER_ERROR_INVALID_EXPIRATION_DATETIME => {
                    "ORDER_ERROR_INVALID_EXPIRATION_DATETIME"
                }
                OrderError::ORDER_ERROR_INVALID_ORDER_REFERENCE => {
                    "ORDER_ERROR_INVALID_ORDER_REFERENCE"
                }
                OrderError::ORDER_ERROR_EDIT_NOT_ALLOWED => {
                    "ORDER_ERROR_EDIT_NOT_ALLOWED"
                }
                OrderError::ORDER_ERROR_AMEND_FAILURE => "ORDER_ERROR_AMEND_FAILURE",
                OrderError::ORDER_ERROR_NOT_FOUND => "ORDER_ERROR_NOT_FOUND",
                OrderError::ORDER_ERROR_INVALID_PARTY_ID => {
                    "ORDER_ERROR_INVALID_PARTY_ID"
                }
                OrderError::ORDER_ERROR_MARKET_CLOSED => "ORDER_ERROR_MARKET_CLOSED",
                OrderError::ORDER_ERROR_MARGIN_CHECK_FAILED => {
                    "ORDER_ERROR_MARGIN_CHECK_FAILED"
                }
                OrderError::ORDER_ERROR_MISSING_GENERAL_ACCOUNT => {
                    "ORDER_ERROR_MISSING_GENERAL_ACCOUNT"
                }
                OrderError::ORDER_ERROR_INTERNAL_ERROR => "ORDER_ERROR_INTERNAL_ERROR",
                OrderError::ORDER_ERROR_INVALID_SIZE => "ORDER_ERROR_INVALID_SIZE",
                OrderError::ORDER_ERROR_INVALID_PERSISTENCE => {
                    "ORDER_ERROR_INVALID_PERSISTENCE"
                }
                OrderError::ORDER_ERROR_INVALID_TYPE => "ORDER_ERROR_INVALID_TYPE",
                OrderError::ORDER_ERROR_SELF_TRADING => "ORDER_ERROR_SELF_TRADING",
                OrderError::ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES => {
                    "ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES"
                }
                OrderError::ORDER_ERROR_INCORRECT_MARKET_TYPE => {
                    "ORDER_ERROR_INCORRECT_MARKET_TYPE"
                }
                OrderError::ORDER_ERROR_INVALID_TIME_IN_FORCE => {
                    "ORDER_ERROR_INVALID_TIME_IN_FORCE"
                }
                OrderError::ORDER_ERROR_GFN_ORDER_DURING_AN_AUCTION => {
                    "ORDER_ERROR_GFN_ORDER_DURING_AN_AUCTION"
                }
                OrderError::ORDER_ERROR_GFA_ORDER_DURING_CONTINUOUS_TRADING => {
                    "ORDER_ERROR_GFA_ORDER_DURING_CONTINUOUS_TRADING"
                }
                OrderError::ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT => {
                    "ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT"
                }
                OrderError::ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT => {
                    "ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT"
                }
                OrderError::ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT => {
                    "ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT"
                }
                OrderError::ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC => {
                    "ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC"
                }
                OrderError::ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN => {
                    "ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN"
                }
                OrderError::ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN => {
                    "ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN"
                }
                OrderError::ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION => {
                    "ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION"
                }
                OrderError::ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION => {
                    "ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION"
                }
                OrderError::ORDER_ERROR_MUST_BE_LIMIT_ORDER => {
                    "ORDER_ERROR_MUST_BE_LIMIT_ORDER"
                }
                OrderError::ORDER_ERROR_MUST_BE_GTT_OR_GTC => {
                    "ORDER_ERROR_MUST_BE_GTT_OR_GTC"
                }
                OrderError::ORDER_ERROR_WITHOUT_REFERENCE_PRICE => {
                    "ORDER_ERROR_WITHOUT_REFERENCE_PRICE"
                }
                OrderError::ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE => {
                    "ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE"
                }
                OrderError::ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO => {
                    "ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO"
                }
                OrderError::ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE => {
                    "ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE"
                }
                OrderError::ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO => {
                    "ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO"
                }
                OrderError::ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE => {
                    "ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE"
                }
                OrderError::ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER => {
                    "ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER"
                }
                OrderError::ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER => {
                    "ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER"
                }
                OrderError::ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER => {
                    "ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER"
                }
                OrderError::ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS => {
                    "ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS"
                }
            };
            buf.extend_from_slice(s.as_bytes());
            std::result::Result::Ok(postgres_types::IsNull::No)
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 46usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "ORDER_ERROR_UNSPECIFIED" => true,
                                "ORDER_ERROR_INVALID_MARKET_ID" => true,
                                "ORDER_ERROR_INVALID_ORDER_ID" => true,
                                "ORDER_ERROR_OUT_OF_SEQUENCE" => true,
                                "ORDER_ERROR_INVALID_REMAINING_SIZE" => true,
                                "ORDER_ERROR_TIME_FAILURE" => true,
                                "ORDER_ERROR_REMOVAL_FAILURE" => true,
                                "ORDER_ERROR_INVALID_EXPIRATION_DATETIME" => true,
                                "ORDER_ERROR_INVALID_ORDER_REFERENCE" => true,
                                "ORDER_ERROR_EDIT_NOT_ALLOWED" => true,
                                "ORDER_ERROR_AMEND_FAILURE" => true,
                                "ORDER_ERROR_NOT_FOUND" => true,
                                "ORDER_ERROR_INVALID_PARTY_ID" => true,
                                "ORDER_ERROR_MARKET_CLOSED" => true,
                                "ORDER_ERROR_MARGIN_CHECK_FAILED" => true,
                                "ORDER_ERROR_MISSING_GENERAL_ACCOUNT" => true,
                                "ORDER_ERROR_INTERNAL_ERROR" => true,
                                "ORDER_ERROR_INVALID_SIZE" => true,
                                "ORDER_ERROR_INVALID_PERSISTENCE" => true,
                                "ORDER_ERROR_INVALID_TYPE" => true,
                                "ORDER_ERROR_SELF_TRADING" => true,
                                "ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES" => true,
                                "ORDER_ERROR_INCORRECT_MARKET_TYPE" => true,
                                "ORDER_ERROR_INVALID_TIME_IN_FORCE" => true,
                                "ORDER_ERROR_GFN_ORDER_DURING_AN_AUCTION" => true,
                                "ORDER_ERROR_GFA_ORDER_DURING_CONTINUOUS_TRADING" => true,
                                "ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT" => true,
                                "ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT" => true,
                                "ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT" => true,
                                "ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC" => true,
                                "ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN" => true,
                                "ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN" => true,
                                "ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION" => true,
                                "ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION" => true,
                                "ORDER_ERROR_MUST_BE_LIMIT_ORDER" => true,
                                "ORDER_ERROR_MUST_BE_GTT_OR_GTC" => true,
                                "ORDER_ERROR_WITHOUT_REFERENCE_PRICE" => true,
                                "ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE" => true,
                                "ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO" => {
                                    true
                                }
                                "ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE" => true,
                                "ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO" => true,
                                "ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE" => true,
                                "ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER" => {
                                    true
                                }
                                "ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER" => true,
                                "ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER" => true,
                                "ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS" => {
                                    true
                                }
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
        fn to_sql_checked(
            &self,
            ty: &::postgres_types::Type,
            out: &mut ::postgres_types::private::BytesMut,
        ) -> ::std::result::Result<
            ::postgres_types::IsNull,
            Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
        > {
            ::postgres_types::__to_sql_checked(self, ty, out)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for OrderError {
        #[inline]
        fn clone(&self) -> OrderError {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for OrderError {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OrderError {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OrderError {
        #[inline]
        fn eq(&self, other: &OrderError) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for OrderError {}
    #[automatically_derived]
    impl ::core::cmp::Eq for OrderError {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for OrderError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                OrderError::ORDER_ERROR_UNSPECIFIED => {
                    ::core::fmt::Formatter::write_str(f, "ORDER_ERROR_UNSPECIFIED")
                }
                OrderError::ORDER_ERROR_INVALID_MARKET_ID => {
                    ::core::fmt::Formatter::write_str(f, "ORDER_ERROR_INVALID_MARKET_ID")
                }
                OrderError::ORDER_ERROR_INVALID_ORDER_ID => {
                    ::core::fmt::Formatter::write_str(f, "ORDER_ERROR_INVALID_ORDER_ID")
                }
                OrderError::ORDER_ERROR_OUT_OF_SEQUENCE => {
                    ::core::fmt::Formatter::write_str(f, "ORDER_ERROR_OUT_OF_SEQUENCE")
                }
                OrderError::ORDER_ERROR_INVALID_REMAINING_SIZE => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_INVALID_REMAINING_SIZE",
                    )
                }
                OrderError::ORDER_ERROR_TIME_FAILURE => {
                    ::core::fmt::Formatter::write_str(f, "ORDER_ERROR_TIME_FAILURE")
                }
                OrderError::ORDER_ERROR_REMOVAL_FAILURE => {
                    ::core::fmt::Formatter::write_str(f, "ORDER_ERROR_REMOVAL_FAILURE")
                }
                OrderError::ORDER_ERROR_INVALID_EXPIRATION_DATETIME => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_INVALID_EXPIRATION_DATETIME",
                    )
                }
                OrderError::ORDER_ERROR_INVALID_ORDER_REFERENCE => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_INVALID_ORDER_REFERENCE",
                    )
                }
                OrderError::ORDER_ERROR_EDIT_NOT_ALLOWED => {
                    ::core::fmt::Formatter::write_str(f, "ORDER_ERROR_EDIT_NOT_ALLOWED")
                }
                OrderError::ORDER_ERROR_AMEND_FAILURE => {
                    ::core::fmt::Formatter::write_str(f, "ORDER_ERROR_AMEND_FAILURE")
                }
                OrderError::ORDER_ERROR_NOT_FOUND => {
                    ::core::fmt::Formatter::write_str(f, "ORDER_ERROR_NOT_FOUND")
                }
                OrderError::ORDER_ERROR_INVALID_PARTY_ID => {
                    ::core::fmt::Formatter::write_str(f, "ORDER_ERROR_INVALID_PARTY_ID")
                }
                OrderError::ORDER_ERROR_MARKET_CLOSED => {
                    ::core::fmt::Formatter::write_str(f, "ORDER_ERROR_MARKET_CLOSED")
                }
                OrderError::ORDER_ERROR_MARGIN_CHECK_FAILED => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_MARGIN_CHECK_FAILED",
                    )
                }
                OrderError::ORDER_ERROR_MISSING_GENERAL_ACCOUNT => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_MISSING_GENERAL_ACCOUNT",
                    )
                }
                OrderError::ORDER_ERROR_INTERNAL_ERROR => {
                    ::core::fmt::Formatter::write_str(f, "ORDER_ERROR_INTERNAL_ERROR")
                }
                OrderError::ORDER_ERROR_INVALID_SIZE => {
                    ::core::fmt::Formatter::write_str(f, "ORDER_ERROR_INVALID_SIZE")
                }
                OrderError::ORDER_ERROR_INVALID_PERSISTENCE => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_INVALID_PERSISTENCE",
                    )
                }
                OrderError::ORDER_ERROR_INVALID_TYPE => {
                    ::core::fmt::Formatter::write_str(f, "ORDER_ERROR_INVALID_TYPE")
                }
                OrderError::ORDER_ERROR_SELF_TRADING => {
                    ::core::fmt::Formatter::write_str(f, "ORDER_ERROR_SELF_TRADING")
                }
                OrderError::ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES",
                    )
                }
                OrderError::ORDER_ERROR_INCORRECT_MARKET_TYPE => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_INCORRECT_MARKET_TYPE",
                    )
                }
                OrderError::ORDER_ERROR_INVALID_TIME_IN_FORCE => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_INVALID_TIME_IN_FORCE",
                    )
                }
                OrderError::ORDER_ERROR_GFN_ORDER_DURING_AN_AUCTION => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_GFN_ORDER_DURING_AN_AUCTION",
                    )
                }
                OrderError::ORDER_ERROR_GFA_ORDER_DURING_CONTINUOUS_TRADING => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_GFA_ORDER_DURING_CONTINUOUS_TRADING",
                    )
                }
                OrderError::ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT",
                    )
                }
                OrderError::ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT",
                    )
                }
                OrderError::ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT",
                    )
                }
                OrderError::ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC",
                    )
                }
                OrderError::ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN",
                    )
                }
                OrderError::ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN",
                    )
                }
                OrderError::ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION",
                    )
                }
                OrderError::ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION",
                    )
                }
                OrderError::ORDER_ERROR_MUST_BE_LIMIT_ORDER => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_MUST_BE_LIMIT_ORDER",
                    )
                }
                OrderError::ORDER_ERROR_MUST_BE_GTT_OR_GTC => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_MUST_BE_GTT_OR_GTC",
                    )
                }
                OrderError::ORDER_ERROR_WITHOUT_REFERENCE_PRICE => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_WITHOUT_REFERENCE_PRICE",
                    )
                }
                OrderError::ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE",
                    )
                }
                OrderError::ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO",
                    )
                }
                OrderError::ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE",
                    )
                }
                OrderError::ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO",
                    )
                }
                OrderError::ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE",
                    )
                }
                OrderError::ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER",
                    )
                }
                OrderError::ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER",
                    )
                }
                OrderError::ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER",
                    )
                }
                OrderError::ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS",
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for OrderError {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    impl ::protobuf::Enum for OrderError {
        const NAME: &'static str = "OrderError";
        fn value(&self) -> i32 {
            *self as i32
        }
        fn from_i32(value: i32) -> ::std::option::Option<OrderError> {
            match value {
                0 => ::std::option::Option::Some(OrderError::ORDER_ERROR_UNSPECIFIED),
                1 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_INVALID_MARKET_ID,
                    )
                }
                2 => {
                    ::std::option::Option::Some(OrderError::ORDER_ERROR_INVALID_ORDER_ID)
                }
                3 => ::std::option::Option::Some(OrderError::ORDER_ERROR_OUT_OF_SEQUENCE),
                4 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_INVALID_REMAINING_SIZE,
                    )
                }
                5 => ::std::option::Option::Some(OrderError::ORDER_ERROR_TIME_FAILURE),
                6 => ::std::option::Option::Some(OrderError::ORDER_ERROR_REMOVAL_FAILURE),
                7 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_INVALID_EXPIRATION_DATETIME,
                    )
                }
                8 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_INVALID_ORDER_REFERENCE,
                    )
                }
                9 => {
                    ::std::option::Option::Some(OrderError::ORDER_ERROR_EDIT_NOT_ALLOWED)
                }
                10 => ::std::option::Option::Some(OrderError::ORDER_ERROR_AMEND_FAILURE),
                11 => ::std::option::Option::Some(OrderError::ORDER_ERROR_NOT_FOUND),
                12 => {
                    ::std::option::Option::Some(OrderError::ORDER_ERROR_INVALID_PARTY_ID)
                }
                13 => ::std::option::Option::Some(OrderError::ORDER_ERROR_MARKET_CLOSED),
                14 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_MARGIN_CHECK_FAILED,
                    )
                }
                15 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_MISSING_GENERAL_ACCOUNT,
                    )
                }
                16 => ::std::option::Option::Some(OrderError::ORDER_ERROR_INTERNAL_ERROR),
                17 => ::std::option::Option::Some(OrderError::ORDER_ERROR_INVALID_SIZE),
                18 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_INVALID_PERSISTENCE,
                    )
                }
                19 => ::std::option::Option::Some(OrderError::ORDER_ERROR_INVALID_TYPE),
                20 => ::std::option::Option::Some(OrderError::ORDER_ERROR_SELF_TRADING),
                21 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES,
                    )
                }
                22 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_INCORRECT_MARKET_TYPE,
                    )
                }
                23 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_INVALID_TIME_IN_FORCE,
                    )
                }
                24 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_GFN_ORDER_DURING_AN_AUCTION,
                    )
                }
                25 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_GFA_ORDER_DURING_CONTINUOUS_TRADING,
                    )
                }
                26 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT,
                    )
                }
                27 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT,
                    )
                }
                28 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT,
                    )
                }
                29 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC,
                    )
                }
                30 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN,
                    )
                }
                31 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN,
                    )
                }
                32 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION,
                    )
                }
                33 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION,
                    )
                }
                34 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_MUST_BE_LIMIT_ORDER,
                    )
                }
                35 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_MUST_BE_GTT_OR_GTC,
                    )
                }
                36 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_WITHOUT_REFERENCE_PRICE,
                    )
                }
                37 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE,
                    )
                }
                40 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO,
                    )
                }
                41 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE,
                    )
                }
                42 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO,
                    )
                }
                43 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE,
                    )
                }
                44 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER,
                    )
                }
                45 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER,
                    )
                }
                46 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER,
                    )
                }
                47 => {
                    ::std::option::Option::Some(
                        OrderError::ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS,
                    )
                }
                _ => ::std::option::Option::None,
            }
        }
        const VALUES: &'static [OrderError] = &[
            OrderError::ORDER_ERROR_UNSPECIFIED,
            OrderError::ORDER_ERROR_INVALID_MARKET_ID,
            OrderError::ORDER_ERROR_INVALID_ORDER_ID,
            OrderError::ORDER_ERROR_OUT_OF_SEQUENCE,
            OrderError::ORDER_ERROR_INVALID_REMAINING_SIZE,
            OrderError::ORDER_ERROR_TIME_FAILURE,
            OrderError::ORDER_ERROR_REMOVAL_FAILURE,
            OrderError::ORDER_ERROR_INVALID_EXPIRATION_DATETIME,
            OrderError::ORDER_ERROR_INVALID_ORDER_REFERENCE,
            OrderError::ORDER_ERROR_EDIT_NOT_ALLOWED,
            OrderError::ORDER_ERROR_AMEND_FAILURE,
            OrderError::ORDER_ERROR_NOT_FOUND,
            OrderError::ORDER_ERROR_INVALID_PARTY_ID,
            OrderError::ORDER_ERROR_MARKET_CLOSED,
            OrderError::ORDER_ERROR_MARGIN_CHECK_FAILED,
            OrderError::ORDER_ERROR_MISSING_GENERAL_ACCOUNT,
            OrderError::ORDER_ERROR_INTERNAL_ERROR,
            OrderError::ORDER_ERROR_INVALID_SIZE,
            OrderError::ORDER_ERROR_INVALID_PERSISTENCE,
            OrderError::ORDER_ERROR_INVALID_TYPE,
            OrderError::ORDER_ERROR_SELF_TRADING,
            OrderError::ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES,
            OrderError::ORDER_ERROR_INCORRECT_MARKET_TYPE,
            OrderError::ORDER_ERROR_INVALID_TIME_IN_FORCE,
            OrderError::ORDER_ERROR_GFN_ORDER_DURING_AN_AUCTION,
            OrderError::ORDER_ERROR_GFA_ORDER_DURING_CONTINUOUS_TRADING,
            OrderError::ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT,
            OrderError::ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT,
            OrderError::ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT,
            OrderError::ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC,
            OrderError::ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN,
            OrderError::ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN,
            OrderError::ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION,
            OrderError::ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION,
            OrderError::ORDER_ERROR_MUST_BE_LIMIT_ORDER,
            OrderError::ORDER_ERROR_MUST_BE_GTT_OR_GTC,
            OrderError::ORDER_ERROR_WITHOUT_REFERENCE_PRICE,
            OrderError::ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE,
            OrderError::ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO,
            OrderError::ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE,
            OrderError::ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO,
            OrderError::ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE,
            OrderError::ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER,
            OrderError::ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER,
            OrderError::ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER,
            OrderError::ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS,
        ];
    }
    impl ::protobuf::EnumFull for OrderError {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::EnumDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .enum_by_package_relative_name("OrderError")
                        .unwrap()
                })
                .clone()
        }
        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                OrderError::ORDER_ERROR_UNSPECIFIED => 0,
                OrderError::ORDER_ERROR_INVALID_MARKET_ID => 1,
                OrderError::ORDER_ERROR_INVALID_ORDER_ID => 2,
                OrderError::ORDER_ERROR_OUT_OF_SEQUENCE => 3,
                OrderError::ORDER_ERROR_INVALID_REMAINING_SIZE => 4,
                OrderError::ORDER_ERROR_TIME_FAILURE => 5,
                OrderError::ORDER_ERROR_REMOVAL_FAILURE => 6,
                OrderError::ORDER_ERROR_INVALID_EXPIRATION_DATETIME => 7,
                OrderError::ORDER_ERROR_INVALID_ORDER_REFERENCE => 8,
                OrderError::ORDER_ERROR_EDIT_NOT_ALLOWED => 9,
                OrderError::ORDER_ERROR_AMEND_FAILURE => 10,
                OrderError::ORDER_ERROR_NOT_FOUND => 11,
                OrderError::ORDER_ERROR_INVALID_PARTY_ID => 12,
                OrderError::ORDER_ERROR_MARKET_CLOSED => 13,
                OrderError::ORDER_ERROR_MARGIN_CHECK_FAILED => 14,
                OrderError::ORDER_ERROR_MISSING_GENERAL_ACCOUNT => 15,
                OrderError::ORDER_ERROR_INTERNAL_ERROR => 16,
                OrderError::ORDER_ERROR_INVALID_SIZE => 17,
                OrderError::ORDER_ERROR_INVALID_PERSISTENCE => 18,
                OrderError::ORDER_ERROR_INVALID_TYPE => 19,
                OrderError::ORDER_ERROR_SELF_TRADING => 20,
                OrderError::ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES => 21,
                OrderError::ORDER_ERROR_INCORRECT_MARKET_TYPE => 22,
                OrderError::ORDER_ERROR_INVALID_TIME_IN_FORCE => 23,
                OrderError::ORDER_ERROR_GFN_ORDER_DURING_AN_AUCTION => 24,
                OrderError::ORDER_ERROR_GFA_ORDER_DURING_CONTINUOUS_TRADING => 25,
                OrderError::ORDER_ERROR_CANNOT_AMEND_TO_GTT_WITHOUT_EXPIRYAT => 26,
                OrderError::ORDER_ERROR_EXPIRYAT_BEFORE_CREATEDAT => 27,
                OrderError::ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT => 28,
                OrderError::ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC => 29,
                OrderError::ORDER_ERROR_CANNOT_AMEND_TO_GFA_OR_GFN => 30,
                OrderError::ORDER_ERROR_CANNOT_AMEND_FROM_GFA_OR_GFN => 31,
                OrderError::ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUCTION => 32,
                OrderError::ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION => 33,
                OrderError::ORDER_ERROR_MUST_BE_LIMIT_ORDER => 34,
                OrderError::ORDER_ERROR_MUST_BE_GTT_OR_GTC => 35,
                OrderError::ORDER_ERROR_WITHOUT_REFERENCE_PRICE => 36,
                OrderError::ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE => 37,
                OrderError::ORDER_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO => 38,
                OrderError::ORDER_ERROR_SELL_CANNOT_REFERENCE_BEST_BID_PRICE => 39,
                OrderError::ORDER_ERROR_OFFSET_MUST_BE_GREATER_THAN_ZERO => 40,
                OrderError::ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE => 41,
                OrderError::ORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED_ORDER => {
                    42
                }
                OrderError::ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER => 43,
                OrderError::ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER => 44,
                OrderError::ORDER_ERROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS => 45,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }
    impl ::std::default::Default for OrderError {
        fn default() -> Self {
            OrderError::ORDER_ERROR_UNSPECIFIED
        }
    }
    impl OrderError {
        fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<
                OrderError,
            >("OrderError")
        }
    }
    #[postgres(name = "transfer_type")]
    pub enum ChainStatus {
        CHAIN_STATUS_UNSPECIFIED = 0,
        CHAIN_STATUS_DISCONNECTED = 1,
        CHAIN_STATUS_REPLAYING = 2,
        CHAIN_STATUS_CONNECTED = 3,
    }
    impl<'a> postgres_types::FromSql<'a> for ChainStatus {
        fn from_sql(
            _type: &postgres_types::Type,
            buf: &'a [u8],
        ) -> std::result::Result<
            ChainStatus,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            match std::str::from_utf8(buf)? {
                "CHAIN_STATUS_UNSPECIFIED" => {
                    std::result::Result::Ok(ChainStatus::CHAIN_STATUS_UNSPECIFIED)
                }
                "CHAIN_STATUS_DISCONNECTED" => {
                    std::result::Result::Ok(ChainStatus::CHAIN_STATUS_DISCONNECTED)
                }
                "CHAIN_STATUS_REPLAYING" => {
                    std::result::Result::Ok(ChainStatus::CHAIN_STATUS_REPLAYING)
                }
                "CHAIN_STATUS_CONNECTED" => {
                    std::result::Result::Ok(ChainStatus::CHAIN_STATUS_CONNECTED)
                }
                s => {
                    std::result::Result::Err(
                        std::convert::Into::into({
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &["invalid variant `", "`"],
                                    &[::core::fmt::ArgumentV1::new_display(&s)],
                                ),
                            );
                            res
                        }),
                    )
                }
            }
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 4usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "CHAIN_STATUS_UNSPECIFIED" => true,
                                "CHAIN_STATUS_DISCONNECTED" => true,
                                "CHAIN_STATUS_REPLAYING" => true,
                                "CHAIN_STATUS_CONNECTED" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
    }
    impl postgres_types::ToSql for ChainStatus {
        fn to_sql(
            &self,
            _type: &postgres_types::Type,
            buf: &mut postgres_types::private::BytesMut,
        ) -> std::result::Result<
            postgres_types::IsNull,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            let s = match *self {
                ChainStatus::CHAIN_STATUS_UNSPECIFIED => "CHAIN_STATUS_UNSPECIFIED",
                ChainStatus::CHAIN_STATUS_DISCONNECTED => "CHAIN_STATUS_DISCONNECTED",
                ChainStatus::CHAIN_STATUS_REPLAYING => "CHAIN_STATUS_REPLAYING",
                ChainStatus::CHAIN_STATUS_CONNECTED => "CHAIN_STATUS_CONNECTED",
            };
            buf.extend_from_slice(s.as_bytes());
            std::result::Result::Ok(postgres_types::IsNull::No)
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 4usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "CHAIN_STATUS_UNSPECIFIED" => true,
                                "CHAIN_STATUS_DISCONNECTED" => true,
                                "CHAIN_STATUS_REPLAYING" => true,
                                "CHAIN_STATUS_CONNECTED" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
        fn to_sql_checked(
            &self,
            ty: &::postgres_types::Type,
            out: &mut ::postgres_types::private::BytesMut,
        ) -> ::std::result::Result<
            ::postgres_types::IsNull,
            Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
        > {
            ::postgres_types::__to_sql_checked(self, ty, out)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ChainStatus {
        #[inline]
        fn clone(&self) -> ChainStatus {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ChainStatus {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ChainStatus {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ChainStatus {
        #[inline]
        fn eq(&self, other: &ChainStatus) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ChainStatus {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ChainStatus {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ChainStatus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ChainStatus::CHAIN_STATUS_UNSPECIFIED => {
                    ::core::fmt::Formatter::write_str(f, "CHAIN_STATUS_UNSPECIFIED")
                }
                ChainStatus::CHAIN_STATUS_DISCONNECTED => {
                    ::core::fmt::Formatter::write_str(f, "CHAIN_STATUS_DISCONNECTED")
                }
                ChainStatus::CHAIN_STATUS_REPLAYING => {
                    ::core::fmt::Formatter::write_str(f, "CHAIN_STATUS_REPLAYING")
                }
                ChainStatus::CHAIN_STATUS_CONNECTED => {
                    ::core::fmt::Formatter::write_str(f, "CHAIN_STATUS_CONNECTED")
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ChainStatus {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    impl ::protobuf::Enum for ChainStatus {
        const NAME: &'static str = "ChainStatus";
        fn value(&self) -> i32 {
            *self as i32
        }
        fn from_i32(value: i32) -> ::std::option::Option<ChainStatus> {
            match value {
                0 => ::std::option::Option::Some(ChainStatus::CHAIN_STATUS_UNSPECIFIED),
                1 => ::std::option::Option::Some(ChainStatus::CHAIN_STATUS_DISCONNECTED),
                2 => ::std::option::Option::Some(ChainStatus::CHAIN_STATUS_REPLAYING),
                3 => ::std::option::Option::Some(ChainStatus::CHAIN_STATUS_CONNECTED),
                _ => ::std::option::Option::None,
            }
        }
        const VALUES: &'static [ChainStatus] = &[
            ChainStatus::CHAIN_STATUS_UNSPECIFIED,
            ChainStatus::CHAIN_STATUS_DISCONNECTED,
            ChainStatus::CHAIN_STATUS_REPLAYING,
            ChainStatus::CHAIN_STATUS_CONNECTED,
        ];
    }
    impl ::protobuf::EnumFull for ChainStatus {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::EnumDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .enum_by_package_relative_name("ChainStatus")
                        .unwrap()
                })
                .clone()
        }
        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }
    impl ::std::default::Default for ChainStatus {
        fn default() -> Self {
            ChainStatus::CHAIN_STATUS_UNSPECIFIED
        }
    }
    impl ChainStatus {
        fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<
                ChainStatus,
            >("ChainStatus")
        }
    }
    #[postgres(name = "transfer_type")]
    pub enum AccountType {
        ACCOUNT_TYPE_UNSPECIFIED = 0,
        ACCOUNT_TYPE_INSURANCE = 1,
        ACCOUNT_TYPE_SETTLEMENT = 2,
        ACCOUNT_TYPE_MARGIN = 3,
        ACCOUNT_TYPE_GENERAL = 4,
        ACCOUNT_TYPE_FEES_INFRASTRUCTURE = 5,
        ACCOUNT_TYPE_FEES_LIQUIDITY = 6,
        ACCOUNT_TYPE_FEES_MAKER = 7,
        ACCOUNT_TYPE_BOND = 9,
        ACCOUNT_TYPE_EXTERNAL = 10,
        ACCOUNT_TYPE_GLOBAL_INSURANCE = 11,
        ACCOUNT_TYPE_GLOBAL_REWARD = 12,
        ACCOUNT_TYPE_PENDING_TRANSFERS = 13,
        ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES = 14,
        ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES = 15,
        ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES = 16,
        ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS = 17,
    }
    impl<'a> postgres_types::FromSql<'a> for AccountType {
        fn from_sql(
            _type: &postgres_types::Type,
            buf: &'a [u8],
        ) -> std::result::Result<
            AccountType,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            match std::str::from_utf8(buf)? {
                "ACCOUNT_TYPE_UNSPECIFIED" => {
                    std::result::Result::Ok(AccountType::ACCOUNT_TYPE_UNSPECIFIED)
                }
                "ACCOUNT_TYPE_INSURANCE" => {
                    std::result::Result::Ok(AccountType::ACCOUNT_TYPE_INSURANCE)
                }
                "ACCOUNT_TYPE_SETTLEMENT" => {
                    std::result::Result::Ok(AccountType::ACCOUNT_TYPE_SETTLEMENT)
                }
                "ACCOUNT_TYPE_MARGIN" => {
                    std::result::Result::Ok(AccountType::ACCOUNT_TYPE_MARGIN)
                }
                "ACCOUNT_TYPE_GENERAL" => {
                    std::result::Result::Ok(AccountType::ACCOUNT_TYPE_GENERAL)
                }
                "ACCOUNT_TYPE_FEES_INFRASTRUCTURE" => {
                    std::result::Result::Ok(
                        AccountType::ACCOUNT_TYPE_FEES_INFRASTRUCTURE,
                    )
                }
                "ACCOUNT_TYPE_FEES_LIQUIDITY" => {
                    std::result::Result::Ok(AccountType::ACCOUNT_TYPE_FEES_LIQUIDITY)
                }
                "ACCOUNT_TYPE_FEES_MAKER" => {
                    std::result::Result::Ok(AccountType::ACCOUNT_TYPE_FEES_MAKER)
                }
                "ACCOUNT_TYPE_BOND" => {
                    std::result::Result::Ok(AccountType::ACCOUNT_TYPE_BOND)
                }
                "ACCOUNT_TYPE_EXTERNAL" => {
                    std::result::Result::Ok(AccountType::ACCOUNT_TYPE_EXTERNAL)
                }
                "ACCOUNT_TYPE_GLOBAL_INSURANCE" => {
                    std::result::Result::Ok(AccountType::ACCOUNT_TYPE_GLOBAL_INSURANCE)
                }
                "ACCOUNT_TYPE_GLOBAL_REWARD" => {
                    std::result::Result::Ok(AccountType::ACCOUNT_TYPE_GLOBAL_REWARD)
                }
                "ACCOUNT_TYPE_PENDING_TRANSFERS" => {
                    std::result::Result::Ok(AccountType::ACCOUNT_TYPE_PENDING_TRANSFERS)
                }
                "ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES" => {
                    std::result::Result::Ok(
                        AccountType::ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES,
                    )
                }
                "ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES" => {
                    std::result::Result::Ok(
                        AccountType::ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES,
                    )
                }
                "ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES" => {
                    std::result::Result::Ok(
                        AccountType::ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES,
                    )
                }
                "ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS" => {
                    std::result::Result::Ok(
                        AccountType::ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS,
                    )
                }
                s => {
                    std::result::Result::Err(
                        std::convert::Into::into({
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &["invalid variant `", "`"],
                                    &[::core::fmt::ArgumentV1::new_display(&s)],
                                ),
                            );
                            res
                        }),
                    )
                }
            }
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 17usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "ACCOUNT_TYPE_UNSPECIFIED" => true,
                                "ACCOUNT_TYPE_INSURANCE" => true,
                                "ACCOUNT_TYPE_SETTLEMENT" => true,
                                "ACCOUNT_TYPE_MARGIN" => true,
                                "ACCOUNT_TYPE_GENERAL" => true,
                                "ACCOUNT_TYPE_FEES_INFRASTRUCTURE" => true,
                                "ACCOUNT_TYPE_FEES_LIQUIDITY" => true,
                                "ACCOUNT_TYPE_FEES_MAKER" => true,
                                "ACCOUNT_TYPE_BOND" => true,
                                "ACCOUNT_TYPE_EXTERNAL" => true,
                                "ACCOUNT_TYPE_GLOBAL_INSURANCE" => true,
                                "ACCOUNT_TYPE_GLOBAL_REWARD" => true,
                                "ACCOUNT_TYPE_PENDING_TRANSFERS" => true,
                                "ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES" => true,
                                "ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES" => true,
                                "ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES" => true,
                                "ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
    }
    impl postgres_types::ToSql for AccountType {
        fn to_sql(
            &self,
            _type: &postgres_types::Type,
            buf: &mut postgres_types::private::BytesMut,
        ) -> std::result::Result<
            postgres_types::IsNull,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            let s = match *self {
                AccountType::ACCOUNT_TYPE_UNSPECIFIED => "ACCOUNT_TYPE_UNSPECIFIED",
                AccountType::ACCOUNT_TYPE_INSURANCE => "ACCOUNT_TYPE_INSURANCE",
                AccountType::ACCOUNT_TYPE_SETTLEMENT => "ACCOUNT_TYPE_SETTLEMENT",
                AccountType::ACCOUNT_TYPE_MARGIN => "ACCOUNT_TYPE_MARGIN",
                AccountType::ACCOUNT_TYPE_GENERAL => "ACCOUNT_TYPE_GENERAL",
                AccountType::ACCOUNT_TYPE_FEES_INFRASTRUCTURE => {
                    "ACCOUNT_TYPE_FEES_INFRASTRUCTURE"
                }
                AccountType::ACCOUNT_TYPE_FEES_LIQUIDITY => "ACCOUNT_TYPE_FEES_LIQUIDITY",
                AccountType::ACCOUNT_TYPE_FEES_MAKER => "ACCOUNT_TYPE_FEES_MAKER",
                AccountType::ACCOUNT_TYPE_BOND => "ACCOUNT_TYPE_BOND",
                AccountType::ACCOUNT_TYPE_EXTERNAL => "ACCOUNT_TYPE_EXTERNAL",
                AccountType::ACCOUNT_TYPE_GLOBAL_INSURANCE => {
                    "ACCOUNT_TYPE_GLOBAL_INSURANCE"
                }
                AccountType::ACCOUNT_TYPE_GLOBAL_REWARD => "ACCOUNT_TYPE_GLOBAL_REWARD",
                AccountType::ACCOUNT_TYPE_PENDING_TRANSFERS => {
                    "ACCOUNT_TYPE_PENDING_TRANSFERS"
                }
                AccountType::ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES => {
                    "ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES"
                }
                AccountType::ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES => {
                    "ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES"
                }
                AccountType::ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES => {
                    "ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES"
                }
                AccountType::ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS => {
                    "ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS"
                }
            };
            buf.extend_from_slice(s.as_bytes());
            std::result::Result::Ok(postgres_types::IsNull::No)
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 17usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "ACCOUNT_TYPE_UNSPECIFIED" => true,
                                "ACCOUNT_TYPE_INSURANCE" => true,
                                "ACCOUNT_TYPE_SETTLEMENT" => true,
                                "ACCOUNT_TYPE_MARGIN" => true,
                                "ACCOUNT_TYPE_GENERAL" => true,
                                "ACCOUNT_TYPE_FEES_INFRASTRUCTURE" => true,
                                "ACCOUNT_TYPE_FEES_LIQUIDITY" => true,
                                "ACCOUNT_TYPE_FEES_MAKER" => true,
                                "ACCOUNT_TYPE_BOND" => true,
                                "ACCOUNT_TYPE_EXTERNAL" => true,
                                "ACCOUNT_TYPE_GLOBAL_INSURANCE" => true,
                                "ACCOUNT_TYPE_GLOBAL_REWARD" => true,
                                "ACCOUNT_TYPE_PENDING_TRANSFERS" => true,
                                "ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES" => true,
                                "ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES" => true,
                                "ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES" => true,
                                "ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
        fn to_sql_checked(
            &self,
            ty: &::postgres_types::Type,
            out: &mut ::postgres_types::private::BytesMut,
        ) -> ::std::result::Result<
            ::postgres_types::IsNull,
            Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
        > {
            ::postgres_types::__to_sql_checked(self, ty, out)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AccountType {
        #[inline]
        fn clone(&self) -> AccountType {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for AccountType {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AccountType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AccountType {
        #[inline]
        fn eq(&self, other: &AccountType) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for AccountType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for AccountType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AccountType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                AccountType::ACCOUNT_TYPE_UNSPECIFIED => {
                    ::core::fmt::Formatter::write_str(f, "ACCOUNT_TYPE_UNSPECIFIED")
                }
                AccountType::ACCOUNT_TYPE_INSURANCE => {
                    ::core::fmt::Formatter::write_str(f, "ACCOUNT_TYPE_INSURANCE")
                }
                AccountType::ACCOUNT_TYPE_SETTLEMENT => {
                    ::core::fmt::Formatter::write_str(f, "ACCOUNT_TYPE_SETTLEMENT")
                }
                AccountType::ACCOUNT_TYPE_MARGIN => {
                    ::core::fmt::Formatter::write_str(f, "ACCOUNT_TYPE_MARGIN")
                }
                AccountType::ACCOUNT_TYPE_GENERAL => {
                    ::core::fmt::Formatter::write_str(f, "ACCOUNT_TYPE_GENERAL")
                }
                AccountType::ACCOUNT_TYPE_FEES_INFRASTRUCTURE => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ACCOUNT_TYPE_FEES_INFRASTRUCTURE",
                    )
                }
                AccountType::ACCOUNT_TYPE_FEES_LIQUIDITY => {
                    ::core::fmt::Formatter::write_str(f, "ACCOUNT_TYPE_FEES_LIQUIDITY")
                }
                AccountType::ACCOUNT_TYPE_FEES_MAKER => {
                    ::core::fmt::Formatter::write_str(f, "ACCOUNT_TYPE_FEES_MAKER")
                }
                AccountType::ACCOUNT_TYPE_BOND => {
                    ::core::fmt::Formatter::write_str(f, "ACCOUNT_TYPE_BOND")
                }
                AccountType::ACCOUNT_TYPE_EXTERNAL => {
                    ::core::fmt::Formatter::write_str(f, "ACCOUNT_TYPE_EXTERNAL")
                }
                AccountType::ACCOUNT_TYPE_GLOBAL_INSURANCE => {
                    ::core::fmt::Formatter::write_str(f, "ACCOUNT_TYPE_GLOBAL_INSURANCE")
                }
                AccountType::ACCOUNT_TYPE_GLOBAL_REWARD => {
                    ::core::fmt::Formatter::write_str(f, "ACCOUNT_TYPE_GLOBAL_REWARD")
                }
                AccountType::ACCOUNT_TYPE_PENDING_TRANSFERS => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ACCOUNT_TYPE_PENDING_TRANSFERS",
                    )
                }
                AccountType::ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES",
                    )
                }
                AccountType::ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES",
                    )
                }
                AccountType::ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES",
                    )
                }
                AccountType::ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS",
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for AccountType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    impl ::protobuf::Enum for AccountType {
        const NAME: &'static str = "AccountType";
        fn value(&self) -> i32 {
            *self as i32
        }
        fn from_i32(value: i32) -> ::std::option::Option<AccountType> {
            match value {
                0 => ::std::option::Option::Some(AccountType::ACCOUNT_TYPE_UNSPECIFIED),
                1 => ::std::option::Option::Some(AccountType::ACCOUNT_TYPE_INSURANCE),
                2 => ::std::option::Option::Some(AccountType::ACCOUNT_TYPE_SETTLEMENT),
                3 => ::std::option::Option::Some(AccountType::ACCOUNT_TYPE_MARGIN),
                4 => ::std::option::Option::Some(AccountType::ACCOUNT_TYPE_GENERAL),
                5 => {
                    ::std::option::Option::Some(
                        AccountType::ACCOUNT_TYPE_FEES_INFRASTRUCTURE,
                    )
                }
                6 => {
                    ::std::option::Option::Some(AccountType::ACCOUNT_TYPE_FEES_LIQUIDITY)
                }
                7 => ::std::option::Option::Some(AccountType::ACCOUNT_TYPE_FEES_MAKER),
                9 => ::std::option::Option::Some(AccountType::ACCOUNT_TYPE_BOND),
                10 => ::std::option::Option::Some(AccountType::ACCOUNT_TYPE_EXTERNAL),
                11 => {
                    ::std::option::Option::Some(
                        AccountType::ACCOUNT_TYPE_GLOBAL_INSURANCE,
                    )
                }
                12 => {
                    ::std::option::Option::Some(AccountType::ACCOUNT_TYPE_GLOBAL_REWARD)
                }
                13 => {
                    ::std::option::Option::Some(
                        AccountType::ACCOUNT_TYPE_PENDING_TRANSFERS,
                    )
                }
                14 => {
                    ::std::option::Option::Some(
                        AccountType::ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES,
                    )
                }
                15 => {
                    ::std::option::Option::Some(
                        AccountType::ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES,
                    )
                }
                16 => {
                    ::std::option::Option::Some(
                        AccountType::ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES,
                    )
                }
                17 => {
                    ::std::option::Option::Some(
                        AccountType::ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS,
                    )
                }
                _ => ::std::option::Option::None,
            }
        }
        const VALUES: &'static [AccountType] = &[
            AccountType::ACCOUNT_TYPE_UNSPECIFIED,
            AccountType::ACCOUNT_TYPE_INSURANCE,
            AccountType::ACCOUNT_TYPE_SETTLEMENT,
            AccountType::ACCOUNT_TYPE_MARGIN,
            AccountType::ACCOUNT_TYPE_GENERAL,
            AccountType::ACCOUNT_TYPE_FEES_INFRASTRUCTURE,
            AccountType::ACCOUNT_TYPE_FEES_LIQUIDITY,
            AccountType::ACCOUNT_TYPE_FEES_MAKER,
            AccountType::ACCOUNT_TYPE_BOND,
            AccountType::ACCOUNT_TYPE_EXTERNAL,
            AccountType::ACCOUNT_TYPE_GLOBAL_INSURANCE,
            AccountType::ACCOUNT_TYPE_GLOBAL_REWARD,
            AccountType::ACCOUNT_TYPE_PENDING_TRANSFERS,
            AccountType::ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES,
            AccountType::ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES,
            AccountType::ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES,
            AccountType::ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS,
        ];
    }
    impl ::protobuf::EnumFull for AccountType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::EnumDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .enum_by_package_relative_name("AccountType")
                        .unwrap()
                })
                .clone()
        }
        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                AccountType::ACCOUNT_TYPE_UNSPECIFIED => 0,
                AccountType::ACCOUNT_TYPE_INSURANCE => 1,
                AccountType::ACCOUNT_TYPE_SETTLEMENT => 2,
                AccountType::ACCOUNT_TYPE_MARGIN => 3,
                AccountType::ACCOUNT_TYPE_GENERAL => 4,
                AccountType::ACCOUNT_TYPE_FEES_INFRASTRUCTURE => 5,
                AccountType::ACCOUNT_TYPE_FEES_LIQUIDITY => 6,
                AccountType::ACCOUNT_TYPE_FEES_MAKER => 7,
                AccountType::ACCOUNT_TYPE_BOND => 8,
                AccountType::ACCOUNT_TYPE_EXTERNAL => 9,
                AccountType::ACCOUNT_TYPE_GLOBAL_INSURANCE => 10,
                AccountType::ACCOUNT_TYPE_GLOBAL_REWARD => 11,
                AccountType::ACCOUNT_TYPE_PENDING_TRANSFERS => 12,
                AccountType::ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES => 13,
                AccountType::ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES => 14,
                AccountType::ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES => 15,
                AccountType::ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS => 16,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }
    impl ::std::default::Default for AccountType {
        fn default() -> Self {
            AccountType::ACCOUNT_TYPE_UNSPECIFIED
        }
    }
    impl AccountType {
        fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<
                AccountType,
            >("AccountType")
        }
    }
    #[postgres(name = "transfer_type")]
    pub enum TransferType {
        TRANSFER_TYPE_UNSPECIFIED = 0,
        TRANSFER_TYPE_LOSS = 1,
        TRANSFER_TYPE_WIN = 2,
        TRANSFER_TYPE_CLOSE = 3,
        TRANSFER_TYPE_MTM_LOSS = 4,
        TRANSFER_TYPE_MTM_WIN = 5,
        TRANSFER_TYPE_MARGIN_LOW = 6,
        TRANSFER_TYPE_MARGIN_HIGH = 7,
        TRANSFER_TYPE_MARGIN_CONFISCATED = 8,
        TRANSFER_TYPE_MAKER_FEE_PAY = 9,
        TRANSFER_TYPE_MAKER_FEE_RECEIVE = 10,
        TRANSFER_TYPE_INFRASTRUCTURE_FEE_PAY = 11,
        TRANSFER_TYPE_INFRASTRUCTURE_FEE_DISTRIBUTE = 12,
        TRANSFER_TYPE_LIQUIDITY_FEE_PAY = 13,
        TRANSFER_TYPE_LIQUIDITY_FEE_DISTRIBUTE = 14,
        TRANSFER_TYPE_BOND_LOW = 15,
        TRANSFER_TYPE_BOND_HIGH = 16,
        TRANSFER_TYPE_WITHDRAW_LOCK = 17,
        TRANSFER_TYPE_WITHDRAW = 18,
        TRANSFER_TYPE_DEPOSIT = 19,
        TRANSFER_TYPE_BOND_SLASHING = 20,
        TRANSFER_TYPE_STAKE_REWARD = 21,
        TRANSFER_TYPE_TRANSFER_FUNDS_SEND = 22,
        TRANSFER_TYPE_TRANSFER_FUNDS_DISTRIBUTE = 23,
        TRANSFER_TYPE_CLEAR_ACCOUNT = 24,
        TRANSFER_TYPE_CHECKPOINT_BALANCE_RESTORE = 25,
    }
    impl<'a> postgres_types::FromSql<'a> for TransferType {
        fn from_sql(
            _type: &postgres_types::Type,
            buf: &'a [u8],
        ) -> std::result::Result<
            TransferType,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            match std::str::from_utf8(buf)? {
                "TRANSFER_TYPE_UNSPECIFIED" => {
                    std::result::Result::Ok(TransferType::TRANSFER_TYPE_UNSPECIFIED)
                }
                "TRANSFER_TYPE_LOSS" => {
                    std::result::Result::Ok(TransferType::TRANSFER_TYPE_LOSS)
                }
                "TRANSFER_TYPE_WIN" => {
                    std::result::Result::Ok(TransferType::TRANSFER_TYPE_WIN)
                }
                "TRANSFER_TYPE_CLOSE" => {
                    std::result::Result::Ok(TransferType::TRANSFER_TYPE_CLOSE)
                }
                "TRANSFER_TYPE_MTM_LOSS" => {
                    std::result::Result::Ok(TransferType::TRANSFER_TYPE_MTM_LOSS)
                }
                "TRANSFER_TYPE_MTM_WIN" => {
                    std::result::Result::Ok(TransferType::TRANSFER_TYPE_MTM_WIN)
                }
                "TRANSFER_TYPE_MARGIN_LOW" => {
                    std::result::Result::Ok(TransferType::TRANSFER_TYPE_MARGIN_LOW)
                }
                "TRANSFER_TYPE_MARGIN_HIGH" => {
                    std::result::Result::Ok(TransferType::TRANSFER_TYPE_MARGIN_HIGH)
                }
                "TRANSFER_TYPE_MARGIN_CONFISCATED" => {
                    std::result::Result::Ok(
                        TransferType::TRANSFER_TYPE_MARGIN_CONFISCATED,
                    )
                }
                "TRANSFER_TYPE_MAKER_FEE_PAY" => {
                    std::result::Result::Ok(TransferType::TRANSFER_TYPE_MAKER_FEE_PAY)
                }
                "TRANSFER_TYPE_MAKER_FEE_RECEIVE" => {
                    std::result::Result::Ok(
                        TransferType::TRANSFER_TYPE_MAKER_FEE_RECEIVE,
                    )
                }
                "TRANSFER_TYPE_INFRASTRUCTURE_FEE_PAY" => {
                    std::result::Result::Ok(
                        TransferType::TRANSFER_TYPE_INFRASTRUCTURE_FEE_PAY,
                    )
                }
                "TRANSFER_TYPE_INFRASTRUCTURE_FEE_DISTRIBUTE" => {
                    std::result::Result::Ok(
                        TransferType::TRANSFER_TYPE_INFRASTRUCTURE_FEE_DISTRIBUTE,
                    )
                }
                "TRANSFER_TYPE_LIQUIDITY_FEE_PAY" => {
                    std::result::Result::Ok(
                        TransferType::TRANSFER_TYPE_LIQUIDITY_FEE_PAY,
                    )
                }
                "TRANSFER_TYPE_LIQUIDITY_FEE_DISTRIBUTE" => {
                    std::result::Result::Ok(
                        TransferType::TRANSFER_TYPE_LIQUIDITY_FEE_DISTRIBUTE,
                    )
                }
                "TRANSFER_TYPE_BOND_LOW" => {
                    std::result::Result::Ok(TransferType::TRANSFER_TYPE_BOND_LOW)
                }
                "TRANSFER_TYPE_BOND_HIGH" => {
                    std::result::Result::Ok(TransferType::TRANSFER_TYPE_BOND_HIGH)
                }
                "TRANSFER_TYPE_WITHDRAW_LOCK" => {
                    std::result::Result::Ok(TransferType::TRANSFER_TYPE_WITHDRAW_LOCK)
                }
                "TRANSFER_TYPE_WITHDRAW" => {
                    std::result::Result::Ok(TransferType::TRANSFER_TYPE_WITHDRAW)
                }
                "TRANSFER_TYPE_DEPOSIT" => {
                    std::result::Result::Ok(TransferType::TRANSFER_TYPE_DEPOSIT)
                }
                "TRANSFER_TYPE_BOND_SLASHING" => {
                    std::result::Result::Ok(TransferType::TRANSFER_TYPE_BOND_SLASHING)
                }
                "TRANSFER_TYPE_STAKE_REWARD" => {
                    std::result::Result::Ok(TransferType::TRANSFER_TYPE_STAKE_REWARD)
                }
                "TRANSFER_TYPE_TRANSFER_FUNDS_SEND" => {
                    std::result::Result::Ok(
                        TransferType::TRANSFER_TYPE_TRANSFER_FUNDS_SEND,
                    )
                }
                "TRANSFER_TYPE_TRANSFER_FUNDS_DISTRIBUTE" => {
                    std::result::Result::Ok(
                        TransferType::TRANSFER_TYPE_TRANSFER_FUNDS_DISTRIBUTE,
                    )
                }
                "TRANSFER_TYPE_CLEAR_ACCOUNT" => {
                    std::result::Result::Ok(TransferType::TRANSFER_TYPE_CLEAR_ACCOUNT)
                }
                "TRANSFER_TYPE_CHECKPOINT_BALANCE_RESTORE" => {
                    std::result::Result::Ok(
                        TransferType::TRANSFER_TYPE_CHECKPOINT_BALANCE_RESTORE,
                    )
                }
                s => {
                    std::result::Result::Err(
                        std::convert::Into::into({
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &["invalid variant `", "`"],
                                    &[::core::fmt::ArgumentV1::new_display(&s)],
                                ),
                            );
                            res
                        }),
                    )
                }
            }
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 26usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "TRANSFER_TYPE_UNSPECIFIED" => true,
                                "TRANSFER_TYPE_LOSS" => true,
                                "TRANSFER_TYPE_WIN" => true,
                                "TRANSFER_TYPE_CLOSE" => true,
                                "TRANSFER_TYPE_MTM_LOSS" => true,
                                "TRANSFER_TYPE_MTM_WIN" => true,
                                "TRANSFER_TYPE_MARGIN_LOW" => true,
                                "TRANSFER_TYPE_MARGIN_HIGH" => true,
                                "TRANSFER_TYPE_MARGIN_CONFISCATED" => true,
                                "TRANSFER_TYPE_MAKER_FEE_PAY" => true,
                                "TRANSFER_TYPE_MAKER_FEE_RECEIVE" => true,
                                "TRANSFER_TYPE_INFRASTRUCTURE_FEE_PAY" => true,
                                "TRANSFER_TYPE_INFRASTRUCTURE_FEE_DISTRIBUTE" => true,
                                "TRANSFER_TYPE_LIQUIDITY_FEE_PAY" => true,
                                "TRANSFER_TYPE_LIQUIDITY_FEE_DISTRIBUTE" => true,
                                "TRANSFER_TYPE_BOND_LOW" => true,
                                "TRANSFER_TYPE_BOND_HIGH" => true,
                                "TRANSFER_TYPE_WITHDRAW_LOCK" => true,
                                "TRANSFER_TYPE_WITHDRAW" => true,
                                "TRANSFER_TYPE_DEPOSIT" => true,
                                "TRANSFER_TYPE_BOND_SLASHING" => true,
                                "TRANSFER_TYPE_STAKE_REWARD" => true,
                                "TRANSFER_TYPE_TRANSFER_FUNDS_SEND" => true,
                                "TRANSFER_TYPE_TRANSFER_FUNDS_DISTRIBUTE" => true,
                                "TRANSFER_TYPE_CLEAR_ACCOUNT" => true,
                                "TRANSFER_TYPE_CHECKPOINT_BALANCE_RESTORE" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
    }
    impl postgres_types::ToSql for TransferType {
        fn to_sql(
            &self,
            _type: &postgres_types::Type,
            buf: &mut postgres_types::private::BytesMut,
        ) -> std::result::Result<
            postgres_types::IsNull,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            let s = match *self {
                TransferType::TRANSFER_TYPE_UNSPECIFIED => "TRANSFER_TYPE_UNSPECIFIED",
                TransferType::TRANSFER_TYPE_LOSS => "TRANSFER_TYPE_LOSS",
                TransferType::TRANSFER_TYPE_WIN => "TRANSFER_TYPE_WIN",
                TransferType::TRANSFER_TYPE_CLOSE => "TRANSFER_TYPE_CLOSE",
                TransferType::TRANSFER_TYPE_MTM_LOSS => "TRANSFER_TYPE_MTM_LOSS",
                TransferType::TRANSFER_TYPE_MTM_WIN => "TRANSFER_TYPE_MTM_WIN",
                TransferType::TRANSFER_TYPE_MARGIN_LOW => "TRANSFER_TYPE_MARGIN_LOW",
                TransferType::TRANSFER_TYPE_MARGIN_HIGH => "TRANSFER_TYPE_MARGIN_HIGH",
                TransferType::TRANSFER_TYPE_MARGIN_CONFISCATED => {
                    "TRANSFER_TYPE_MARGIN_CONFISCATED"
                }
                TransferType::TRANSFER_TYPE_MAKER_FEE_PAY => {
                    "TRANSFER_TYPE_MAKER_FEE_PAY"
                }
                TransferType::TRANSFER_TYPE_MAKER_FEE_RECEIVE => {
                    "TRANSFER_TYPE_MAKER_FEE_RECEIVE"
                }
                TransferType::TRANSFER_TYPE_INFRASTRUCTURE_FEE_PAY => {
                    "TRANSFER_TYPE_INFRASTRUCTURE_FEE_PAY"
                }
                TransferType::TRANSFER_TYPE_INFRASTRUCTURE_FEE_DISTRIBUTE => {
                    "TRANSFER_TYPE_INFRASTRUCTURE_FEE_DISTRIBUTE"
                }
                TransferType::TRANSFER_TYPE_LIQUIDITY_FEE_PAY => {
                    "TRANSFER_TYPE_LIQUIDITY_FEE_PAY"
                }
                TransferType::TRANSFER_TYPE_LIQUIDITY_FEE_DISTRIBUTE => {
                    "TRANSFER_TYPE_LIQUIDITY_FEE_DISTRIBUTE"
                }
                TransferType::TRANSFER_TYPE_BOND_LOW => "TRANSFER_TYPE_BOND_LOW",
                TransferType::TRANSFER_TYPE_BOND_HIGH => "TRANSFER_TYPE_BOND_HIGH",
                TransferType::TRANSFER_TYPE_WITHDRAW_LOCK => {
                    "TRANSFER_TYPE_WITHDRAW_LOCK"
                }
                TransferType::TRANSFER_TYPE_WITHDRAW => "TRANSFER_TYPE_WITHDRAW",
                TransferType::TRANSFER_TYPE_DEPOSIT => "TRANSFER_TYPE_DEPOSIT",
                TransferType::TRANSFER_TYPE_BOND_SLASHING => {
                    "TRANSFER_TYPE_BOND_SLASHING"
                }
                TransferType::TRANSFER_TYPE_STAKE_REWARD => "TRANSFER_TYPE_STAKE_REWARD",
                TransferType::TRANSFER_TYPE_TRANSFER_FUNDS_SEND => {
                    "TRANSFER_TYPE_TRANSFER_FUNDS_SEND"
                }
                TransferType::TRANSFER_TYPE_TRANSFER_FUNDS_DISTRIBUTE => {
                    "TRANSFER_TYPE_TRANSFER_FUNDS_DISTRIBUTE"
                }
                TransferType::TRANSFER_TYPE_CLEAR_ACCOUNT => {
                    "TRANSFER_TYPE_CLEAR_ACCOUNT"
                }
                TransferType::TRANSFER_TYPE_CHECKPOINT_BALANCE_RESTORE => {
                    "TRANSFER_TYPE_CHECKPOINT_BALANCE_RESTORE"
                }
            };
            buf.extend_from_slice(s.as_bytes());
            std::result::Result::Ok(postgres_types::IsNull::No)
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 26usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "TRANSFER_TYPE_UNSPECIFIED" => true,
                                "TRANSFER_TYPE_LOSS" => true,
                                "TRANSFER_TYPE_WIN" => true,
                                "TRANSFER_TYPE_CLOSE" => true,
                                "TRANSFER_TYPE_MTM_LOSS" => true,
                                "TRANSFER_TYPE_MTM_WIN" => true,
                                "TRANSFER_TYPE_MARGIN_LOW" => true,
                                "TRANSFER_TYPE_MARGIN_HIGH" => true,
                                "TRANSFER_TYPE_MARGIN_CONFISCATED" => true,
                                "TRANSFER_TYPE_MAKER_FEE_PAY" => true,
                                "TRANSFER_TYPE_MAKER_FEE_RECEIVE" => true,
                                "TRANSFER_TYPE_INFRASTRUCTURE_FEE_PAY" => true,
                                "TRANSFER_TYPE_INFRASTRUCTURE_FEE_DISTRIBUTE" => true,
                                "TRANSFER_TYPE_LIQUIDITY_FEE_PAY" => true,
                                "TRANSFER_TYPE_LIQUIDITY_FEE_DISTRIBUTE" => true,
                                "TRANSFER_TYPE_BOND_LOW" => true,
                                "TRANSFER_TYPE_BOND_HIGH" => true,
                                "TRANSFER_TYPE_WITHDRAW_LOCK" => true,
                                "TRANSFER_TYPE_WITHDRAW" => true,
                                "TRANSFER_TYPE_DEPOSIT" => true,
                                "TRANSFER_TYPE_BOND_SLASHING" => true,
                                "TRANSFER_TYPE_STAKE_REWARD" => true,
                                "TRANSFER_TYPE_TRANSFER_FUNDS_SEND" => true,
                                "TRANSFER_TYPE_TRANSFER_FUNDS_DISTRIBUTE" => true,
                                "TRANSFER_TYPE_CLEAR_ACCOUNT" => true,
                                "TRANSFER_TYPE_CHECKPOINT_BALANCE_RESTORE" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
        fn to_sql_checked(
            &self,
            ty: &::postgres_types::Type,
            out: &mut ::postgres_types::private::BytesMut,
        ) -> ::std::result::Result<
            ::postgres_types::IsNull,
            Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
        > {
            ::postgres_types::__to_sql_checked(self, ty, out)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TransferType {
        #[inline]
        fn clone(&self) -> TransferType {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TransferType {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TransferType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TransferType {
        #[inline]
        fn eq(&self, other: &TransferType) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for TransferType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for TransferType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TransferType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                TransferType::TRANSFER_TYPE_UNSPECIFIED => {
                    ::core::fmt::Formatter::write_str(f, "TRANSFER_TYPE_UNSPECIFIED")
                }
                TransferType::TRANSFER_TYPE_LOSS => {
                    ::core::fmt::Formatter::write_str(f, "TRANSFER_TYPE_LOSS")
                }
                TransferType::TRANSFER_TYPE_WIN => {
                    ::core::fmt::Formatter::write_str(f, "TRANSFER_TYPE_WIN")
                }
                TransferType::TRANSFER_TYPE_CLOSE => {
                    ::core::fmt::Formatter::write_str(f, "TRANSFER_TYPE_CLOSE")
                }
                TransferType::TRANSFER_TYPE_MTM_LOSS => {
                    ::core::fmt::Formatter::write_str(f, "TRANSFER_TYPE_MTM_LOSS")
                }
                TransferType::TRANSFER_TYPE_MTM_WIN => {
                    ::core::fmt::Formatter::write_str(f, "TRANSFER_TYPE_MTM_WIN")
                }
                TransferType::TRANSFER_TYPE_MARGIN_LOW => {
                    ::core::fmt::Formatter::write_str(f, "TRANSFER_TYPE_MARGIN_LOW")
                }
                TransferType::TRANSFER_TYPE_MARGIN_HIGH => {
                    ::core::fmt::Formatter::write_str(f, "TRANSFER_TYPE_MARGIN_HIGH")
                }
                TransferType::TRANSFER_TYPE_MARGIN_CONFISCATED => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "TRANSFER_TYPE_MARGIN_CONFISCATED",
                    )
                }
                TransferType::TRANSFER_TYPE_MAKER_FEE_PAY => {
                    ::core::fmt::Formatter::write_str(f, "TRANSFER_TYPE_MAKER_FEE_PAY")
                }
                TransferType::TRANSFER_TYPE_MAKER_FEE_RECEIVE => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "TRANSFER_TYPE_MAKER_FEE_RECEIVE",
                    )
                }
                TransferType::TRANSFER_TYPE_INFRASTRUCTURE_FEE_PAY => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "TRANSFER_TYPE_INFRASTRUCTURE_FEE_PAY",
                    )
                }
                TransferType::TRANSFER_TYPE_INFRASTRUCTURE_FEE_DISTRIBUTE => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "TRANSFER_TYPE_INFRASTRUCTURE_FEE_DISTRIBUTE",
                    )
                }
                TransferType::TRANSFER_TYPE_LIQUIDITY_FEE_PAY => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "TRANSFER_TYPE_LIQUIDITY_FEE_PAY",
                    )
                }
                TransferType::TRANSFER_TYPE_LIQUIDITY_FEE_DISTRIBUTE => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "TRANSFER_TYPE_LIQUIDITY_FEE_DISTRIBUTE",
                    )
                }
                TransferType::TRANSFER_TYPE_BOND_LOW => {
                    ::core::fmt::Formatter::write_str(f, "TRANSFER_TYPE_BOND_LOW")
                }
                TransferType::TRANSFER_TYPE_BOND_HIGH => {
                    ::core::fmt::Formatter::write_str(f, "TRANSFER_TYPE_BOND_HIGH")
                }
                TransferType::TRANSFER_TYPE_WITHDRAW_LOCK => {
                    ::core::fmt::Formatter::write_str(f, "TRANSFER_TYPE_WITHDRAW_LOCK")
                }
                TransferType::TRANSFER_TYPE_WITHDRAW => {
                    ::core::fmt::Formatter::write_str(f, "TRANSFER_TYPE_WITHDRAW")
                }
                TransferType::TRANSFER_TYPE_DEPOSIT => {
                    ::core::fmt::Formatter::write_str(f, "TRANSFER_TYPE_DEPOSIT")
                }
                TransferType::TRANSFER_TYPE_BOND_SLASHING => {
                    ::core::fmt::Formatter::write_str(f, "TRANSFER_TYPE_BOND_SLASHING")
                }
                TransferType::TRANSFER_TYPE_STAKE_REWARD => {
                    ::core::fmt::Formatter::write_str(f, "TRANSFER_TYPE_STAKE_REWARD")
                }
                TransferType::TRANSFER_TYPE_TRANSFER_FUNDS_SEND => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "TRANSFER_TYPE_TRANSFER_FUNDS_SEND",
                    )
                }
                TransferType::TRANSFER_TYPE_TRANSFER_FUNDS_DISTRIBUTE => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "TRANSFER_TYPE_TRANSFER_FUNDS_DISTRIBUTE",
                    )
                }
                TransferType::TRANSFER_TYPE_CLEAR_ACCOUNT => {
                    ::core::fmt::Formatter::write_str(f, "TRANSFER_TYPE_CLEAR_ACCOUNT")
                }
                TransferType::TRANSFER_TYPE_CHECKPOINT_BALANCE_RESTORE => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "TRANSFER_TYPE_CHECKPOINT_BALANCE_RESTORE",
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TransferType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    impl ::protobuf::Enum for TransferType {
        const NAME: &'static str = "TransferType";
        fn value(&self) -> i32 {
            *self as i32
        }
        fn from_i32(value: i32) -> ::std::option::Option<TransferType> {
            match value {
                0 => ::std::option::Option::Some(TransferType::TRANSFER_TYPE_UNSPECIFIED),
                1 => ::std::option::Option::Some(TransferType::TRANSFER_TYPE_LOSS),
                2 => ::std::option::Option::Some(TransferType::TRANSFER_TYPE_WIN),
                3 => ::std::option::Option::Some(TransferType::TRANSFER_TYPE_CLOSE),
                4 => ::std::option::Option::Some(TransferType::TRANSFER_TYPE_MTM_LOSS),
                5 => ::std::option::Option::Some(TransferType::TRANSFER_TYPE_MTM_WIN),
                6 => ::std::option::Option::Some(TransferType::TRANSFER_TYPE_MARGIN_LOW),
                7 => ::std::option::Option::Some(TransferType::TRANSFER_TYPE_MARGIN_HIGH),
                8 => {
                    ::std::option::Option::Some(
                        TransferType::TRANSFER_TYPE_MARGIN_CONFISCATED,
                    )
                }
                9 => {
                    ::std::option::Option::Some(
                        TransferType::TRANSFER_TYPE_MAKER_FEE_PAY,
                    )
                }
                10 => {
                    ::std::option::Option::Some(
                        TransferType::TRANSFER_TYPE_MAKER_FEE_RECEIVE,
                    )
                }
                11 => {
                    ::std::option::Option::Some(
                        TransferType::TRANSFER_TYPE_INFRASTRUCTURE_FEE_PAY,
                    )
                }
                12 => {
                    ::std::option::Option::Some(
                        TransferType::TRANSFER_TYPE_INFRASTRUCTURE_FEE_DISTRIBUTE,
                    )
                }
                13 => {
                    ::std::option::Option::Some(
                        TransferType::TRANSFER_TYPE_LIQUIDITY_FEE_PAY,
                    )
                }
                14 => {
                    ::std::option::Option::Some(
                        TransferType::TRANSFER_TYPE_LIQUIDITY_FEE_DISTRIBUTE,
                    )
                }
                15 => ::std::option::Option::Some(TransferType::TRANSFER_TYPE_BOND_LOW),
                16 => ::std::option::Option::Some(TransferType::TRANSFER_TYPE_BOND_HIGH),
                17 => {
                    ::std::option::Option::Some(
                        TransferType::TRANSFER_TYPE_WITHDRAW_LOCK,
                    )
                }
                18 => ::std::option::Option::Some(TransferType::TRANSFER_TYPE_WITHDRAW),
                19 => ::std::option::Option::Some(TransferType::TRANSFER_TYPE_DEPOSIT),
                20 => {
                    ::std::option::Option::Some(
                        TransferType::TRANSFER_TYPE_BOND_SLASHING,
                    )
                }
                21 => {
                    ::std::option::Option::Some(TransferType::TRANSFER_TYPE_STAKE_REWARD)
                }
                22 => {
                    ::std::option::Option::Some(
                        TransferType::TRANSFER_TYPE_TRANSFER_FUNDS_SEND,
                    )
                }
                23 => {
                    ::std::option::Option::Some(
                        TransferType::TRANSFER_TYPE_TRANSFER_FUNDS_DISTRIBUTE,
                    )
                }
                24 => {
                    ::std::option::Option::Some(
                        TransferType::TRANSFER_TYPE_CLEAR_ACCOUNT,
                    )
                }
                25 => {
                    ::std::option::Option::Some(
                        TransferType::TRANSFER_TYPE_CHECKPOINT_BALANCE_RESTORE,
                    )
                }
                _ => ::std::option::Option::None,
            }
        }
        const VALUES: &'static [TransferType] = &[
            TransferType::TRANSFER_TYPE_UNSPECIFIED,
            TransferType::TRANSFER_TYPE_LOSS,
            TransferType::TRANSFER_TYPE_WIN,
            TransferType::TRANSFER_TYPE_CLOSE,
            TransferType::TRANSFER_TYPE_MTM_LOSS,
            TransferType::TRANSFER_TYPE_MTM_WIN,
            TransferType::TRANSFER_TYPE_MARGIN_LOW,
            TransferType::TRANSFER_TYPE_MARGIN_HIGH,
            TransferType::TRANSFER_TYPE_MARGIN_CONFISCATED,
            TransferType::TRANSFER_TYPE_MAKER_FEE_PAY,
            TransferType::TRANSFER_TYPE_MAKER_FEE_RECEIVE,
            TransferType::TRANSFER_TYPE_INFRASTRUCTURE_FEE_PAY,
            TransferType::TRANSFER_TYPE_INFRASTRUCTURE_FEE_DISTRIBUTE,
            TransferType::TRANSFER_TYPE_LIQUIDITY_FEE_PAY,
            TransferType::TRANSFER_TYPE_LIQUIDITY_FEE_DISTRIBUTE,
            TransferType::TRANSFER_TYPE_BOND_LOW,
            TransferType::TRANSFER_TYPE_BOND_HIGH,
            TransferType::TRANSFER_TYPE_WITHDRAW_LOCK,
            TransferType::TRANSFER_TYPE_WITHDRAW,
            TransferType::TRANSFER_TYPE_DEPOSIT,
            TransferType::TRANSFER_TYPE_BOND_SLASHING,
            TransferType::TRANSFER_TYPE_STAKE_REWARD,
            TransferType::TRANSFER_TYPE_TRANSFER_FUNDS_SEND,
            TransferType::TRANSFER_TYPE_TRANSFER_FUNDS_DISTRIBUTE,
            TransferType::TRANSFER_TYPE_CLEAR_ACCOUNT,
            TransferType::TRANSFER_TYPE_CHECKPOINT_BALANCE_RESTORE,
        ];
    }
    impl ::protobuf::EnumFull for TransferType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::EnumDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .enum_by_package_relative_name("TransferType")
                        .unwrap()
                })
                .clone()
        }
        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }
    impl ::std::default::Default for TransferType {
        fn default() -> Self {
            TransferType::TRANSFER_TYPE_UNSPECIFIED
        }
    }
    impl TransferType {
        fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<
                TransferType,
            >("TransferType")
        }
    }
    #[postgres(name = "transfer_type")]
    pub enum DispatchMetric {
        DISPATCH_METRIC_UNSPECIFIED = 0,
        DISPATCH_METRIC_MAKER_FEES_PAID = 1,
        DISPATCH_METRIC_MAKER_FEES_RECEIVED = 2,
        DISPATCH_METRIC_LP_FEES_RECEIVED = 3,
        DISPATCH_METRIC_MARKET_VALUE = 4,
    }
    impl<'a> postgres_types::FromSql<'a> for DispatchMetric {
        fn from_sql(
            _type: &postgres_types::Type,
            buf: &'a [u8],
        ) -> std::result::Result<
            DispatchMetric,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            match std::str::from_utf8(buf)? {
                "DISPATCH_METRIC_UNSPECIFIED" => {
                    std::result::Result::Ok(DispatchMetric::DISPATCH_METRIC_UNSPECIFIED)
                }
                "DISPATCH_METRIC_MAKER_FEES_PAID" => {
                    std::result::Result::Ok(
                        DispatchMetric::DISPATCH_METRIC_MAKER_FEES_PAID,
                    )
                }
                "DISPATCH_METRIC_MAKER_FEES_RECEIVED" => {
                    std::result::Result::Ok(
                        DispatchMetric::DISPATCH_METRIC_MAKER_FEES_RECEIVED,
                    )
                }
                "DISPATCH_METRIC_LP_FEES_RECEIVED" => {
                    std::result::Result::Ok(
                        DispatchMetric::DISPATCH_METRIC_LP_FEES_RECEIVED,
                    )
                }
                "DISPATCH_METRIC_MARKET_VALUE" => {
                    std::result::Result::Ok(DispatchMetric::DISPATCH_METRIC_MARKET_VALUE)
                }
                s => {
                    std::result::Result::Err(
                        std::convert::Into::into({
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &["invalid variant `", "`"],
                                    &[::core::fmt::ArgumentV1::new_display(&s)],
                                ),
                            );
                            res
                        }),
                    )
                }
            }
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 5usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "DISPATCH_METRIC_UNSPECIFIED" => true,
                                "DISPATCH_METRIC_MAKER_FEES_PAID" => true,
                                "DISPATCH_METRIC_MAKER_FEES_RECEIVED" => true,
                                "DISPATCH_METRIC_LP_FEES_RECEIVED" => true,
                                "DISPATCH_METRIC_MARKET_VALUE" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
    }
    impl postgres_types::ToSql for DispatchMetric {
        fn to_sql(
            &self,
            _type: &postgres_types::Type,
            buf: &mut postgres_types::private::BytesMut,
        ) -> std::result::Result<
            postgres_types::IsNull,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            let s = match *self {
                DispatchMetric::DISPATCH_METRIC_UNSPECIFIED => {
                    "DISPATCH_METRIC_UNSPECIFIED"
                }
                DispatchMetric::DISPATCH_METRIC_MAKER_FEES_PAID => {
                    "DISPATCH_METRIC_MAKER_FEES_PAID"
                }
                DispatchMetric::DISPATCH_METRIC_MAKER_FEES_RECEIVED => {
                    "DISPATCH_METRIC_MAKER_FEES_RECEIVED"
                }
                DispatchMetric::DISPATCH_METRIC_LP_FEES_RECEIVED => {
                    "DISPATCH_METRIC_LP_FEES_RECEIVED"
                }
                DispatchMetric::DISPATCH_METRIC_MARKET_VALUE => {
                    "DISPATCH_METRIC_MARKET_VALUE"
                }
            };
            buf.extend_from_slice(s.as_bytes());
            std::result::Result::Ok(postgres_types::IsNull::No)
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 5usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "DISPATCH_METRIC_UNSPECIFIED" => true,
                                "DISPATCH_METRIC_MAKER_FEES_PAID" => true,
                                "DISPATCH_METRIC_MAKER_FEES_RECEIVED" => true,
                                "DISPATCH_METRIC_LP_FEES_RECEIVED" => true,
                                "DISPATCH_METRIC_MARKET_VALUE" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
        fn to_sql_checked(
            &self,
            ty: &::postgres_types::Type,
            out: &mut ::postgres_types::private::BytesMut,
        ) -> ::std::result::Result<
            ::postgres_types::IsNull,
            Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
        > {
            ::postgres_types::__to_sql_checked(self, ty, out)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DispatchMetric {
        #[inline]
        fn clone(&self) -> DispatchMetric {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for DispatchMetric {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DispatchMetric {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DispatchMetric {
        #[inline]
        fn eq(&self, other: &DispatchMetric) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for DispatchMetric {}
    #[automatically_derived]
    impl ::core::cmp::Eq for DispatchMetric {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DispatchMetric {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                DispatchMetric::DISPATCH_METRIC_UNSPECIFIED => {
                    ::core::fmt::Formatter::write_str(f, "DISPATCH_METRIC_UNSPECIFIED")
                }
                DispatchMetric::DISPATCH_METRIC_MAKER_FEES_PAID => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "DISPATCH_METRIC_MAKER_FEES_PAID",
                    )
                }
                DispatchMetric::DISPATCH_METRIC_MAKER_FEES_RECEIVED => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "DISPATCH_METRIC_MAKER_FEES_RECEIVED",
                    )
                }
                DispatchMetric::DISPATCH_METRIC_LP_FEES_RECEIVED => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "DISPATCH_METRIC_LP_FEES_RECEIVED",
                    )
                }
                DispatchMetric::DISPATCH_METRIC_MARKET_VALUE => {
                    ::core::fmt::Formatter::write_str(f, "DISPATCH_METRIC_MARKET_VALUE")
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for DispatchMetric {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    impl ::protobuf::Enum for DispatchMetric {
        const NAME: &'static str = "DispatchMetric";
        fn value(&self) -> i32 {
            *self as i32
        }
        fn from_i32(value: i32) -> ::std::option::Option<DispatchMetric> {
            match value {
                0 => {
                    ::std::option::Option::Some(
                        DispatchMetric::DISPATCH_METRIC_UNSPECIFIED,
                    )
                }
                1 => {
                    ::std::option::Option::Some(
                        DispatchMetric::DISPATCH_METRIC_MAKER_FEES_PAID,
                    )
                }
                2 => {
                    ::std::option::Option::Some(
                        DispatchMetric::DISPATCH_METRIC_MAKER_FEES_RECEIVED,
                    )
                }
                3 => {
                    ::std::option::Option::Some(
                        DispatchMetric::DISPATCH_METRIC_LP_FEES_RECEIVED,
                    )
                }
                4 => {
                    ::std::option::Option::Some(
                        DispatchMetric::DISPATCH_METRIC_MARKET_VALUE,
                    )
                }
                _ => ::std::option::Option::None,
            }
        }
        const VALUES: &'static [DispatchMetric] = &[
            DispatchMetric::DISPATCH_METRIC_UNSPECIFIED,
            DispatchMetric::DISPATCH_METRIC_MAKER_FEES_PAID,
            DispatchMetric::DISPATCH_METRIC_MAKER_FEES_RECEIVED,
            DispatchMetric::DISPATCH_METRIC_LP_FEES_RECEIVED,
            DispatchMetric::DISPATCH_METRIC_MARKET_VALUE,
        ];
    }
    impl ::protobuf::EnumFull for DispatchMetric {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::EnumDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .enum_by_package_relative_name("DispatchMetric")
                        .unwrap()
                })
                .clone()
        }
        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }
    impl ::std::default::Default for DispatchMetric {
        fn default() -> Self {
            DispatchMetric::DISPATCH_METRIC_UNSPECIFIED
        }
    }
    impl DispatchMetric {
        fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<
                DispatchMetric,
            >("DispatchMetric")
        }
    }
    #[postgres(name = "transfer_type")]
    pub enum NodeStatus {
        NODE_STATUS_UNSPECIFIED = 0,
        NODE_STATUS_VALIDATOR = 1,
        NODE_STATUS_NON_VALIDATOR = 2,
    }
    impl<'a> postgres_types::FromSql<'a> for NodeStatus {
        fn from_sql(
            _type: &postgres_types::Type,
            buf: &'a [u8],
        ) -> std::result::Result<
            NodeStatus,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            match std::str::from_utf8(buf)? {
                "NODE_STATUS_UNSPECIFIED" => {
                    std::result::Result::Ok(NodeStatus::NODE_STATUS_UNSPECIFIED)
                }
                "NODE_STATUS_VALIDATOR" => {
                    std::result::Result::Ok(NodeStatus::NODE_STATUS_VALIDATOR)
                }
                "NODE_STATUS_NON_VALIDATOR" => {
                    std::result::Result::Ok(NodeStatus::NODE_STATUS_NON_VALIDATOR)
                }
                s => {
                    std::result::Result::Err(
                        std::convert::Into::into({
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &["invalid variant `", "`"],
                                    &[::core::fmt::ArgumentV1::new_display(&s)],
                                ),
                            );
                            res
                        }),
                    )
                }
            }
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 3usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "NODE_STATUS_UNSPECIFIED" => true,
                                "NODE_STATUS_VALIDATOR" => true,
                                "NODE_STATUS_NON_VALIDATOR" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
    }
    impl postgres_types::ToSql for NodeStatus {
        fn to_sql(
            &self,
            _type: &postgres_types::Type,
            buf: &mut postgres_types::private::BytesMut,
        ) -> std::result::Result<
            postgres_types::IsNull,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            let s = match *self {
                NodeStatus::NODE_STATUS_UNSPECIFIED => "NODE_STATUS_UNSPECIFIED",
                NodeStatus::NODE_STATUS_VALIDATOR => "NODE_STATUS_VALIDATOR",
                NodeStatus::NODE_STATUS_NON_VALIDATOR => "NODE_STATUS_NON_VALIDATOR",
            };
            buf.extend_from_slice(s.as_bytes());
            std::result::Result::Ok(postgres_types::IsNull::No)
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 3usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "NODE_STATUS_UNSPECIFIED" => true,
                                "NODE_STATUS_VALIDATOR" => true,
                                "NODE_STATUS_NON_VALIDATOR" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
        fn to_sql_checked(
            &self,
            ty: &::postgres_types::Type,
            out: &mut ::postgres_types::private::BytesMut,
        ) -> ::std::result::Result<
            ::postgres_types::IsNull,
            Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
        > {
            ::postgres_types::__to_sql_checked(self, ty, out)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for NodeStatus {
        #[inline]
        fn clone(&self) -> NodeStatus {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for NodeStatus {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for NodeStatus {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for NodeStatus {
        #[inline]
        fn eq(&self, other: &NodeStatus) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for NodeStatus {}
    #[automatically_derived]
    impl ::core::cmp::Eq for NodeStatus {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for NodeStatus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                NodeStatus::NODE_STATUS_UNSPECIFIED => {
                    ::core::fmt::Formatter::write_str(f, "NODE_STATUS_UNSPECIFIED")
                }
                NodeStatus::NODE_STATUS_VALIDATOR => {
                    ::core::fmt::Formatter::write_str(f, "NODE_STATUS_VALIDATOR")
                }
                NodeStatus::NODE_STATUS_NON_VALIDATOR => {
                    ::core::fmt::Formatter::write_str(f, "NODE_STATUS_NON_VALIDATOR")
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for NodeStatus {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    impl ::protobuf::Enum for NodeStatus {
        const NAME: &'static str = "NodeStatus";
        fn value(&self) -> i32 {
            *self as i32
        }
        fn from_i32(value: i32) -> ::std::option::Option<NodeStatus> {
            match value {
                0 => ::std::option::Option::Some(NodeStatus::NODE_STATUS_UNSPECIFIED),
                1 => ::std::option::Option::Some(NodeStatus::NODE_STATUS_VALIDATOR),
                2 => ::std::option::Option::Some(NodeStatus::NODE_STATUS_NON_VALIDATOR),
                _ => ::std::option::Option::None,
            }
        }
        const VALUES: &'static [NodeStatus] = &[
            NodeStatus::NODE_STATUS_UNSPECIFIED,
            NodeStatus::NODE_STATUS_VALIDATOR,
            NodeStatus::NODE_STATUS_NON_VALIDATOR,
        ];
    }
    impl ::protobuf::EnumFull for NodeStatus {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::EnumDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .enum_by_package_relative_name("NodeStatus")
                        .unwrap()
                })
                .clone()
        }
        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }
    impl ::std::default::Default for NodeStatus {
        fn default() -> Self {
            NodeStatus::NODE_STATUS_UNSPECIFIED
        }
    }
    impl NodeStatus {
        fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<
                NodeStatus,
            >("NodeStatus")
        }
    }
    #[postgres(name = "transfer_type")]
    pub enum EpochAction {
        EPOCH_ACTION_UNSPECIFIED = 0,
        EPOCH_ACTION_START = 1,
        EPOCH_ACTION_END = 2,
    }
    impl<'a> postgres_types::FromSql<'a> for EpochAction {
        fn from_sql(
            _type: &postgres_types::Type,
            buf: &'a [u8],
        ) -> std::result::Result<
            EpochAction,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            match std::str::from_utf8(buf)? {
                "EPOCH_ACTION_UNSPECIFIED" => {
                    std::result::Result::Ok(EpochAction::EPOCH_ACTION_UNSPECIFIED)
                }
                "EPOCH_ACTION_START" => {
                    std::result::Result::Ok(EpochAction::EPOCH_ACTION_START)
                }
                "EPOCH_ACTION_END" => {
                    std::result::Result::Ok(EpochAction::EPOCH_ACTION_END)
                }
                s => {
                    std::result::Result::Err(
                        std::convert::Into::into({
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &["invalid variant `", "`"],
                                    &[::core::fmt::ArgumentV1::new_display(&s)],
                                ),
                            );
                            res
                        }),
                    )
                }
            }
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 3usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "EPOCH_ACTION_UNSPECIFIED" => true,
                                "EPOCH_ACTION_START" => true,
                                "EPOCH_ACTION_END" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
    }
    impl postgres_types::ToSql for EpochAction {
        fn to_sql(
            &self,
            _type: &postgres_types::Type,
            buf: &mut postgres_types::private::BytesMut,
        ) -> std::result::Result<
            postgres_types::IsNull,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            let s = match *self {
                EpochAction::EPOCH_ACTION_UNSPECIFIED => "EPOCH_ACTION_UNSPECIFIED",
                EpochAction::EPOCH_ACTION_START => "EPOCH_ACTION_START",
                EpochAction::EPOCH_ACTION_END => "EPOCH_ACTION_END",
            };
            buf.extend_from_slice(s.as_bytes());
            std::result::Result::Ok(postgres_types::IsNull::No)
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 3usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "EPOCH_ACTION_UNSPECIFIED" => true,
                                "EPOCH_ACTION_START" => true,
                                "EPOCH_ACTION_END" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
        fn to_sql_checked(
            &self,
            ty: &::postgres_types::Type,
            out: &mut ::postgres_types::private::BytesMut,
        ) -> ::std::result::Result<
            ::postgres_types::IsNull,
            Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
        > {
            ::postgres_types::__to_sql_checked(self, ty, out)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EpochAction {
        #[inline]
        fn clone(&self) -> EpochAction {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for EpochAction {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EpochAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EpochAction {
        #[inline]
        fn eq(&self, other: &EpochAction) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for EpochAction {}
    #[automatically_derived]
    impl ::core::cmp::Eq for EpochAction {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EpochAction {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                EpochAction::EPOCH_ACTION_UNSPECIFIED => {
                    ::core::fmt::Formatter::write_str(f, "EPOCH_ACTION_UNSPECIFIED")
                }
                EpochAction::EPOCH_ACTION_START => {
                    ::core::fmt::Formatter::write_str(f, "EPOCH_ACTION_START")
                }
                EpochAction::EPOCH_ACTION_END => {
                    ::core::fmt::Formatter::write_str(f, "EPOCH_ACTION_END")
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for EpochAction {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    impl ::protobuf::Enum for EpochAction {
        const NAME: &'static str = "EpochAction";
        fn value(&self) -> i32 {
            *self as i32
        }
        fn from_i32(value: i32) -> ::std::option::Option<EpochAction> {
            match value {
                0 => ::std::option::Option::Some(EpochAction::EPOCH_ACTION_UNSPECIFIED),
                1 => ::std::option::Option::Some(EpochAction::EPOCH_ACTION_START),
                2 => ::std::option::Option::Some(EpochAction::EPOCH_ACTION_END),
                _ => ::std::option::Option::None,
            }
        }
        const VALUES: &'static [EpochAction] = &[
            EpochAction::EPOCH_ACTION_UNSPECIFIED,
            EpochAction::EPOCH_ACTION_START,
            EpochAction::EPOCH_ACTION_END,
        ];
    }
    impl ::protobuf::EnumFull for EpochAction {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::EnumDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .enum_by_package_relative_name("EpochAction")
                        .unwrap()
                })
                .clone()
        }
        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }
    impl ::std::default::Default for EpochAction {
        fn default() -> Self {
            EpochAction::EPOCH_ACTION_UNSPECIFIED
        }
    }
    impl EpochAction {
        fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<
                EpochAction,
            >("EpochAction")
        }
    }
    #[postgres(name = "transfer_type")]
    pub enum ValidatorNodeStatus {
        VALIDATOR_NODE_STATUS_UNSPECIFIED = 0,
        VALIDATOR_NODE_STATUS_TENDERMINT = 1,
        VALIDATOR_NODE_STATUS_ERSATZ = 2,
        VALIDATOR_NODE_STATUS_PENDING = 3,
    }
    impl<'a> postgres_types::FromSql<'a> for ValidatorNodeStatus {
        fn from_sql(
            _type: &postgres_types::Type,
            buf: &'a [u8],
        ) -> std::result::Result<
            ValidatorNodeStatus,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            match std::str::from_utf8(buf)? {
                "VALIDATOR_NODE_STATUS_UNSPECIFIED" => {
                    std::result::Result::Ok(
                        ValidatorNodeStatus::VALIDATOR_NODE_STATUS_UNSPECIFIED,
                    )
                }
                "VALIDATOR_NODE_STATUS_TENDERMINT" => {
                    std::result::Result::Ok(
                        ValidatorNodeStatus::VALIDATOR_NODE_STATUS_TENDERMINT,
                    )
                }
                "VALIDATOR_NODE_STATUS_ERSATZ" => {
                    std::result::Result::Ok(
                        ValidatorNodeStatus::VALIDATOR_NODE_STATUS_ERSATZ,
                    )
                }
                "VALIDATOR_NODE_STATUS_PENDING" => {
                    std::result::Result::Ok(
                        ValidatorNodeStatus::VALIDATOR_NODE_STATUS_PENDING,
                    )
                }
                s => {
                    std::result::Result::Err(
                        std::convert::Into::into({
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &["invalid variant `", "`"],
                                    &[::core::fmt::ArgumentV1::new_display(&s)],
                                ),
                            );
                            res
                        }),
                    )
                }
            }
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 4usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "VALIDATOR_NODE_STATUS_UNSPECIFIED" => true,
                                "VALIDATOR_NODE_STATUS_TENDERMINT" => true,
                                "VALIDATOR_NODE_STATUS_ERSATZ" => true,
                                "VALIDATOR_NODE_STATUS_PENDING" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
    }
    impl postgres_types::ToSql for ValidatorNodeStatus {
        fn to_sql(
            &self,
            _type: &postgres_types::Type,
            buf: &mut postgres_types::private::BytesMut,
        ) -> std::result::Result<
            postgres_types::IsNull,
            std::boxed::Box<
                dyn std::error::Error + std::marker::Sync + std::marker::Send,
            >,
        > {
            let s = match *self {
                ValidatorNodeStatus::VALIDATOR_NODE_STATUS_UNSPECIFIED => {
                    "VALIDATOR_NODE_STATUS_UNSPECIFIED"
                }
                ValidatorNodeStatus::VALIDATOR_NODE_STATUS_TENDERMINT => {
                    "VALIDATOR_NODE_STATUS_TENDERMINT"
                }
                ValidatorNodeStatus::VALIDATOR_NODE_STATUS_ERSATZ => {
                    "VALIDATOR_NODE_STATUS_ERSATZ"
                }
                ValidatorNodeStatus::VALIDATOR_NODE_STATUS_PENDING => {
                    "VALIDATOR_NODE_STATUS_PENDING"
                }
            };
            buf.extend_from_slice(s.as_bytes());
            std::result::Result::Ok(postgres_types::IsNull::No)
        }
        fn accepts(type_: &postgres_types::Type) -> bool {
            if type_.name() != "transfer_type" {
                return false;
            }
            match *type_.kind() {
                ::postgres_types::Kind::Enum(ref variants) => {
                    if variants.len() != 4usize {
                        return false;
                    }
                    variants
                        .iter()
                        .all(|v| {
                            match &**v {
                                "VALIDATOR_NODE_STATUS_UNSPECIFIED" => true,
                                "VALIDATOR_NODE_STATUS_TENDERMINT" => true,
                                "VALIDATOR_NODE_STATUS_ERSATZ" => true,
                                "VALIDATOR_NODE_STATUS_PENDING" => true,
                                _ => false,
                            }
                        })
                }
                _ => false,
            }
        }
        fn to_sql_checked(
            &self,
            ty: &::postgres_types::Type,
            out: &mut ::postgres_types::private::BytesMut,
        ) -> ::std::result::Result<
            ::postgres_types::IsNull,
            Box<dyn ::std::error::Error + ::std::marker::Sync + ::std::marker::Send>,
        > {
            ::postgres_types::__to_sql_checked(self, ty, out)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ValidatorNodeStatus {
        #[inline]
        fn clone(&self) -> ValidatorNodeStatus {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ValidatorNodeStatus {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ValidatorNodeStatus {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ValidatorNodeStatus {
        #[inline]
        fn eq(&self, other: &ValidatorNodeStatus) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ValidatorNodeStatus {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ValidatorNodeStatus {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ValidatorNodeStatus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ValidatorNodeStatus::VALIDATOR_NODE_STATUS_UNSPECIFIED => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "VALIDATOR_NODE_STATUS_UNSPECIFIED",
                    )
                }
                ValidatorNodeStatus::VALIDATOR_NODE_STATUS_TENDERMINT => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "VALIDATOR_NODE_STATUS_TENDERMINT",
                    )
                }
                ValidatorNodeStatus::VALIDATOR_NODE_STATUS_ERSATZ => {
                    ::core::fmt::Formatter::write_str(f, "VALIDATOR_NODE_STATUS_ERSATZ")
                }
                ValidatorNodeStatus::VALIDATOR_NODE_STATUS_PENDING => {
                    ::core::fmt::Formatter::write_str(f, "VALIDATOR_NODE_STATUS_PENDING")
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ValidatorNodeStatus {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    impl ::protobuf::Enum for ValidatorNodeStatus {
        const NAME: &'static str = "ValidatorNodeStatus";
        fn value(&self) -> i32 {
            *self as i32
        }
        fn from_i32(value: i32) -> ::std::option::Option<ValidatorNodeStatus> {
            match value {
                0 => {
                    ::std::option::Option::Some(
                        ValidatorNodeStatus::VALIDATOR_NODE_STATUS_UNSPECIFIED,
                    )
                }
                1 => {
                    ::std::option::Option::Some(
                        ValidatorNodeStatus::VALIDATOR_NODE_STATUS_TENDERMINT,
                    )
                }
                2 => {
                    ::std::option::Option::Some(
                        ValidatorNodeStatus::VALIDATOR_NODE_STATUS_ERSATZ,
                    )
                }
                3 => {
                    ::std::option::Option::Some(
                        ValidatorNodeStatus::VALIDATOR_NODE_STATUS_PENDING,
                    )
                }
                _ => ::std::option::Option::None,
            }
        }
        const VALUES: &'static [ValidatorNodeStatus] = &[
            ValidatorNodeStatus::VALIDATOR_NODE_STATUS_UNSPECIFIED,
            ValidatorNodeStatus::VALIDATOR_NODE_STATUS_TENDERMINT,
            ValidatorNodeStatus::VALIDATOR_NODE_STATUS_ERSATZ,
            ValidatorNodeStatus::VALIDATOR_NODE_STATUS_PENDING,
        ];
    }
    impl ::protobuf::EnumFull for ValidatorNodeStatus {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<
                ::protobuf::reflect::EnumDescriptor,
            > = ::protobuf::rt::Lazy::new();
            descriptor
                .get(|| {
                    file_descriptor()
                        .enum_by_package_relative_name("ValidatorNodeStatus")
                        .unwrap()
                })
                .clone()
        }
        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }
    impl ::std::default::Default for ValidatorNodeStatus {
        fn default() -> Self {
            ValidatorNodeStatus::VALIDATOR_NODE_STATUS_UNSPECIFIED
        }
    }
    impl ValidatorNodeStatus {
        fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<
                ValidatorNodeStatus,
            >("ValidatorNodeStatus")
        }
    }
    static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fvega/vega.proto\x12\x04vega\x1a\x12vega/markets.proto\"\x17\n\x05P\
    arty\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"N\n\nRiskFactor\x12\x16\
    \n\x06market\x18\x01\x20\x01(\tR\x06market\x12\x14\n\x05short\x18\x02\
    \x20\x01(\tR\x05short\x12\x12\n\x04long\x18\x03\x20\x01(\tR\x04long\"Z\n\
    \x0bPeggedOrder\x123\n\treference\x18\x01\x20\x01(\x0e2\x15.vega.PeggedR\
    eferenceR\treference\x12\x16\n\x06offset\x18\x02\x20\x01(\tR\x06offset\"\
    \xe2\x08\n\x05Order\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x1b\n\
    \tmarket_id\x18\x02\x20\x01(\tR\x08marketId\x12\x19\n\x08party_id\x18\
    \x03\x20\x01(\tR\x07partyId\x12\x1e\n\x04side\x18\x04\x20\x01(\x0e2\n.ve\
    ga.SideR\x04side\x12\x14\n\x05price\x18\x05\x20\x01(\tR\x05price\x12\x12\
    \n\x04size\x18\x06\x20\x01(\x04R\x04size\x12\x1c\n\tremaining\x18\x07\
    \x20\x01(\x04R\tremaining\x12;\n\rtime_in_force\x18\x08\x20\x01(\x0e2\
    \x17.vega.Order.TimeInForceR\x0btimeInForce\x12$\n\x04type\x18\t\x20\x01\
    (\x0e2\x10.vega.Order.TypeR\x04type\x12\x1d\n\ncreated_at\x18\n\x20\x01(\
    \x03R\tcreatedAt\x12*\n\x06status\x18\x0b\x20\x01(\x0e2\x12.vega.Order.S\
    tatusR\x06status\x12\x1d\n\nexpires_at\x18\x0c\x20\x01(\x03R\texpiresAt\
    \x12\x1c\n\treference\x18\r\x20\x01(\tR\treference\x12(\n\x06reason\x18\
    \x0e\x20\x01(\x0e2\x10.vega.OrderErrorR\x06reason\x12\x1d\n\nupdated_at\
    \x18\x0f\x20\x01(\x03R\tupdatedAt\x12\x18\n\x07version\x18\x10\x20\x01(\
    \x04R\x07version\x12\x19\n\x08batch_id\x18\x11\x20\x01(\x04R\x07batchId\
    \x124\n\x0cpegged_order\x18\x12\x20\x01(\x0b2\x11.vega.PeggedOrderR\x0bp\
    eggedOrder\x124\n\x16liquidity_provision_id\x18\x13\x20\x01(\tR\x14liqui\
    dityProvisionId\"\xb6\x01\n\x0bTimeInForce\x12\x1d\n\x19TIME_IN_FORCE_UN\
    SPECIFIED\x10\0\x12\x15\n\x11TIME_IN_FORCE_GTC\x10\x01\x12\x15\n\x11TIME\
    _IN_FORCE_GTT\x10\x02\x12\x15\n\x11TIME_IN_FORCE_IOC\x10\x03\x12\x15\n\
    \x11TIME_IN_FORCE_FOK\x10\x04\x12\x15\n\x11TIME_IN_FORCE_GFA\x10\x05\x12\
    \x15\n\x11TIME_IN_FORCE_GFN\x10\x06\"O\n\x04Type\x12\x14\n\x10TYPE_UNSPE\
    CIFIED\x10\0\x12\x0e\n\nTYPE_LIMIT\x10\x01\x12\x0f\n\x0bTYPE_MARKET\x10\
    \x02\x12\x10\n\x0cTYPE_NETWORK\x10\x03\"\xc9\x01\n\x06Status\x12\x16\n\
    \x12STATUS_UNSPECIFIED\x10\0\x12\x11\n\rSTATUS_ACTIVE\x10\x01\x12\x12\n\
    \x0eSTATUS_EXPIRED\x10\x02\x12\x14\n\x10STATUS_CANCELLED\x10\x03\x12\x12\
    \n\x0eSTATUS_STOPPED\x10\x04\x12\x11\n\rSTATUS_FILLED\x10\x05\x12\x13\n\
    \x0fSTATUS_REJECTED\x10\x06\x12\x1b\n\x17STATUS_PARTIALLY_FILLED\x10\x07\
    \x12\x11\n\rSTATUS_PARKED\x10\x08\"B\n\x1dOrderCancellationConfirmation\
    \x12!\n\x05order\x18\x01\x20\x01(\x0b2\x0b.vega.OrderR\x05order\"\xa0\
    \x01\n\x11OrderConfirmation\x12!\n\x05order\x18\x01\x20\x01(\x0b2\x0b.ve\
    ga.OrderR\x05order\x12#\n\x06trades\x18\x02\x20\x03(\x0b2\x0b.vega.Trade\
    R\x06trades\x12C\n\x17passive_orders_affected\x18\x03\x20\x03(\x0b2\x0b.\
    vega.OrderR\x15passiveOrdersAffected\"\xd3\x01\n\x16AuctionIndicativeSta\
    te\x12\x1b\n\tmarket_id\x18\x01\x20\x01(\tR\x08marketId\x12)\n\x10indica\
    tive_price\x18\x02\x20\x01(\tR\x0findicativePrice\x12+\n\x11indicative_v\
    olume\x18\x03\x20\x01(\x04R\x10indicativeVolume\x12#\n\rauction_start\
    \x18\x04\x20\x01(\x03R\x0cauctionStart\x12\x1f\n\x0bauction_end\x18\x05\
    \x20\x01(\x03R\nauctionEnd\"\xdb\x04\n\x05Trade\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x1b\n\tmarket_id\x18\x02\x20\x01(\tR\x08marketId\
    \x12\x14\n\x05price\x18\x03\x20\x01(\tR\x05price\x12\x12\n\x04size\x18\
    \x04\x20\x01(\x04R\x04size\x12\x14\n\x05buyer\x18\x05\x20\x01(\tR\x05buy\
    er\x12\x16\n\x06seller\x18\x06\x20\x01(\tR\x06seller\x12(\n\taggressor\
    \x18\x07\x20\x01(\x0e2\n.vega.SideR\taggressor\x12\x1b\n\tbuy_order\x18\
    \x08\x20\x01(\tR\x08buyOrder\x12\x1d\n\nsell_order\x18\t\x20\x01(\tR\tse\
    llOrder\x12\x1c\n\ttimestamp\x18\n\x20\x01(\x03R\ttimestamp\x12$\n\x04ty\
    pe\x18\x0b\x20\x01(\x0e2\x10.vega.Trade.TypeR\x04type\x12&\n\tbuyer_fee\
    \x18\x0c\x20\x01(\x0b2\t.vega.FeeR\x08buyerFee\x12(\n\nseller_fee\x18\r\
    \x20\x01(\x0b2\t.vega.FeeR\tsellerFee\x12.\n\x13buyer_auction_batch\x18\
    \x0e\x20\x01(\x04R\x11buyerAuctionBatch\x120\n\x14seller_auction_batch\
    \x18\x0f\x20\x01(\x04R\x12sellerAuctionBatch\"o\n\x04Type\x12\x14\n\x10T\
    YPE_UNSPECIFIED\x10\0\x12\x10\n\x0cTYPE_DEFAULT\x10\x01\x12\x1f\n\x1bTYP\
    E_NETWORK_CLOSE_OUT_GOOD\x10\x02\x12\x1e\n\x1aTYPE_NETWORK_CLOSE_OUT_BAD\
    \x10\x03\"v\n\x03Fee\x12\x1b\n\tmaker_fee\x18\x01\x20\x01(\tR\x08makerFe\
    e\x12-\n\x12infrastructure_fee\x18\x02\x20\x01(\tR\x11infrastructureFee\
    \x12#\n\rliquidity_fee\x18\x03\x20\x01(\tR\x0cliquidityFee\"/\n\x08Trade\
    Set\x12#\n\x06trades\x18\x01\x20\x03(\x0b2\x0b.vega.TradeR\x06trades\"\
    \xd6\x01\n\x06Candle\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x03R\ttimesta\
    mp\x12\x1a\n\x08datetime\x18\x02\x20\x01(\tR\x08datetime\x12\x12\n\x04hi\
    gh\x18\x03\x20\x01(\tR\x04high\x12\x10\n\x03low\x18\x04\x20\x01(\tR\x03l\
    ow\x12\x12\n\x04open\x18\x05\x20\x01(\tR\x04open\x12\x14\n\x05close\x18\
    \x06\x20\x01(\tR\x05close\x12\x16\n\x06volume\x18\x07\x20\x01(\x04R\x06v\
    olume\x12*\n\x08interval\x18\x08\x20\x01(\x0e2\x0e.vega.IntervalR\x08int\
    erval\"d\n\nPriceLevel\x12\x14\n\x05price\x18\x01\x20\x01(\tR\x05price\
    \x12(\n\x10number_of_orders\x18\x02\x20\x01(\x04R\x0enumberOfOrders\x12\
    \x16\n\x06volume\x18\x03\x20\x01(\x04R\x06volume\"\x9d\x01\n\x0bMarketDe\
    pth\x12\x1b\n\tmarket_id\x18\x01\x20\x01(\tR\x08marketId\x12\"\n\x03buy\
    \x18\x02\x20\x03(\x0b2\x10.vega.PriceLevelR\x03buy\x12$\n\x04sell\x18\
    \x03\x20\x03(\x0b2\x10.vega.PriceLevelR\x04sell\x12'\n\x0fsequence_numbe\
    r\x18\x04\x20\x01(\x04R\x0esequenceNumber\"\xdd\x01\n\x11MarketDepthUpda\
    te\x12\x1b\n\tmarket_id\x18\x01\x20\x01(\tR\x08marketId\x12\"\n\x03buy\
    \x18\x02\x20\x03(\x0b2\x10.vega.PriceLevelR\x03buy\x12$\n\x04sell\x18\
    \x03\x20\x03(\x0b2\x10.vega.PriceLevelR\x04sell\x12'\n\x0fsequence_numbe\
    r\x18\x04\x20\x01(\x04R\x0esequenceNumber\x128\n\x18previous_sequence_nu\
    mber\x18\x05\x20\x01(\x04R\x16previousSequenceNumber\"\xfc\x01\n\x08Posi\
    tion\x12\x1b\n\tmarket_id\x18\x01\x20\x01(\tR\x08marketId\x12\x19\n\x08p\
    arty_id\x18\x02\x20\x01(\tR\x07partyId\x12\x1f\n\x0bopen_volume\x18\x03\
    \x20\x01(\x03R\nopenVolume\x12!\n\x0crealised_pnl\x18\x04\x20\x01(\tR\
    \x0brealisedPnl\x12%\n\x0eunrealised_pnl\x18\x05\x20\x01(\tR\runrealised\
    Pnl\x12.\n\x13average_entry_price\x18\x06\x20\x01(\tR\x11averageEntryPri\
    ce\x12\x1d\n\nupdated_at\x18\x07\x20\x01(\x03R\tupdatedAt\"=\n\rPosition\
    Trade\x12\x16\n\x06volume\x18\x01\x20\x01(\x03R\x06volume\x12\x14\n\x05p\
    rice\x18\x02\x20\x01(\tR\x05price\"\xe4\x02\n\x07Deposit\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\x12,\n\x06status\x18\x02\x20\x01(\x0e2\x14.ve\
    ga.Deposit.StatusR\x06status\x12\x19\n\x08party_id\x18\x03\x20\x01(\tR\
    \x07partyId\x12\x14\n\x05asset\x18\x04\x20\x01(\tR\x05asset\x12\x16\n\
    \x06amount\x18\x05\x20\x01(\tR\x06amount\x12\x17\n\x07tx_hash\x18\x06\
    \x20\x01(\tR\x06txHash\x12-\n\x12credited_timestamp\x18\x07\x20\x01(\x03\
    R\x11creditedTimestamp\x12+\n\x11created_timestamp\x18\x08\x20\x01(\x03R\
    \x10createdTimestamp\"]\n\x06Status\x12\x16\n\x12STATUS_UNSPECIFIED\x10\
    \0\x12\x0f\n\x0bSTATUS_OPEN\x10\x01\x12\x14\n\x10STATUS_CANCELLED\x10\
    \x02\x12\x14\n\x10STATUS_FINALIZED\x10\x03\"\xba\x03\n\nWithdrawal\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x19\n\x08party_id\x18\x02\x20\
    \x01(\tR\x07partyId\x12\x16\n\x06amount\x18\x03\x20\x01(\tR\x06amount\
    \x12\x14\n\x05asset\x18\x04\x20\x01(\tR\x05asset\x12/\n\x06status\x18\
    \x05\x20\x01(\x0e2\x17.vega.Withdrawal.StatusR\x06status\x12\x10\n\x03re\
    f\x18\x06\x20\x01(\tR\x03ref\x12\x16\n\x06expiry\x18\x07\x20\x01(\x03R\
    \x06expiry\x12\x17\n\x07tx_hash\x18\x08\x20\x01(\tR\x06txHash\x12+\n\x11\
    created_timestamp\x18\t\x20\x01(\x03R\x10createdTimestamp\x12/\n\x13with\
    drawn_timestamp\x18\n\x20\x01(\x03R\x12withdrawnTimestamp\x12#\n\x03ext\
    \x18\x0b\x20\x01(\x0b2\x11.vega.WithdrawExtR\x03ext\"\\\n\x06Status\x12\
    \x16\n\x12STATUS_UNSPECIFIED\x10\0\x12\x0f\n\x0bSTATUS_OPEN\x10\x01\x12\
    \x13\n\x0fSTATUS_REJECTED\x10\x02\x12\x14\n\x10STATUS_FINALIZED\x10\x03\
    \"D\n\x0bWithdrawExt\x12.\n\x05erc20\x18\x01\x20\x01(\x0b2\x16.vega.Erc2\
    0WithdrawExtH\0R\x05erc20B\x05\n\x03ext\"=\n\x10Erc20WithdrawExt\x12)\n\
    \x10receiver_address\x18\x01\x20\x01(\tR\x0freceiverAddress\"\xa3\x01\n\
    \x07Account\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x14\n\x05owner\
    \x18\x02\x20\x01(\tR\x05owner\x12\x18\n\x07balance\x18\x03\x20\x01(\tR\
    \x07balance\x12\x14\n\x05asset\x18\x04\x20\x01(\tR\x05asset\x12\x1b\n\tm\
    arket_id\x18\x05\x20\x01(\tR\x08marketId\x12%\n\x04type\x18\x06\x20\x01(\
    \x0e2\x11.vega.AccountTypeR\x04type\"?\n\x0fFinancialAmount\x12\x16\n\
    \x06amount\x18\x01\x20\x01(\tR\x06amount\x12\x14\n\x05asset\x18\x02\x20\
    \x01(\tR\x05asset\"\xb3\x01\n\x08Transfer\x12\x14\n\x05owner\x18\x01\x20\
    \x01(\tR\x05owner\x12-\n\x06amount\x18\x02\x20\x01(\x0b2\x15.vega.Financ\
    ialAmountR\x06amount\x12&\n\x04type\x18\x03\x20\x01(\x0e2\x12.vega.Trans\
    ferTypeR\x04type\x12\x1d\n\nmin_amount\x18\x04\x20\x01(\tR\tminAmount\
    \x12\x1b\n\tmarket_id\x18\x05\x20\x01(\tR\x08marketId\"\x84\x01\n\x10Dis\
    patchStrategy\x12(\n\x10asset_for_metric\x18\x01\x20\x01(\tR\x0eassetFor\
    Metric\x12,\n\x06metric\x18\x02\x20\x01(\x0e2\x14.vega.DispatchMetricR\
    \x06metric\x12\x18\n\x07markets\x18\x03\x20\x03(\tR\x07markets\"\xe6\x01\
    \n\x0fTransferRequest\x120\n\x0cfrom_account\x18\x01\x20\x03(\x0b2\r.veg\
    a.AccountR\x0bfromAccount\x12,\n\nto_account\x18\x02\x20\x03(\x0b2\r.veg\
    a.AccountR\ttoAccount\x12\x16\n\x06amount\x18\x03\x20\x01(\tR\x06amount\
    \x12\x1d\n\nmin_amount\x18\x04\x20\x01(\tR\tminAmount\x12\x14\n\x05asset\
    \x18\x05\x20\x01(\tR\x05asset\x12&\n\x04type\x18\x07\x20\x01(\x0e2\x12.v\
    ega.TransferTypeR\x04type\"\xa7\x01\n\x0eAccountDetails\x12\x19\n\x08ass\
    et_id\x18\x01\x20\x01(\tR\x07assetId\x12%\n\x04type\x18\x02\x20\x01(\x0e\
    2\x11.vega.AccountTypeR\x04type\x12\x19\n\x05owner\x18\x03\x20\x01(\tH\0\
    R\x05owner\x88\x01\x01\x12\x20\n\tmarket_id\x18\x04\x20\x01(\tH\x01R\x08\
    marketId\x88\x01\x01B\x08\n\x06_ownerB\x0c\n\n_market_id\"\xd9\x01\n\x0b\
    LedgerEntry\x127\n\x0cfrom_account\x18\x01\x20\x01(\x0b2\x14.vega.Accoun\
    tDetailsR\x0bfromAccount\x123\n\nto_account\x18\x02\x20\x01(\x0b2\x14.ve\
    ga.AccountDetailsR\ttoAccount\x12\x16\n\x06amount\x18\x03\x20\x01(\tR\
    \x06amount\x12&\n\x04type\x18\x04\x20\x01(\x0e2\x12.vega.TransferTypeR\
    \x04type\x12\x1c\n\ttimestamp\x18\x05\x20\x01(\x03R\ttimestamp\"_\n\x13P\
    ostTransferBalance\x12.\n\x07account\x18\x01\x20\x01(\x0b2\x14.vega.Acco\
    untDetailsR\x07account\x12\x18\n\x07balance\x18\x02\x20\x01(\tR\x07balan\
    ce\"t\n\x0eLedgerMovement\x12+\n\x07entries\x18\x01\x20\x03(\x0b2\x11.ve\
    ga.LedgerEntryR\x07entries\x125\n\x08balances\x18\x02\x20\x03(\x0b2\x19.\
    vega.PostTransferBalanceR\x08balances\"\xad\x02\n\x0cMarginLevels\x12-\n\
    \x12maintenance_margin\x18\x01\x20\x01(\tR\x11maintenanceMargin\x12!\n\
    \x0csearch_level\x18\x02\x20\x01(\tR\x0bsearchLevel\x12%\n\x0einitial_ma\
    rgin\x18\x03\x20\x01(\tR\rinitialMargin\x128\n\x18collateral_release_lev\
    el\x18\x04\x20\x01(\tR\x16collateralReleaseLevel\x12\x19\n\x08party_id\
    \x18\x05\x20\x01(\tR\x07partyId\x12\x1b\n\tmarket_id\x18\x06\x20\x01(\tR\
    \x08marketId\x12\x14\n\x05asset\x18\x07\x20\x01(\tR\x05asset\x12\x1c\n\t\
    timestamp\x18\x08\x20\x01(\x03R\ttimestamp\"\x8a\n\n\nMarketData\x12\x1d\
    \n\nmark_price\x18\x01\x20\x01(\tR\tmarkPrice\x12$\n\x0ebest_bid_price\
    \x18\x02\x20\x01(\tR\x0cbestBidPrice\x12&\n\x0fbest_bid_volume\x18\x03\
    \x20\x01(\x04R\rbestBidVolume\x12(\n\x10best_offer_price\x18\x04\x20\x01\
    (\tR\x0ebestOfferPrice\x12*\n\x11best_offer_volume\x18\x05\x20\x01(\x04R\
    \x0fbestOfferVolume\x121\n\x15best_static_bid_price\x18\x06\x20\x01(\tR\
    \x12bestStaticBidPrice\x123\n\x16best_static_bid_volume\x18\x07\x20\x01(\
    \x04R\x13bestStaticBidVolume\x125\n\x17best_static_offer_price\x18\x08\
    \x20\x01(\tR\x14bestStaticOfferPrice\x127\n\x18best_static_offer_volume\
    \x18\t\x20\x01(\x04R\x15bestStaticOfferVolume\x12\x1b\n\tmid_price\x18\n\
    \x20\x01(\tR\x08midPrice\x12(\n\x10static_mid_price\x18\x0b\x20\x01(\tR\
    \x0estaticMidPrice\x12\x16\n\x06market\x18\x0c\x20\x01(\tR\x06market\x12\
    \x1c\n\ttimestamp\x18\r\x20\x01(\x03R\ttimestamp\x12#\n\ropen_interest\
    \x18\x0e\x20\x01(\x04R\x0copenInterest\x12\x1f\n\x0bauction_end\x18\x0f\
    \x20\x01(\x03R\nauctionEnd\x12#\n\rauction_start\x18\x10\x20\x01(\x03R\
    \x0cauctionStart\x12)\n\x10indicative_price\x18\x11\x20\x01(\tR\x0findic\
    ativePrice\x12+\n\x11indicative_volume\x18\x12\x20\x01(\x04R\x10indicati\
    veVolume\x12H\n\x13market_trading_mode\x18\x13\x20\x01(\x0e2\x18.vega.Ma\
    rket.TradingModeR\x11marketTradingMode\x12.\n\x07trigger\x18\x14\x20\x01\
    (\x0e2\x14.vega.AuctionTriggerR\x07trigger\x12A\n\x11extension_trigger\
    \x18\x15\x20\x01(\x0e2\x14.vega.AuctionTriggerR\x10extensionTrigger\x12!\
    \n\x0ctarget_stake\x18\x16\x20\x01(\tR\x0btargetStake\x12%\n\x0esupplied\
    _stake\x18\x17\x20\x01(\tR\rsuppliedStake\x12S\n\x17price_monitoring_bou\
    nds\x18\x18\x20\x03(\x0b2\x1b.vega.PriceMonitoringBoundsR\x15priceMonito\
    ringBounds\x12,\n\x12market_value_proxy\x18\x19\x20\x01(\tR\x10marketVal\
    ueProxy\x12`\n\x1cliquidity_provider_fee_share\x18\x1a\x20\x03(\x0b2\x1f\
    .vega.LiquidityProviderFeeShareR\x19liquidityProviderFeeShare\x125\n\x0c\
    market_state\x18\x1b\x20\x01(\x0e2\x12.vega.Market.StateR\x0bmarketState\
    \"\x95\x01\n\x19LiquidityProviderFeeShare\x12\x14\n\x05party\x18\x01\x20\
    \x01(\tR\x05party\x12*\n\x11equity_like_share\x18\x02\x20\x01(\tR\x0fequ\
    ityLikeShare\x126\n\x17average_entry_valuation\x18\x03\x20\x01(\tR\x15av\
    erageEntryValuation\"\xc8\x01\n\x15PriceMonitoringBounds\x12&\n\x0fmin_v\
    alid_price\x18\x01\x20\x01(\tR\rminValidPrice\x12&\n\x0fmax_valid_price\
    \x18\x02\x20\x01(\tR\rmaxValidPrice\x126\n\x07trigger\x18\x03\x20\x01(\
    \x0b2\x1c.vega.PriceMonitoringTriggerR\x07trigger\x12'\n\x0freference_pr\
    ice\x18\x04\x20\x01(\tR\x0ereferencePrice\"Q\n\x0bErrorDetail\x12\x12\n\
    \x04code\x18\x01\x20\x01(\x05R\x04code\x12\x18\n\x07message\x18\x02\x20\
    \x01(\tR\x07message\x12\x14\n\x05inner\x18\x03\x20\x01(\tR\x05inner\":\n\
    \x10NetworkParameter\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\
    \n\x05value\x18\x02\x20\x01(\tR\x05value\"\xd9\x03\n\rNetworkLimits\x12,\
    \n\x12can_propose_market\x18\x01\x20\x01(\x08R\x10canProposeMarket\x12*\
    \n\x11can_propose_asset\x18\x02\x20\x01(\x08R\x0fcanProposeAsset\x12-\n\
    \x12bootstrap_finished\x18\x03\x20\x01(\x08R\x11bootstrapFinished\x124\n\
    \x16propose_market_enabled\x18\x04\x20\x01(\x08R\x14proposeMarketEnabled\
    \x122\n\x15propose_asset_enabled\x18\x05\x20\x01(\x08R\x13proposeAssetEn\
    abled\x122\n\x15bootstrap_block_count\x18\x06\x20\x01(\rR\x13bootstrapBl\
    ockCount\x12%\n\x0egenesis_loaded\x18\x07\x20\x01(\x08R\rgenesisLoaded\
    \x12=\n\x1bpropose_market_enabled_from\x18\x08\x20\x01(\x03R\x18proposeM\
    arketEnabledFrom\x12;\n\x1apropose_asset_enabled_from\x18\t\x20\x01(\x03\
    R\x17proposeAssetEnabledFrom\"}\n\x0eLiquidityOrder\x123\n\treference\
    \x18\x01\x20\x01(\x0e2\x15.vega.PeggedReferenceR\treference\x12\x1e\n\np\
    roportion\x18\x02\x20\x01(\rR\nproportion\x12\x16\n\x06offset\x18\x03\
    \x20\x01(\tR\x06offset\"s\n\x17LiquidityOrderReference\x12\x19\n\x08orde\
    r_id\x18\x01\x20\x01(\tR\x07orderId\x12=\n\x0fliquidity_order\x18\x02\
    \x20\x01(\x0b2\x14.vega.LiquidityOrderR\x0eliquidityOrder\"\xd2\x04\n\
    \x12LiquidityProvision\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x19\
    \n\x08party_id\x18\x02\x20\x01(\tR\x07partyId\x12\x1d\n\ncreated_at\x18\
    \x03\x20\x01(\x03R\tcreatedAt\x12\x1d\n\nupdated_at\x18\x04\x20\x01(\x03\
    R\tupdatedAt\x12\x1b\n\tmarket_id\x18\x05\x20\x01(\tR\x08marketId\x12+\n\
    \x11commitment_amount\x18\x06\x20\x01(\tR\x10commitmentAmount\x12\x10\n\
    \x03fee\x18\x07\x20\x01(\tR\x03fee\x123\n\x05sells\x18\x08\x20\x03(\x0b2\
    \x1d.vega.LiquidityOrderReferenceR\x05sells\x121\n\x04buys\x18\t\x20\x03\
    (\x0b2\x1d.vega.LiquidityOrderReferenceR\x04buys\x12\x18\n\x07version\
    \x18\n\x20\x01(\x04R\x07version\x127\n\x06status\x18\x0b\x20\x01(\x0e2\
    \x1f.vega.LiquidityProvision.StatusR\x06status\x12\x1c\n\treference\x18\
    \x0c\x20\x01(\tR\treference\"\x9d\x01\n\x06Status\x12\x16\n\x12STATUS_UN\
    SPECIFIED\x10\0\x12\x11\n\rSTATUS_ACTIVE\x10\x01\x12\x12\n\x0eSTATUS_STO\
    PPED\x10\x02\x12\x14\n\x10STATUS_CANCELLED\x10\x03\x12\x13\n\x0fSTATUS_R\
    EJECTED\x10\x04\x12\x15\n\x11STATUS_UNDEPLOYED\x10\x05\x12\x12\n\x0eSTAT\
    US_PENDING\x10\x06\"\xd0\x03\n\x0eEthereumConfig\x12\x1d\n\nnetwork_id\
    \x18\x01\x20\x01(\tR\tnetworkId\x12\x19\n\x08chain_id\x18\x02\x20\x01(\t\
    R\x07chainId\x12Z\n\x1acollateral_bridge_contract\x18\x03\x20\x01(\x0b2\
    \x1c.vega.EthereumContractConfigR\x18collateralBridgeContract\x12$\n\rco\
    nfirmations\x18\x04\x20\x01(\rR\rconfirmations\x12T\n\x17staking_bridge_\
    contract\x18\x05\x20\x01(\x0b2\x1c.vega.EthereumContractConfigR\x15staki\
    ngBridgeContract\x12R\n\x16token_vesting_contract\x18\x06\x20\x01(\x0b2\
    \x1c.vega.EthereumContractConfigR\x14tokenVestingContract\x12X\n\x19mult\
    isig_control_contract\x18\x07\x20\x01(\x0b2\x1c.vega.EthereumContractCon\
    figR\x17multisigControlContract\"j\n\x16EthereumContractConfig\x12\x18\n\
    \x07address\x18\x01\x20\x01(\tR\x07address\x126\n\x17deployment_block_he\
    ight\x18\x06\x20\x01(\x04R\x15deploymentBlockHeight\"\xac\x01\n\x0fEpoch\
    Timestamps\x12\x1d\n\nstart_time\x18\x01\x20\x01(\x03R\tstartTime\x12\
    \x1f\n\x0bexpiry_time\x18\x02\x20\x01(\x03R\nexpiryTime\x12\x19\n\x08end\
    _time\x18\x03\x20\x01(\x03R\x07endTime\x12\x1f\n\x0bfirst_block\x18\x04\
    \x20\x01(\x04R\nfirstBlock\x12\x1d\n\nlast_block\x18\x05\x20\x01(\x04R\t\
    lastBlock\"\xb0\x01\n\x05Epoch\x12\x10\n\x03seq\x18\x01\x20\x01(\x04R\
    \x03seq\x125\n\ntimestamps\x18\x02\x20\x01(\x0b2\x15.vega.EpochTimestamp\
    sR\ntimestamps\x12*\n\nvalidators\x18\x03\x20\x03(\x0b2\n.vega.NodeR\nva\
    lidators\x122\n\x0bdelegations\x18\x04\x20\x03(\x0b2\x10.vega.Delegation\
    R\x0bdelegations\"\x8e\x01\n\x12EpochParticipation\x12!\n\x05epoch\x18\
    \x01\x20\x01(\x0b2\x0b.vega.EpochR\x05epoch\x12\x18\n\x07offline\x18\x02\
    \x20\x01(\x04R\x07offline\x12\x16\n\x06online\x18\x03\x20\x01(\x04R\x06o\
    nline\x12#\n\rtotal_rewards\x18\x04\x20\x01(\x01R\x0ctotalRewards\"S\n\t\
    EpochData\x12\x14\n\x05total\x18\x01\x20\x01(\x05R\x05total\x12\x18\n\
    \x07offline\x18\x02\x20\x01(\x05R\x07offline\x12\x16\n\x06online\x18\x03\
    \x20\x01(\x05R\x06online\"\x9b\x02\n\x0cRankingScore\x12\x1f\n\x0bstake_\
    score\x18\x01\x20\x01(\tR\nstakeScore\x12+\n\x11performance_score\x18\
    \x02\x20\x01(\tR\x10performanceScore\x12B\n\x0fprevious_status\x18\x03\
    \x20\x01(\x0e2\x19.vega.ValidatorNodeStatusR\x0epreviousStatus\x121\n\
    \x06status\x18\x04\x20\x01(\x0e2\x19.vega.ValidatorNodeStatusR\x06status\
    \x12!\n\x0cvoting_power\x18\x05\x20\x01(\rR\x0bvotingPower\x12#\n\rranki\
    ng_score\x18\x06\x20\x01(\tR\x0crankingScore\"\xab\x02\n\x0bRewardScore\
    \x12.\n\x13raw_validator_score\x18\x01\x20\x01(\tR\x11rawValidatorScore\
    \x12+\n\x11performance_score\x18\x02\x20\x01(\tR\x10performanceScore\x12\
    %\n\x0emultisig_score\x18\x03\x20\x01(\tR\rmultisigScore\x12'\n\x0fvalid\
    ator_score\x18\x04\x20\x01(\tR\x0evalidatorScore\x12)\n\x10normalised_sc\
    ore\x18\x05\x20\x01(\tR\x0fnormalisedScore\x12D\n\x10validator_status\
    \x18\x06\x20\x01(\x0e2\x19.vega.ValidatorNodeStatusR\x0fvalidatorStatus\
    \"\xb3\x05\n\x04Node\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x17\n\
    \x07pub_key\x18\x02\x20\x01(\tR\x06pubKey\x12\x1c\n\ntm_pub_key\x18\x03\
    \x20\x01(\tR\x08tmPubKey\x12)\n\x10ethereum_address\x18\x04\x20\x01(\tR\
    \x0fethereumAddress\x12\x19\n\x08info_url\x18\x05\x20\x01(\tR\x07infoUrl\
    \x12\x1a\n\x08location\x18\x06\x20\x01(\tR\x08location\x12,\n\x12staked_\
    by_operator\x18\x07\x20\x01(\tR\x10stakedByOperator\x12.\n\x13staked_by_\
    delegates\x18\x08\x20\x01(\tR\x11stakedByDelegates\x12!\n\x0cstaked_tota\
    l\x18\t\x20\x01(\tR\x0bstakedTotal\x12,\n\x12max_intended_stake\x18\n\
    \x20\x01(\tR\x10maxIntendedStake\x12#\n\rpending_stake\x18\x0b\x20\x01(\
    \tR\x0cpendingStake\x12.\n\nepoch_data\x18\x0c\x20\x01(\x0b2\x0f.vega.Ep\
    ochDataR\tepochData\x12(\n\x06status\x18\r\x20\x01(\x0e2\x10.vega.NodeSt\
    atusR\x06status\x122\n\x0bdelegations\x18\x0e\x20\x03(\x0b2\x10.vega.Del\
    egationR\x0bdelegations\x124\n\x0creward_score\x18\x0f\x20\x01(\x0b2\x11\
    .vega.RewardScoreR\x0brewardScore\x127\n\rranking_score\x18\x10\x20\x01(\
    \x0b2\x12.vega.RankingScoreR\x0crankingScore\x12\x12\n\x04name\x18\x11\
    \x20\x01(\tR\x04name\x12\x1d\n\navatar_url\x18\x12\x20\x01(\tR\tavatarUr\
    l\"\xb8\x01\n\x08NodeData\x12!\n\x0cstaked_total\x18\x01\x20\x01(\tR\x0b\
    stakedTotal\x12\x1f\n\x0btotal_nodes\x18\x02\x20\x01(\rR\ntotalNodes\x12\
    %\n\x0einactive_nodes\x18\x03\x20\x01(\rR\rinactiveNodes\x12)\n\x10valid\
    ating_nodes\x18\x04\x20\x01(\rR\x0fvalidatingNodes\x12\x16\n\x06uptime\
    \x18\x05\x20\x01(\x02R\x06uptime\"p\n\nDelegation\x12\x14\n\x05party\x18\
    \x01\x20\x01(\tR\x05party\x12\x17\n\x07node_id\x18\x02\x20\x01(\tR\x06no\
    deId\x12\x16\n\x06amount\x18\x03\x20\x01(\tR\x06amount\x12\x1b\n\tepoch_\
    seq\x18\x04\x20\x01(\tR\x08epochSeq\"\xfb\x01\n\x06Reward\x12\x19\n\x08a\
    sset_id\x18\x01\x20\x01(\tR\x07assetId\x12\x19\n\x08party_id\x18\x02\x20\
    \x01(\tR\x07partyId\x12\x14\n\x05epoch\x18\x03\x20\x01(\x04R\x05epoch\
    \x12\x16\n\x06amount\x18\x04\x20\x01(\tR\x06amount\x12.\n\x13percentage_\
    of_total\x18\x05\x20\x01(\tR\x11percentageOfTotal\x12\x1f\n\x0breceived_\
    at\x18\x06\x20\x01(\x03R\nreceivedAt\x12\x1b\n\tmarket_id\x18\x07\x20\
    \x01(\tR\x08marketId\x12\x1f\n\x0breward_type\x18\x08\x20\x01(\tR\nrewar\
    dType\"]\n\rRewardSummary\x12\x19\n\x08asset_id\x18\x01\x20\x01(\tR\x07a\
    ssetId\x12\x19\n\x08party_id\x18\x02\x20\x01(\tR\x07partyId\x12\x16\n\
    \x06amount\x18\x03\x20\x01(\tR\x06amount\"y\n\x12StateValueProposal\x12\
    \x20\n\x0cstate_var_id\x18\x01\x20\x01(\tR\nstateVarId\x12\x19\n\x08even\
    t_id\x18\x02\x20\x01(\tR\x07eventId\x12&\n\x03kvb\x18\x03\x20\x03(\x0b2\
    \x14.vega.KeyValueBundleR\x03kvb\"k\n\x0eKeyValueBundle\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x1c\n\ttolerance\x18\x02\x20\x01(\tR\tto\
    lerance\x12)\n\x05value\x18\x03\x20\x01(\x0b2\x13.vega.StateVarValueR\
    \x05value\"\xb4\x01\n\rStateVarValue\x122\n\nscalar_val\x18\x01\x20\x01(\
    \x0b2\x11.vega.ScalarValueH\0R\tscalarVal\x122\n\nvector_val\x18\x02\x20\
    \x01(\x0b2\x11.vega.VectorValueH\0R\tvectorVal\x122\n\nmatrix_val\x18\
    \x03\x20\x01(\x0b2\x11.vega.MatrixValueH\0R\tmatrixValB\x07\n\x05value\"\
    #\n\x0bScalarValue\x12\x14\n\x05value\x18\x01\x20\x01(\tR\x05value\"#\n\
    \x0bVectorValue\x12\x14\n\x05value\x18\x01\x20\x03(\tR\x05value\"6\n\x0b\
    MatrixValue\x12'\n\x05value\x18\x01\x20\x03(\x0b2\x11.vega.VectorValueR\
    \x05value*9\n\x04Side\x12\x14\n\x10SIDE_UNSPECIFIED\x10\0\x12\x0c\n\x08S\
    IDE_BUY\x10\x01\x12\r\n\tSIDE_SELL\x10\x02*\x98\x01\n\x08Interval\x12\
    \x18\n\x14INTERVAL_UNSPECIFIED\x10\0\x12\x10\n\x0cINTERVAL_I1M\x10<\x12\
    \x11\n\x0cINTERVAL_I5M\x10\xac\x02\x12\x12\n\rINTERVAL_I15M\x10\x84\x07\
    \x12\x11\n\x0cINTERVAL_I1H\x10\x90\x1c\x12\x12\n\x0cINTERVAL_I6H\x10\xe0\
    \xa8\x01\x12\x12\n\x0cINTERVAL_I1D\x10\x80\xa3\x05*\xa3\x01\n\x0eAuction\
    Trigger\x12\x1f\n\x1bAUCTION_TRIGGER_UNSPECIFIED\x10\0\x12\x19\n\x15AUCT\
    ION_TRIGGER_BATCH\x10\x01\x12\x1b\n\x17AUCTION_TRIGGER_OPENING\x10\x02\
    \x12\x19\n\x15AUCTION_TRIGGER_PRICE\x10\x03\x12\x1d\n\x19AUCTION_TRIGGER\
    _LIQUIDITY\x10\x04*\x8b\x01\n\x0fPeggedReference\x12\x20\n\x1cPEGGED_REF\
    ERENCE_UNSPECIFIED\x10\0\x12\x18\n\x14PEGGED_REFERENCE_MID\x10\x01\x12\
    \x1d\n\x19PEGGED_REFERENCE_BEST_BID\x10\x02\x12\x1d\n\x19PEGGED_REFERENC\
    E_BEST_ASK\x10\x03*\x9f\x0f\n\nOrderError\x12\x1b\n\x17ORDER_ERROR_UNSPE\
    CIFIED\x10\0\x12!\n\x1dORDER_ERROR_INVALID_MARKET_ID\x10\x01\x12\x20\n\
    \x1cORDER_ERROR_INVALID_ORDER_ID\x10\x02\x12\x1f\n\x1bORDER_ERROR_OUT_OF\
    _SEQUENCE\x10\x03\x12&\n\"ORDER_ERROR_INVALID_REMAINING_SIZE\x10\x04\x12\
    \x1c\n\x18ORDER_ERROR_TIME_FAILURE\x10\x05\x12\x1f\n\x1bORDER_ERROR_REMO\
    VAL_FAILURE\x10\x06\x12+\n'ORDER_ERROR_INVALID_EXPIRATION_DATETIME\x10\
    \x07\x12'\n#ORDER_ERROR_INVALID_ORDER_REFERENCE\x10\x08\x12\x20\n\x1cORD\
    ER_ERROR_EDIT_NOT_ALLOWED\x10\t\x12\x1d\n\x19ORDER_ERROR_AMEND_FAILURE\
    \x10\n\x12\x19\n\x15ORDER_ERROR_NOT_FOUND\x10\x0b\x12\x20\n\x1cORDER_ERR\
    OR_INVALID_PARTY_ID\x10\x0c\x12\x1d\n\x19ORDER_ERROR_MARKET_CLOSED\x10\r\
    \x12#\n\x1fORDER_ERROR_MARGIN_CHECK_FAILED\x10\x0e\x12'\n#ORDER_ERROR_MI\
    SSING_GENERAL_ACCOUNT\x10\x0f\x12\x1e\n\x1aORDER_ERROR_INTERNAL_ERROR\
    \x10\x10\x12\x1c\n\x18ORDER_ERROR_INVALID_SIZE\x10\x11\x12#\n\x1fORDER_E\
    RROR_INVALID_PERSISTENCE\x10\x12\x12\x1c\n\x18ORDER_ERROR_INVALID_TYPE\
    \x10\x13\x12\x1c\n\x18ORDER_ERROR_SELF_TRADING\x10\x14\x12.\n*ORDER_ERRO\
    R_INSUFFICIENT_FUNDS_TO_PAY_FEES\x10\x15\x12%\n!ORDER_ERROR_INCORRECT_MA\
    RKET_TYPE\x10\x16\x12%\n!ORDER_ERROR_INVALID_TIME_IN_FORCE\x10\x17\x12+\
    \n'ORDER_ERROR_GFN_ORDER_DURING_AN_AUCTION\x10\x18\x123\n/ORDER_ERROR_GF\
    A_ORDER_DURING_CONTINUOUS_TRADING\x10\x19\x124\n0ORDER_ERROR_CANNOT_AMEN\
    D_TO_GTT_WITHOUT_EXPIRYAT\x10\x1a\x12)\n%ORDER_ERROR_EXPIRYAT_BEFORE_CRE\
    ATEDAT\x10\x1b\x12,\n(ORDER_ERROR_CANNOT_HAVE_GTC_AND_EXPIRYAT\x10\x1c\
    \x12*\n&ORDER_ERROR_CANNOT_AMEND_TO_FOK_OR_IOC\x10\x1d\x12*\n&ORDER_ERRO\
    R_CANNOT_AMEND_TO_GFA_OR_GFN\x10\x1e\x12,\n(ORDER_ERROR_CANNOT_AMEND_FRO\
    M_GFA_OR_GFN\x10\x1f\x124\n0ORDER_ERROR_CANNOT_SEND_IOC_ORDER_DURING_AUC\
    TION\x10\x20\x124\n0ORDER_ERROR_CANNOT_SEND_FOK_ORDER_DURING_AUCTION\x10\
    !\x12#\n\x1fORDER_ERROR_MUST_BE_LIMIT_ORDER\x10\"\x12\"\n\x1eORDER_ERROR\
    _MUST_BE_GTT_OR_GTC\x10#\x12'\n#ORDER_ERROR_WITHOUT_REFERENCE_PRICE\x10$\
    \x123\n/ORDER_ERROR_BUY_CANNOT_REFERENCE_BEST_ASK_PRICE\x10%\x127\n3ORDE\
    R_ERROR_OFFSET_MUST_BE_GREATER_OR_EQUAL_TO_ZERO\x10(\x124\n0ORDER_ERROR_\
    SELL_CANNOT_REFERENCE_BEST_BID_PRICE\x10)\x120\n,ORDER_ERROR_OFFSET_MUST\
    _BE_GREATER_THAN_ZERO\x10*\x12*\n&ORDER_ERROR_INSUFFICIENT_ASSET_BALANCE\
    \x10+\x12E\nAORDER_ERROR_CANNOT_AMEND_PEGGED_ORDER_DETAILS_ON_NON_PEGGED\
    _ORDER\x10,\x12.\n*ORDER_ERROR_UNABLE_TO_REPRICE_PEGGED_ORDER\x10-\x125\
    \n1ORDER_ERROR_UNABLE_TO_AMEND_PRICE_ON_PEGGED_ORDER\x10.\x128\n4ORDER_E\
    RROR_NON_PERSISTENT_ORDER_OUT_OF_PRICE_BOUNDS\x10/\"\x04\x08&\x10&\"\x04\
    \x08'\x10'*\x82\x01\n\x0bChainStatus\x12\x1c\n\x18CHAIN_STATUS_UNSPECIFI\
    ED\x10\0\x12\x1d\n\x19CHAIN_STATUS_DISCONNECTED\x10\x01\x12\x1a\n\x16CHA\
    IN_STATUS_REPLAYING\x10\x02\x12\x1a\n\x16CHAIN_STATUS_CONNECTED\x10\x03*\
    \xc4\x04\n\x0bAccountType\x12\x1c\n\x18ACCOUNT_TYPE_UNSPECIFIED\x10\0\
    \x12\x1a\n\x16ACCOUNT_TYPE_INSURANCE\x10\x01\x12\x1b\n\x17ACCOUNT_TYPE_S\
    ETTLEMENT\x10\x02\x12\x17\n\x13ACCOUNT_TYPE_MARGIN\x10\x03\x12\x18\n\x14\
    ACCOUNT_TYPE_GENERAL\x10\x04\x12$\n\x20ACCOUNT_TYPE_FEES_INFRASTRUCTURE\
    \x10\x05\x12\x1f\n\x1bACCOUNT_TYPE_FEES_LIQUIDITY\x10\x06\x12\x1b\n\x17A\
    CCOUNT_TYPE_FEES_MAKER\x10\x07\x12\x15\n\x11ACCOUNT_TYPE_BOND\x10\t\x12\
    \x19\n\x15ACCOUNT_TYPE_EXTERNAL\x10\n\x12!\n\x1dACCOUNT_TYPE_GLOBAL_INSU\
    RANCE\x10\x0b\x12\x1e\n\x1aACCOUNT_TYPE_GLOBAL_REWARD\x10\x0c\x12\"\n\
    \x1eACCOUNT_TYPE_PENDING_TRANSFERS\x10\r\x12'\n#ACCOUNT_TYPE_REWARD_MAKE\
    R_PAID_FEES\x10\x0e\x12+\n'ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES\x10\
    \x0f\x12(\n$ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES\x10\x10\x12(\n$ACCOUNT_\
    TYPE_REWARD_MARKET_PROPOSERS\x10\x11\"\x04\x08\x08\x10\x08*\xf6\x06\n\
    \x0cTransferType\x12\x1d\n\x19TRANSFER_TYPE_UNSPECIFIED\x10\0\x12\x16\n\
    \x12TRANSFER_TYPE_LOSS\x10\x01\x12\x15\n\x11TRANSFER_TYPE_WIN\x10\x02\
    \x12\x17\n\x13TRANSFER_TYPE_CLOSE\x10\x03\x12\x1a\n\x16TRANSFER_TYPE_MTM\
    _LOSS\x10\x04\x12\x19\n\x15TRANSFER_TYPE_MTM_WIN\x10\x05\x12\x1c\n\x18TR\
    ANSFER_TYPE_MARGIN_LOW\x10\x06\x12\x1d\n\x19TRANSFER_TYPE_MARGIN_HIGH\
    \x10\x07\x12$\n\x20TRANSFER_TYPE_MARGIN_CONFISCATED\x10\x08\x12\x1f\n\
    \x1bTRANSFER_TYPE_MAKER_FEE_PAY\x10\t\x12#\n\x1fTRANSFER_TYPE_MAKER_FEE_\
    RECEIVE\x10\n\x12(\n$TRANSFER_TYPE_INFRASTRUCTURE_FEE_PAY\x10\x0b\x12/\n\
    +TRANSFER_TYPE_INFRASTRUCTURE_FEE_DISTRIBUTE\x10\x0c\x12#\n\x1fTRANSFER_\
    TYPE_LIQUIDITY_FEE_PAY\x10\r\x12*\n&TRANSFER_TYPE_LIQUIDITY_FEE_DISTRIBU\
    TE\x10\x0e\x12\x1a\n\x16TRANSFER_TYPE_BOND_LOW\x10\x0f\x12\x1b\n\x17TRAN\
    SFER_TYPE_BOND_HIGH\x10\x10\x12\x1f\n\x1bTRANSFER_TYPE_WITHDRAW_LOCK\x10\
    \x11\x12\x1a\n\x16TRANSFER_TYPE_WITHDRAW\x10\x12\x12\x19\n\x15TRANSFER_T\
    YPE_DEPOSIT\x10\x13\x12\x1f\n\x1bTRANSFER_TYPE_BOND_SLASHING\x10\x14\x12\
    \x1e\n\x1aTRANSFER_TYPE_STAKE_REWARD\x10\x15\x12%\n!TRANSFER_TYPE_TRANSF\
    ER_FUNDS_SEND\x10\x16\x12+\n'TRANSFER_TYPE_TRANSFER_FUNDS_DISTRIBUTE\x10\
    \x17\x12\x1f\n\x1bTRANSFER_TYPE_CLEAR_ACCOUNT\x10\x18\x12,\n(TRANSFER_TY\
    PE_CHECKPOINT_BALANCE_RESTORE\x10\x19*\xc7\x01\n\x0eDispatchMetric\x12\
    \x1f\n\x1bDISPATCH_METRIC_UNSPECIFIED\x10\0\x12#\n\x1fDISPATCH_METRIC_MA\
    KER_FEES_PAID\x10\x01\x12'\n#DISPATCH_METRIC_MAKER_FEES_RECEIVED\x10\x02\
    \x12$\n\x20DISPATCH_METRIC_LP_FEES_RECEIVED\x10\x03\x12\x20\n\x1cDISPATC\
    H_METRIC_MARKET_VALUE\x10\x04*c\n\nNodeStatus\x12\x1b\n\x17NODE_STATUS_U\
    NSPECIFIED\x10\0\x12\x19\n\x15NODE_STATUS_VALIDATOR\x10\x01\x12\x1d\n\
    \x19NODE_STATUS_NON_VALIDATOR\x10\x02*Y\n\x0bEpochAction\x12\x1c\n\x18EP\
    OCH_ACTION_UNSPECIFIED\x10\0\x12\x16\n\x12EPOCH_ACTION_START\x10\x01\x12\
    \x14\n\x10EPOCH_ACTION_END\x10\x02*\xa7\x01\n\x13ValidatorNodeStatus\x12\
    %\n!VALIDATOR_NODE_STATUS_UNSPECIFIED\x10\0\x12$\n\x20VALIDATOR_NODE_STA\
    TUS_TENDERMINT\x10\x01\x12\x20\n\x1cVALIDATOR_NODE_STATUS_ERSATZ\x10\x02\
    \x12!\n\x1dVALIDATOR_NODE_STATUS_PENDING\x10\x03B'Z%code.vegaprotocol.io\
    /vega/protos/vegab\x06proto3\
";
    /// `FileDescriptorProto` object which was a source for this generated file
    fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
        static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<
            ::protobuf::descriptor::FileDescriptorProto,
        > = ::protobuf::rt::Lazy::new();
        file_descriptor_proto_lazy
            .get(|| {
                ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data)
                    .unwrap()
            })
    }
    /// `FileDescriptor` object which allows dynamic access to files
    pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
        static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<
            ::protobuf::reflect::GeneratedFileDescriptor,
        > = ::protobuf::rt::Lazy::new();
        static file_descriptor: ::protobuf::rt::Lazy<
            ::protobuf::reflect::FileDescriptor,
        > = ::protobuf::rt::Lazy::new();
        file_descriptor
            .get(|| {
                let generated_file_descriptor = generated_file_descriptor_lazy
                    .get(|| {
                        let mut deps = ::std::vec::Vec::with_capacity(1);
                        deps.push(super::markets::file_descriptor().clone());
                        let mut messages = ::std::vec::Vec::with_capacity(58);
                        messages.push(Party::generated_message_descriptor_data());
                        messages.push(RiskFactor::generated_message_descriptor_data());
                        messages.push(PeggedOrder::generated_message_descriptor_data());
                        messages.push(Order::generated_message_descriptor_data());
                        messages
                            .push(
                                OrderCancellationConfirmation::generated_message_descriptor_data(),
                            );
                        messages
                            .push(
                                OrderConfirmation::generated_message_descriptor_data(),
                            );
                        messages
                            .push(
                                AuctionIndicativeState::generated_message_descriptor_data(),
                            );
                        messages.push(Trade::generated_message_descriptor_data());
                        messages.push(Fee::generated_message_descriptor_data());
                        messages.push(TradeSet::generated_message_descriptor_data());
                        messages.push(Candle::generated_message_descriptor_data());
                        messages.push(PriceLevel::generated_message_descriptor_data());
                        messages.push(MarketDepth::generated_message_descriptor_data());
                        messages
                            .push(
                                MarketDepthUpdate::generated_message_descriptor_data(),
                            );
                        messages.push(Position::generated_message_descriptor_data());
                        messages
                            .push(PositionTrade::generated_message_descriptor_data());
                        messages.push(Deposit::generated_message_descriptor_data());
                        messages.push(Withdrawal::generated_message_descriptor_data());
                        messages.push(WithdrawExt::generated_message_descriptor_data());
                        messages
                            .push(Erc20WithdrawExt::generated_message_descriptor_data());
                        messages.push(Account::generated_message_descriptor_data());
                        messages
                            .push(FinancialAmount::generated_message_descriptor_data());
                        messages.push(Transfer::generated_message_descriptor_data());
                        messages
                            .push(DispatchStrategy::generated_message_descriptor_data());
                        messages
                            .push(TransferRequest::generated_message_descriptor_data());
                        messages
                            .push(AccountDetails::generated_message_descriptor_data());
                        messages.push(LedgerEntry::generated_message_descriptor_data());
                        messages
                            .push(
                                PostTransferBalance::generated_message_descriptor_data(),
                            );
                        messages
                            .push(LedgerMovement::generated_message_descriptor_data());
                        messages.push(MarginLevels::generated_message_descriptor_data());
                        messages.push(MarketData::generated_message_descriptor_data());
                        messages
                            .push(
                                LiquidityProviderFeeShare::generated_message_descriptor_data(),
                            );
                        messages
                            .push(
                                PriceMonitoringBounds::generated_message_descriptor_data(),
                            );
                        messages.push(ErrorDetail::generated_message_descriptor_data());
                        messages
                            .push(NetworkParameter::generated_message_descriptor_data());
                        messages
                            .push(NetworkLimits::generated_message_descriptor_data());
                        messages
                            .push(LiquidityOrder::generated_message_descriptor_data());
                        messages
                            .push(
                                LiquidityOrderReference::generated_message_descriptor_data(),
                            );
                        messages
                            .push(
                                LiquidityProvision::generated_message_descriptor_data(),
                            );
                        messages
                            .push(EthereumConfig::generated_message_descriptor_data());
                        messages
                            .push(
                                EthereumContractConfig::generated_message_descriptor_data(),
                            );
                        messages
                            .push(EpochTimestamps::generated_message_descriptor_data());
                        messages.push(Epoch::generated_message_descriptor_data());
                        messages
                            .push(
                                EpochParticipation::generated_message_descriptor_data(),
                            );
                        messages.push(EpochData::generated_message_descriptor_data());
                        messages.push(RankingScore::generated_message_descriptor_data());
                        messages.push(RewardScore::generated_message_descriptor_data());
                        messages.push(Node::generated_message_descriptor_data());
                        messages.push(NodeData::generated_message_descriptor_data());
                        messages.push(Delegation::generated_message_descriptor_data());
                        messages.push(Reward::generated_message_descriptor_data());
                        messages
                            .push(RewardSummary::generated_message_descriptor_data());
                        messages
                            .push(
                                StateValueProposal::generated_message_descriptor_data(),
                            );
                        messages
                            .push(KeyValueBundle::generated_message_descriptor_data());
                        messages
                            .push(StateVarValue::generated_message_descriptor_data());
                        messages.push(ScalarValue::generated_message_descriptor_data());
                        messages.push(VectorValue::generated_message_descriptor_data());
                        messages.push(MatrixValue::generated_message_descriptor_data());
                        let mut enums = ::std::vec::Vec::with_capacity(19);
                        enums.push(Side::generated_enum_descriptor_data());
                        enums.push(Interval::generated_enum_descriptor_data());
                        enums.push(AuctionTrigger::generated_enum_descriptor_data());
                        enums.push(PeggedReference::generated_enum_descriptor_data());
                        enums.push(OrderError::generated_enum_descriptor_data());
                        enums.push(ChainStatus::generated_enum_descriptor_data());
                        enums.push(AccountType::generated_enum_descriptor_data());
                        enums.push(TransferType::generated_enum_descriptor_data());
                        enums.push(DispatchMetric::generated_enum_descriptor_data());
                        enums.push(NodeStatus::generated_enum_descriptor_data());
                        enums.push(EpochAction::generated_enum_descriptor_data());
                        enums
                            .push(ValidatorNodeStatus::generated_enum_descriptor_data());
                        enums.push(order::TimeInForce::generated_enum_descriptor_data());
                        enums.push(order::Type::generated_enum_descriptor_data());
                        enums.push(order::Status::generated_enum_descriptor_data());
                        enums.push(trade::Type::generated_enum_descriptor_data());
                        enums.push(deposit::Status::generated_enum_descriptor_data());
                        enums.push(withdrawal::Status::generated_enum_descriptor_data());
                        enums
                            .push(
                                liquidity_provision::Status::generated_enum_descriptor_data(),
                            );
                        ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                            file_descriptor_proto(),
                            deps,
                            messages,
                            enums,
                        )
                    });
                ::protobuf::reflect::FileDescriptor::new_generated_2(
                    generated_file_descriptor,
                )
            })
    }
}
